<!DOCTYPE html>
<html lang="zh-cn">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Go-深入理解内存分配">
<meta itemprop="description" content="深入理解内存分配 CPU缓存 CPU的发展的速度远快于内存的发展，CPU的处理速度也比内存访问速度快很多。这样很多情况下，CPU必须要等内存的相应，为了应对这种情况，CPU多谢缓存就出现了。
计算机内存金字塔图 缓存大小L1&lt;L2&lt;L3, 速度L1&gt;L2&gt;L3， L1和L2通常用在单核中，L3则用来多核中。CPU缓存的命中率代表了CPU缓存复用的情况。 CPU读取数据是从先从缓存中寻找，如果找到就立即返回给CPU处理，如果没有找到，就从相对慢的速度中读取并返回给CPU处理，同时把这个数据加入缓存中。
程序内存 unix系统进程内存占用示意图  text段在内存映射中是只读的，data和bss是可读可写 data和bss属于静态内存分配。data是初始化过的，bss是未出华的  TCmalloc TCmalloc全称Thread-Cacheing Malloc, 即线程缓存的malloc，是由Google开发的内存分配器(https://gperftools.github.io/gperftools/tcmalloc.html)。
TCmalloc通过多级缓存，降低了多线程中锁竞争的情况，通过不同的sizeclass，空间利用率高，碎片少。
如果想了解细节可以看下：
 tcmalloc浅析 TCMalloc解密  Go内存分配 Golang内存分配最开始也是TCmalloc的，后来再次基础上也改动了许多，包括内存池、预分配和延迟分配等。
介绍 Page: Golang里面的Page大小是8KB（x64操作系统页一般是4KB），一般是操作系统页的几倍 maxTinySize： 小于16Byte tinySizeClass: 16B &lt; size &lt;= 32KB maxSmallSize： size &gt; 32K Spans: 存放mspan的指针，指针大小是8byte，每个指针指向arena的一个page bitmap:用于保存arena对应某个地址是否存在对象，以及对象是否被GC扫描过 arena：由一堆page组成 object:
从别的地方引用的一张内存管理图 go内存结构 总共分为3个区域，spans，bitmap和areaa
mspan 每个mspan对一个一个page bitmap 每个bitmap对应arena 4个指针的内存，相当于2bit对应1个指针大小的内存，两个2bit分别代表是否指针和是否应该扫描 size class 每个mspan会按照SizeClass的大小分配成若干的object，每个object可以存储一个对象。并且使用allocBits表示object使用情况，mspan会按照上面的分配原则给object分配对象
// class bytes/obj bytes/span objects tail waste max waste // 1 8 8192 1024 0 87.">
<meta itemprop="datePublished" content="2021-06-27T09:32:23+08:00" />
<meta itemprop="dateModified" content="2021-06-27T09:32:23+08:00" />
<meta itemprop="wordCount" content="3728">



<meta itemprop="keywords" content="" />
<meta property="og:title" content="Go-深入理解内存分配" />
<meta property="og:description" content="深入理解内存分配 CPU缓存 CPU的发展的速度远快于内存的发展，CPU的处理速度也比内存访问速度快很多。这样很多情况下，CPU必须要等内存的相应，为了应对这种情况，CPU多谢缓存就出现了。
计算机内存金字塔图 缓存大小L1&lt;L2&lt;L3, 速度L1&gt;L2&gt;L3， L1和L2通常用在单核中，L3则用来多核中。CPU缓存的命中率代表了CPU缓存复用的情况。 CPU读取数据是从先从缓存中寻找，如果找到就立即返回给CPU处理，如果没有找到，就从相对慢的速度中读取并返回给CPU处理，同时把这个数据加入缓存中。
程序内存 unix系统进程内存占用示意图  text段在内存映射中是只读的，data和bss是可读可写 data和bss属于静态内存分配。data是初始化过的，bss是未出华的  TCmalloc TCmalloc全称Thread-Cacheing Malloc, 即线程缓存的malloc，是由Google开发的内存分配器(https://gperftools.github.io/gperftools/tcmalloc.html)。
TCmalloc通过多级缓存，降低了多线程中锁竞争的情况，通过不同的sizeclass，空间利用率高，碎片少。
如果想了解细节可以看下：
 tcmalloc浅析 TCMalloc解密  Go内存分配 Golang内存分配最开始也是TCmalloc的，后来再次基础上也改动了许多，包括内存池、预分配和延迟分配等。
介绍 Page: Golang里面的Page大小是8KB（x64操作系统页一般是4KB），一般是操作系统页的几倍 maxTinySize： 小于16Byte tinySizeClass: 16B &lt; size &lt;= 32KB maxSmallSize： size &gt; 32K Spans: 存放mspan的指针，指针大小是8byte，每个指针指向arena的一个page bitmap:用于保存arena对应某个地址是否存在对象，以及对象是否被GC扫描过 arena：由一堆page组成 object:
从别的地方引用的一张内存管理图 go内存结构 总共分为3个区域，spans，bitmap和areaa
mspan 每个mspan对一个一个page bitmap 每个bitmap对应arena 4个指针的内存，相当于2bit对应1个指针大小的内存，两个2bit分别代表是否指针和是否应该扫描 size class 每个mspan会按照SizeClass的大小分配成若干的object，每个object可以存储一个对象。并且使用allocBits表示object使用情况，mspan会按照上面的分配原则给object分配对象
// class bytes/obj bytes/span objects tail waste max waste // 1 8 8192 1024 0 87." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://leonzyang.github.io/posts/malloc/" />
<meta property="article:published_time" content="2021-06-27T09:32:23+08:00" />
<meta property="article:modified_time" content="2021-06-27T09:32:23+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go-深入理解内存分配"/>
<meta name="twitter:description" content="深入理解内存分配 CPU缓存 CPU的发展的速度远快于内存的发展，CPU的处理速度也比内存访问速度快很多。这样很多情况下，CPU必须要等内存的相应，为了应对这种情况，CPU多谢缓存就出现了。
计算机内存金字塔图 缓存大小L1&lt;L2&lt;L3, 速度L1&gt;L2&gt;L3， L1和L2通常用在单核中，L3则用来多核中。CPU缓存的命中率代表了CPU缓存复用的情况。 CPU读取数据是从先从缓存中寻找，如果找到就立即返回给CPU处理，如果没有找到，就从相对慢的速度中读取并返回给CPU处理，同时把这个数据加入缓存中。
程序内存 unix系统进程内存占用示意图  text段在内存映射中是只读的，data和bss是可读可写 data和bss属于静态内存分配。data是初始化过的，bss是未出华的  TCmalloc TCmalloc全称Thread-Cacheing Malloc, 即线程缓存的malloc，是由Google开发的内存分配器(https://gperftools.github.io/gperftools/tcmalloc.html)。
TCmalloc通过多级缓存，降低了多线程中锁竞争的情况，通过不同的sizeclass，空间利用率高，碎片少。
如果想了解细节可以看下：
 tcmalloc浅析 TCMalloc解密  Go内存分配 Golang内存分配最开始也是TCmalloc的，后来再次基础上也改动了许多，包括内存池、预分配和延迟分配等。
介绍 Page: Golang里面的Page大小是8KB（x64操作系统页一般是4KB），一般是操作系统页的几倍 maxTinySize： 小于16Byte tinySizeClass: 16B &lt; size &lt;= 32KB maxSmallSize： size &gt; 32K Spans: 存放mspan的指针，指针大小是8byte，每个指针指向arena的一个page bitmap:用于保存arena对应某个地址是否存在对象，以及对象是否被GC扫描过 arena：由一堆page组成 object:
从别的地方引用的一张内存管理图 go内存结构 总共分为3个区域，spans，bitmap和areaa
mspan 每个mspan对一个一个page bitmap 每个bitmap对应arena 4个指针的内存，相当于2bit对应1个指针大小的内存，两个2bit分别代表是否指针和是否应该扫描 size class 每个mspan会按照SizeClass的大小分配成若干的object，每个object可以存储一个对象。并且使用allocBits表示object使用情况，mspan会按照上面的分配原则给object分配对象
// class bytes/obj bytes/span objects tail waste max waste // 1 8 8192 1024 0 87."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Go-深入理解内存分配</title>
	<link rel="stylesheet" href="https://leonzyang.github.io/css/style.min.eac77496566fd7d5768fd650ddb0b2b181ca6a2d7c5fdd6fe6b8ba4bf47e566f.css" integrity="sha256-6sd0llZv19V2j9ZQ3bCysYHKai18X91v5ri6S/R+Vm8=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://leonzyang.github.io">LeonZhao的小木屋</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://leonzyang.github.io/posts/">博客</a>
				<a href="https://leonzyang.github.io/datastruct/">数据结构</a>
				<a href="https://leonzyang.github.io/algo/">算法</a>
				<a href="https://leonzyang.github.io/network/">网络</a>
				<a href="https://leonzyang.github.io/interview/">面试</a>
				<a href="https://leonzyang.github.io/about/">关于</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://leonzyang.github.io/posts/">博客</a></li>
			<li><a href="https://leonzyang.github.io/datastruct/">数据结构</a></li>
			<li><a href="https://leonzyang.github.io/algo/">算法</a></li>
			<li><a href="https://leonzyang.github.io/network/">网络</a></li>
			<li><a href="https://leonzyang.github.io/interview/">面试</a></li>
			<li><a href="https://leonzyang.github.io/about/">关于</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jun 27, 2021</span></div>
				<h1>Go-深入理解内存分配</h1>
			</header>
			<div class="content">
				<h2 id="深入理解内存分配">深入理解内存分配<a href="#深入理解内存分配" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="cpu缓存">CPU缓存<a href="#cpu缓存" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>CPU的发展的速度远快于内存的发展，CPU的处理速度也比内存访问速度快很多。这样很多情况下，CPU必须要等内存的相应，为了应对这种情况，CPU多谢缓存就出现了。</p>
<p>计算机内存金字塔图
<img src="/posts/images/mem_line.png" alt="mem_line"></p>
<p><img src="/posts/images/cpu.png" alt="cpu">
缓存大小L1&lt;L2&lt;L3, 速度L1&gt;L2&gt;L3， L1和L2通常用在单核中，L3则用来多核中。CPU缓存的命中率代表了CPU缓存复用的情况。 CPU读取数据是从先从缓存中寻找，如果找到就立即返回给CPU处理，如果没有找到，就从相对慢的速度中读取并返回给CPU处理，同时把这个数据加入缓存中。</p>
<h3 id="程序内存">程序内存<a href="#程序内存" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>unix系统进程内存占用示意图
<img src="/posts/images/unix_mem.png" alt="mem1"></p>
<ul>
<li>text段在内存映射中是只读的，data和bss是可读可写</li>
<li>data和bss属于静态内存分配。data是初始化过的，bss是未出华的</li>
</ul>
<h3 id="tcmalloc">TCmalloc<a href="#tcmalloc" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>TCmalloc全称Thread-Cacheing Malloc, 即线程缓存的malloc，是由Google开发的内存分配器(<a href="https://gperftools.github.io/gperftools/tcmalloc.html">https://gperftools.github.io/gperftools/tcmalloc.html</a>)。</p>
<p>TCmalloc通过多级缓存，降低了多线程中锁竞争的情况，通过不同的sizeclass，空间利用率高，碎片少。</p>
<p><img src="/posts/images/tcmalloc.png" alt="tcmalloc"></p>
<p>如果想了解细节可以看下：</p>
<ul>
<li><a href="https://yq.aliyun.com/articles/6045">tcmalloc浅析</a></li>
<li><a href="https://wallenwang.com/2018/11/tcmalloc/">TCMalloc解密</a></li>
</ul>
<h3 id="go内存分配">Go内存分配<a href="#go内存分配" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Golang内存分配最开始也是TCmalloc的，后来再次基础上也改动了许多，包括内存池、预分配和延迟分配等。</p>
<h4 id="介绍">介绍<a href="#介绍" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>Page: Golang里面的Page大小是8KB（x64操作系统页一般是4KB），一般是操作系统页的几倍
maxTinySize： 小于16Byte
tinySizeClass: 16B &lt; size &lt;= 32KB
maxSmallSize： size &gt; 32K
Spans: 存放mspan的指针，指针大小是8byte，每个指针指向arena的一个page
bitmap:用于保存arena对应某个地址是否存在对象，以及对象是否被GC扫描过
arena：由一堆page组成
object:</p>
<p>从别的地方引用的一张内存管理图
<img src="/posts/images/mem.png" alt="mem"></p>
<h4 id="go内存结构">go内存结构<a href="#go内存结构" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p><img src="/posts/images/mheap.png" alt="heap">
总共分为3个区域，spans，bitmap和areaa</p>
<h5 id="mspan">mspan<a href="#mspan" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>每个mspan对一个一个page
<img src="/posts/images/spans.png" alt="spans"></p>
<h5 id="bitmap">bitmap<a href="#bitmap" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>每个bitmap对应arena 4个指针的内存，相当于2bit对应1个指针大小的内存，两个2bit分别代表是否指针和是否应该扫描
<img src="/posts/images/bitmap.png" alt="bitmap"></p>
<h4 id="size-class">size class<a href="#size-class" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>每个mspan会按照SizeClass的大小分配成若干的object，每个object可以存储一个对象。并且使用allocBits表示object使用情况，mspan会按照上面的分配原则给object分配对象</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// class  bytes/obj  bytes/span  objects  tail waste  max waste
</span><span class="c1">//     1          8        8192     1024           0     87.50%
</span><span class="c1">//     2         16        8192      512           0     43.75%
</span><span class="c1">//     3         32        8192      256           0     46.88%
</span><span class="c1">//     4         48        8192      170          32     31.52%
</span><span class="c1">//     5         64        8192      128           0     23.44%
</span><span class="c1">//     6         80        8192      102          32     19.07%
</span><span class="c1">//     7         96        8192       85          32     15.95%
</span><span class="c1">//     8        112        8192       73          16     13.56%
</span><span class="c1">//     9        128        8192       64           0     11.72%
</span><span class="c1">//    10        144        8192       56         128     11.82%
</span><span class="c1">//    11        160        8192       51          32      9.73%
</span><span class="c1">//    12        176        8192       46          96      9.59%
</span><span class="c1">//    13        192        8192       42         128      9.25%
</span><span class="c1">//    14        208        8192       39          80      8.12%
</span><span class="c1">//    15        224        8192       36         128      8.15%
</span><span class="c1">//    16        240        8192       34          32      6.62%
</span><span class="c1">//    17        256        8192       32           0      5.86%
</span><span class="c1">//    18        288        8192       28         128     12.16%
</span><span class="c1">//    19        320        8192       25         192     11.80%
</span><span class="c1">//    20        352        8192       23          96      9.88%
</span><span class="c1">//    21        384        8192       21         128      9.51%
</span><span class="c1">//    22        416        8192       19         288     10.71%
</span><span class="c1">//    23        448        8192       18         128      8.37%
</span><span class="c1">//    24        480        8192       17          32      6.82%
</span><span class="c1">//    25        512        8192       16           0      6.05%
</span><span class="c1">//    26        576        8192       14         128     12.33%
</span><span class="c1">//    27        640        8192       12         512     15.48%
</span><span class="c1">//    28        704        8192       11         448     13.93%
</span><span class="c1">//    29        768        8192       10         512     13.94%
</span><span class="c1">//    30        896        8192        9         128     15.52%
</span><span class="c1">//    31       1024        8192        8           0     12.40%
</span><span class="c1">//    32       1152        8192        7         128     12.41%
</span><span class="c1">//    33       1280        8192        6         512     15.55%
</span><span class="c1">//    34       1408       16384       11         896     14.00%
</span><span class="c1">//    35       1536        8192        5         512     14.00%
</span><span class="c1">//    36       1792       16384        9         256     15.57%
</span><span class="c1">//    37       2048        8192        4           0     12.45%
</span><span class="c1">//    38       2304       16384        7         256     12.46%
</span><span class="c1">//    39       2688        8192        3         128     15.59%
</span><span class="c1">//    40       3072       24576        8           0     12.47%
</span><span class="c1">//    41       3200       16384        5         384      6.22%
</span><span class="c1">//    42       3456       24576        7         384      8.83%
</span><span class="c1">//    43       4096        8192        2           0     15.60%
</span><span class="c1">//    44       4864       24576        5         256     16.65%
</span><span class="c1">//    45       5376       16384        3         256     10.92%
</span><span class="c1">//    46       6144       24576        4           0     12.48%
</span><span class="c1">//    47       6528       32768        5         128      6.23%
</span><span class="c1">//    48       6784       40960        6         256      4.36%
</span><span class="c1">//    49       6912       49152        7         768      3.37%
</span><span class="c1">//    50       8192        8192        1           0     15.61%
</span><span class="c1">//    51       9472       57344        6         512     14.28%
</span><span class="c1">//    52       9728       49152        5         512      3.64%
</span><span class="c1">//    53      10240       40960        4           0      4.99%
</span><span class="c1">//    54      10880       32768        3         128      6.24%
</span><span class="c1">//    55      12288       24576        2           0     11.45%
</span><span class="c1">//    56      13568       40960        3         256      9.99%
</span><span class="c1">//    57      14336       57344        4           0      5.35%
</span><span class="c1">//    58      16384       16384        1           0     12.49%
</span><span class="c1">//    59      18432       73728        4           0     11.11%
</span><span class="c1">//    60      19072       57344        3         128      3.57%
</span><span class="c1">//    61      20480       40960        2           0      6.87%
</span><span class="c1">//    62      21760       65536        3         256      6.25%
</span><span class="c1">//    63      24576       24576        1           0     11.45%
</span><span class="c1">//    64      27264       81920        3         128     10.00%
</span><span class="c1">//    65      28672       57344        2           0      4.91%
</span><span class="c1">//    66      32768       32768        1           0     12.50%
</span></code></pre></div><p>class: class ID, 每个span都有class ID
bytes/obj: 对象的字节数
bytes/span: 每个span占用的字节数
objects: 每个span可以分配的对象 (bytes/span) / (bytes/obj)
waste bytes: 每个span产生的碎片， (bytes/span) % (bytes/obj)</p>
<p>这么做有什么好处呢？ 可以看下这个图
<img src="/posts/images/mem_used.png" alt="mem_used">
如果p2释放掉后，是不是就会造成有很多内存碎片？</p>
<h5 id="span-class">span class<a href="#span-class" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>每个Size Class对应两个mspan，一个是含指针对象，一个是不含指针对象的，主要是方便GC</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">Size_Class</span> <span class="p">=</span> <span class="nx">Span_class</span> <span class="o">/</span> <span class="mi">2</span>
</code></pre></div><h4 id="mspan-1">mspan<a href="#mspan-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>mspan是个双向链表，是go里面最小的管理单元，是由一堆Pages组成的连续内存</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mspan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// next span in list, or nil if none
</span><span class="c1"></span>	<span class="nx">prev</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// previous span in list, or nil if none
</span><span class="c1"></span>	<span class="nx">list</span> <span class="o">*</span><span class="nx">mSpanList</span> <span class="c1">// For debugging. TODO: Remove.
</span><span class="c1"></span>
	<span class="nx">startAddr</span> <span class="kt">uintptr</span> <span class="c1">// span其实地址
</span><span class="c1"></span>	<span class="nx">npages</span>    <span class="kt">uintptr</span> <span class="c1">// 页数
</span><span class="c1"></span>
	<span class="nx">manualFreeList</span> <span class="nx">gclinkptr</span> <span class="c1">// list of free objects in mSpanManual spans
</span><span class="c1"></span>
	<span class="c1">// 定位下一个空闲的object， 范围在0~nelems
</span><span class="c1"></span>	<span class="nx">freeindex</span> <span class="kt">uintptr</span>
	<span class="c1">// object的数量
</span><span class="c1"></span>	<span class="nx">nelems</span> <span class="kt">uintptr</span> <span class="c1">// number of object in the span.
</span><span class="c1"></span>
	<span class="c1">// 缓存freeindex开始的bitmap， allocCache是allocBits的补码
</span><span class="c1"></span>	<span class="nx">allocCache</span> <span class="kt">uint64</span>

	<span class="c1">// 分配位图，每一位代表是否已分配
</span><span class="c1"></span>	<span class="nx">allocBits</span>  <span class="o">*</span><span class="nx">gcBits</span>

	<span class="c1">// 用于在gc的时候标记哪些对象存活，每次GC后gcmarkBits变成allocBits
</span><span class="c1"></span>	<span class="nx">gcmarkBits</span> <span class="o">*</span><span class="nx">gcBits</span>

	<span class="nx">sweepgen</span>    <span class="kt">uint32</span>
	<span class="nx">divMul</span>      <span class="kt">uint16</span>     <span class="c1">// for divide by elemsize - divMagic.mul
</span><span class="c1"></span>	<span class="nx">baseMask</span>    <span class="kt">uint16</span>     <span class="c1">// if non-0, elemsize is a power of 2, &amp; this will get object allocation base
</span><span class="c1"></span>	<span class="c1">// 已分配的object数量
</span><span class="c1"></span>	<span class="nx">allocCount</span>  <span class="kt">uint16</span>     <span class="c1">// number of allocated objects
</span><span class="c1"></span>	<span class="nx">spanclass</span>   <span class="nx">spanClass</span>  <span class="c1">// size class and noscan (uint8)
</span><span class="c1"></span>	<span class="nx">state</span>       <span class="nx">mSpanState</span> <span class="c1">// mspaninuse etc
</span><span class="c1"></span>	<span class="nx">needzero</span>    <span class="kt">uint8</span>      <span class="c1">// needs to be zeroed before allocation
</span><span class="c1"></span>	<span class="nx">divShift</span>    <span class="kt">uint8</span>      <span class="c1">// for divide by elemsize - divMagic.shift
</span><span class="c1"></span>	<span class="nx">divShift2</span>   <span class="kt">uint8</span>      <span class="c1">// for divide by elemsize - divMagic.shift2
</span><span class="c1"></span>	<span class="nx">scavenged</span>   <span class="kt">bool</span>       <span class="c1">// whether this span has had its pages released to the OS
</span><span class="c1"></span>	<span class="nx">elemsize</span>    <span class="kt">uintptr</span>    <span class="c1">// computed from sizeclass or from npages
</span><span class="c1"></span>	<span class="nx">unusedsince</span> <span class="kt">int64</span>      <span class="c1">// first time spotted by gc in mspanfree state
</span><span class="c1"></span>	<span class="nx">limit</span>       <span class="kt">uintptr</span>    <span class="c1">// end of data in span
</span><span class="c1"></span>	<span class="nx">speciallock</span> <span class="nx">mutex</span>      <span class="c1">// guards specials list
</span><span class="c1"></span>	<span class="nx">specials</span>    <span class="o">*</span><span class="nx">special</span>   <span class="c1">// linked list of special records sorted by offset.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="mcache">mcache<a href="#mcache" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>mcache是每个P单独拥有的，所以不需要锁</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mcache</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// numSpanClasses = _NumSizeClasses &lt;&lt; 1, 也就是67*2=134
</span><span class="c1"></span>	<span class="nx">alloc</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span> 
<span class="p">}</span>
</code></pre></div><p>alloc的分布</p>
<p><img src="/posts/images/alloc_mspan.png" alt="alloc_mspan"></p>
<p>span class分为scan和noscan，如果对象含有指针则分为scan，否则分配到noscan，这样在GC的时候，如果对应的是noscan，则不用再去bitmap中找对应的对象</p>
<h4 id="mcentral">mcentral<a href="#mcentral" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>mcentral为每个mcache提供mspan， 每个mcentral保存未分配和已分批的span，当mcache没有合适或是空闲的mspan,就会从mcentral申请</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mcentral</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>      <span class="nx">mutex</span>
	<span class="nx">spanclass</span> <span class="nx">spanClass</span>
	<span class="nx">nonempty</span>  <span class="nx">mSpanList</span> <span class="c1">// 有空闲Object的mspan的链表
</span><span class="c1"></span>	<span class="nx">empty</span>     <span class="nx">mSpanList</span> <span class="c1">// 没有空闲Objectde mspan的链表， 或者被mcache取走的mspan链表
</span><span class="c1"></span>
	<span class="c1">// 累计分配object的数量
</span><span class="c1"></span>	<span class="nx">nmalloc</span> <span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></div><p>下面两个操作都需要加锁</p>
<ul>
<li>当mcache从mcentral申请mspan的时候，如果noempty中有空闲，那么会从noempty拿走，并加入到empty中</li>
<li>归还的话，从empty删除，并加入到noempty中</li>
</ul>
<h4 id="mheap">mheap<a href="#mheap" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>mheap是一个全局的内存管理</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mheap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>      <span class="nx">mutex</span>
	<span class="c1">// mTreap 是个二叉排序树，按照span的page数量排序
</span><span class="c1"></span>	<span class="nx">free</span>      <span class="nx">mTreap</span> <span class="c1">// 保存span是空闲并且非垃圾回收的span
</span><span class="c1"></span>	<span class="nx">scav</span>      <span class="nx">mTreap</span> <span class="c1">// 保存span是空闲并且垃圾回收的span
</span><span class="c1"></span>	<span class="c1">// 指向spans区域，
</span><span class="c1"></span>	<span class="nx">allspans</span> <span class="p">[]</span><span class="o">*</span><span class="nx">mspan</span> <span class="c1">// all spans out there
</span><span class="c1"></span>
	<span class="c1">// arenas 是一个map，指向了每个heap arena对应的metadata
</span><span class="c1"></span>	<span class="c1">// Linux平台上arenaL1Bits是0， arenaL2Bits=heapAddrBits-logHeapArenaBytes(48-26)=22
</span><span class="c1"></span>	<span class="nx">arenas</span> <span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL1Bits</span><span class="p">]</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL2Bits</span><span class="p">]</span><span class="o">*</span><span class="nx">heapArena</span>

	<span class="c1">// 32位平台上预留空闲
</span><span class="c1"></span>	<span class="nx">arena</span> <span class="nx">linearAlloc</span>

	<span class="c1">// 记录arena的增长地址
</span><span class="c1"></span>	<span class="nx">arenaHints</span> <span class="o">*</span><span class="nx">arenaHint</span>

	<span class="c1">// 如果sweepgen == mheap.sweepgen - 2, span需要扫描
</span><span class="c1"></span>	<span class="c1">// 如果sweepgen == mheap.sweepgen - 1, span正在被扫描
</span><span class="c1"></span>	<span class="c1">// 如果sweepgen == mheap.sweepgen, span已经扫描完成，等待被使用
</span><span class="c1"></span>	<span class="c1">// 如果sweepgen == mheap.sweepgen + 1, span已经被缓存，现在仍然缓存中，则需要扫描
</span><span class="c1"></span>	<span class="c1">// 如果sweepgen == mheap.sweepgen + 3, span已经扫描过了，还处在缓存中
</span><span class="c1"></span>	<span class="nx">sweepgen</span>    <span class="kt">uint32</span>

	<span class="c1">// central 是一个针对小对象(32KB)的列表，用spanClass索引
</span><span class="c1"></span>	<span class="nx">central</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">mcentral</span> <span class="nx">mcentral</span>
		<span class="nx">pad</span>      <span class="p">[</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">mcentral</span><span class="p">{})</span><span class="o">%</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span><span class="p">]</span><span class="kt">byte</span>
	<span class="p">}</span>

	<span class="nx">spanalloc</span>             <span class="nx">fixalloc</span> <span class="c1">// allocator for span*
</span><span class="c1"></span>	<span class="nx">cachealloc</span>            <span class="nx">fixalloc</span> <span class="c1">// allocator for mcache*
</span><span class="c1"></span>	<span class="nx">treapalloc</span>            <span class="nx">fixalloc</span> <span class="c1">// allocator for treapNodes*
</span><span class="c1"></span>	<span class="nx">specialfinalizeralloc</span> <span class="nx">fixalloc</span> <span class="c1">// allocator for specialfinalizer*
</span><span class="c1"></span>	<span class="nx">specialprofilealloc</span>   <span class="nx">fixalloc</span> <span class="c1">// allocator for specialprofile*
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h5 id="heaparena">heapArena<a href="#heaparena" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>heapArena 保存heap arena的元数据</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">heapArena</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// bitmap表示arena哪些地址保存了对象， heapArenaBitmapBytes是2048K
</span><span class="c1"></span>	<span class="nx">bitmap</span> <span class="p">[</span><span class="nx">heapArenaBitmapBytes</span><span class="p">]</span><span class="kt">byte</span>

	<span class="c1">// spans 保存了page和mspan的对应关系， pagesPerArena是8KB
</span><span class="c1"></span>	<span class="nx">spans</span> <span class="p">[</span><span class="nx">pagesPerArena</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>

	<span class="c1">// pageInUse is a bitmap that indicates which spans are in
</span><span class="c1"></span>	<span class="c1">// state mSpanInUse. This bitmap is indexed by page number,
</span><span class="c1"></span>	<span class="c1">// but only the bit corresponding to the first page in each
</span><span class="c1"></span>	<span class="c1">// span is used.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Writes are protected by mheap_.lock.
</span><span class="c1"></span>	<span class="nx">pageInUse</span> <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>

	<span class="c1">// pageMarks is a bitmap that indicates which spans have any
</span><span class="c1"></span>	<span class="c1">// marked objects on them. Like pageInUse, only the bit
</span><span class="c1"></span>	<span class="c1">// corresponding to the first page in each span is used.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Writes are done atomically during marking. Reads are
</span><span class="c1"></span>	<span class="c1">// non-atomic and lock-free since they only occur during
</span><span class="c1"></span>	<span class="c1">// sweeping (and hence never race with writes).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This is used to quickly find whole spans that can be freed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// TODO(austin): It would be nice if this was uint64 for
</span><span class="c1"></span>	<span class="c1">// faster scanning, but we don&#39;t have 64-bit atomic bit
</span><span class="c1"></span>	<span class="c1">// operations.
</span><span class="c1"></span>	<span class="nx">pageMarks</span> <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
<span class="p">}</span>
</code></pre></div><h3 id="分配过程">分配过程<a href="#分配过程" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h4 id="newobject">newobject<a href="#newobject" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>从堆上分配对象会从newobject</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">typ</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">typ</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="mallocgc">mallocgc<a href="#mallocgc" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>mallocgc 代码非常长，这里我们一种一种情况说</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="c1">// 省略...
</span><span class="c1"></span>	<span class="c1">// 判断是否需要辅助GC工作
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">assistG</span> <span class="o">*</span><span class="nx">g</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Charge the current user G for this allocation.
</span><span class="c1"></span>		<span class="nx">assistG</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">assistG</span> <span class="p">=</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
		<span class="p">}</span>
		<span class="c1">// Charge the allocation against the G. We&#39;ll account
</span><span class="c1"></span>		<span class="c1">// for internal fragmentation at the end of mallocgc.
</span><span class="c1"></span>		<span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// This G is in debt. Assist the GC to correct
</span><span class="c1"></span>			<span class="c1">// this before allocating. This must happen
</span><span class="c1"></span>			<span class="c1">// before disabling preemption.
</span><span class="c1"></span>			<span class="nf">gcAssistAlloc</span><span class="p">(</span><span class="nx">assistG</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 设置m的mallocing，防止被抢占
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;malloc deadlock&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;malloc during signal&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="nx">shouldhelpgc</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="nx">dataSize</span> <span class="o">:=</span> <span class="nx">size</span>
	<span class="c1">// 获取mcache
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">gomcache</span><span class="p">()</span>

	<span class="c1">// 省略...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h5 id="小对象32kb">小对象(&lt;=32KB)<a href="#小对象32kb" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="c1">// 如果是极小对象(&lt;16B)并且对象不包含指针，则进行特殊处理
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">noscan</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
			<span class="c1">// 因为span最小是8byte，如果是过小的对象，也会被浪费掉，非常小的对象可以整合在class 2 noscan(大小为16 byte)
</span><span class="c1"></span>			<span class="nx">off</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span>
			<span class="c1">// Align tiny pointer for required (conservative) alignment.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">7</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">round</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">round</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">round</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">off</span><span class="o">+</span><span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxTinySize</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// The object fits into existing tiny block.
</span><span class="c1"></span>				<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">+</span> <span class="nx">off</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">off</span> <span class="o">+</span> <span class="nx">size</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">local_tinyallocs</span><span class="o">++</span>
				<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
				<span class="k">return</span> <span class="nx">x</span>
			<span class="p">}</span>
			<span class="c1">// tinySpanClass = 5, 按照span class排列，正好的16byte noscan span class
</span><span class="c1"></span>			<span class="nx">span</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">tinySpanClass</span><span class="p">]</span>
			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">v</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">tinySpanClass</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="c1">// See if we need to replace the existing tiny block with the new one
</span><span class="c1"></span>			<span class="c1">// based on amount of remaining free space.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">size</span>
			<span class="p">}</span>
			<span class="nx">size</span> <span class="p">=</span> <span class="nx">maxTinySize</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 其他按小对象分配
</span><span class="c1"></span>			<span class="kd">var</span> <span class="nx">sizeclass</span> <span class="kt">uint8</span>
			<span class="c1">// 按size大小判断应该落在哪个span类型上
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">smallSizeMax</span><span class="o">-</span><span class="mi">8</span> <span class="p">{</span>
				<span class="nx">sizeclass</span> <span class="p">=</span> <span class="nx">size_to_class8</span><span class="p">[(</span><span class="nx">size</span><span class="o">+</span><span class="nx">smallSizeDiv</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nx">smallSizeDiv</span><span class="p">]</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">sizeclass</span> <span class="p">=</span> <span class="nx">size_to_class128</span><span class="p">[(</span><span class="nx">size</span><span class="o">-</span><span class="nx">smallSizeMax</span><span class="o">+</span><span class="nx">largeSizeDiv</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nx">largeSizeDiv</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="nx">size</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">])</span>
			<span class="c1">// 等于sizeclass * 2
</span><span class="c1"></span>			<span class="nx">spc</span> <span class="o">:=</span> <span class="nf">makeSpanClass</span><span class="p">(</span><span class="nx">sizeclass</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
			<span class="nx">span</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// 如果分配失败，需要从mcentral或者mheap中获取
</span><span class="c1"></span>				<span class="c1">// 如果分配到了shouldhelpgc会返回true，接下来会判断是否触发GC
</span><span class="c1"></span>				<span class="nx">v</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">needzero</span> <span class="o">&amp;&amp;</span> <span class="nx">span</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
</code></pre></div><h5 id="对象32kb">对象(&gt;32KB)<a href="#对象32kb" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">		<span class="c1">// 大对象直接从mheap分配， 这个class是0
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
		<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">s</span> <span class="p">=</span> <span class="nf">largeAlloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">needzero</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
		<span class="p">})</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
</code></pre></div><h5 id="后续">后续<a href="#后续" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="c1">// 如果是指针对象，需要设置对应的bitmap，记录哪些位置包含了指针
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">noscan</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">typ</span> <span class="o">==</span> <span class="nx">deferType</span> <span class="p">{</span>
			<span class="nx">dataSize</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">_defer</span><span class="p">{})</span>
		<span class="p">}</span>
		<span class="nf">heapBitsSetType</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">dataSize</span><span class="p">,</span> <span class="nx">typ</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">dataSize</span> <span class="p">&gt;</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
			<span class="c1">// Array allocation. If there are any
</span><span class="c1"></span>			<span class="c1">// pointers, GC has to scan to the last
</span><span class="c1"></span>			<span class="c1">// element.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">scanSize</span> <span class="p">=</span> <span class="nx">dataSize</span> <span class="o">-</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">size</span> <span class="o">+</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">scanSize</span> <span class="p">=</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_scan</span> <span class="o">+=</span> <span class="nx">scanSize</span>
	<span class="p">}</span>
	<span class="c1">// ...
</span><span class="c1"></span>	<span class="c1">// GC中发生了分配，则将对象标记为“黑色”，防止回收
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">gcmarknewobject</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">scanSize</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 允许抢占
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>

	<span class="c1">// Profile记录
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">rate</span> <span class="o">:=</span> <span class="nx">MemProfileRate</span><span class="p">;</span> <span class="nx">rate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">rate</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">next_sample</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">next_sample</span> <span class="o">-=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
			<span class="nf">profilealloc</span><span class="p">(</span><span class="nx">mp</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">assistG</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Account for internal fragmentation in the assist
</span><span class="c1"></span>		<span class="c1">// debt now that we know it.
</span><span class="c1"></span>		<span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">size</span> <span class="o">-</span> <span class="nx">dataSize</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 如果之前获取了新的span，需要启动下gc
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">shouldhelpgc</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">gcTriggerHeap</span><span class="p">});</span> <span class="nx">t</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">gcStart</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div><h5 id="nextfreefast">nextFreeFast<a href="#nextfreefast" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>快速分配</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="nx">gclinkptr</span> <span class="p">{</span>
	<span class="c1">// 获取第一个非0的bit是第几bit（从右边排），用来判断是否未分配
</span><span class="c1"></span>	<span class="nx">theBit</span> <span class="o">:=</span> <span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span><span class="p">)</span>
	<span class="c1">// 如果有未分配的,
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">theBit</span> <span class="p">&lt;</span> <span class="mi">64</span> <span class="p">{</span>
		<span class="nx">result</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">theBit</span><span class="p">)</span>
		<span class="c1">// 索引值小于当前元素数量
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">result</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
			<span class="c1">// 下一个freeidx
</span><span class="c1"></span>			<span class="nx">freeidx</span> <span class="o">:=</span> <span class="nx">result</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="c1">// 如果是64的倍数，需要特殊处理
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">freeidx</span><span class="o">%</span><span class="mi">64</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">freeidx</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
				<span class="k">return</span> <span class="mi">0</span>
			<span class="p">}</span>
			<span class="c1">// 更新freeindex和allocCache
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="o">&gt;&gt;=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">theBit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">freeidx</span>
			<span class="c1">// 更新计数器
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="o">++</span>
			<span class="k">return</span> <span class="nf">gclinkptr</span><span class="p">(</span><span class="nx">result</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div><h5 id="nextfree">nextFree<a href="#nextfree" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>如果nextFreeFast没有分配到元素，则需要调用nextFree</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">gclinkptr</span><span class="p">,</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 获取目标span
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
	<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="c1">// 获取下一个freeIndex
</span><span class="c1"></span>	<span class="nx">freeIndex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
	<span class="c1">// span已经满了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: s.allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34;s.nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 申请新的span
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">refill</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
		<span class="c1">// 标记检查gc
</span><span class="c1"></span>		<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>

		<span class="nx">freeIndex</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">&gt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;freeIndex is not valid&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 返回元素所在的地址
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="nf">gclinkptr</span><span class="p">(</span><span class="nx">freeIndex</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
	<span class="c1">// 分配计数++
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="o">++</span>
	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;s.allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34;s.nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;s.allocCount &gt; s.nelems&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><h5 id="refill">refill<a href="#refill" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>当mache中没有空闲的span时候，需要调用refill申请新的span
注： refill过程中，已经标记G不能被抢占</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">refill</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Return the current cached span to the central lists.
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>

	<span class="c1">// 确保元素已经分配完
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;refill of span with free space remaining&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 设置sweepgen属性，
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">emptymspan</span> <span class="p">{</span>
		<span class="c1">// 将这个span标记为不在缓存
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">!=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">+</span><span class="mi">3</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad sweepgen in refill&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 从mcenral 申请一个新的span
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">cacheSpan</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;span has no free space&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 将此标记为已扫描
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">+</span> <span class="mi">3</span>
	<span class="c1">// 将当前span加入到mcache中
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><h5 id="cachespan">cacheSpan<a href="#cachespan" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>从mcentral获取span</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">cacheSpan</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// 需要分配span的字节大小
</span><span class="c1"></span>	<span class="nx">spanBytes</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_allocnpages</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span> <span class="o">*</span> <span class="nx">_PageSize</span>
	<span class="nf">deductSweepCredit</span><span class="p">(</span><span class="nx">spanBytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="c1">// 加锁
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">traceDone</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSweepStart</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
<span class="nx">retry</span><span class="p">:</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="c1">// 从nonempty中获取mspan
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
		<span class="c1">// sweepgen ==  mheap_.sweepgen, 表示span已经sweep
</span><span class="c1"></span>		<span class="c1">// sweepgen ==  mheap_.sweepgen - 1，表示span正在sweep
</span><span class="c1"></span>		<span class="c1">// sweepgen ==  mheap_.sweepgen - 2, 表示span还没sweep
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 如果获取到了，将nonempty移除，并加入到empty，
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
			<span class="k">goto</span> <span class="nx">havespan</span>
		<span class="p">}</span>
		<span class="c1">// 如果span正在被其他线程sweep，跳过
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="c1">// sweep已经sweep，noempty至少有1个未分配的span，直接分配
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">havespan</span>
	<span class="p">}</span>
	
	<span class="c1">// 从empty中获取mspan
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
		<span class="c1">// span正在等待sweep
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 从empty中移除，并加入到链表末尾
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="c1">// TODO: 尝试sweep
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
			<span class="c1">// 检查下是否有未分配的对象，有则分配
</span><span class="c1"></span>			<span class="nx">freeIndex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">freeIndex</span>
				<span class="k">goto</span> <span class="nx">havespan</span>
			<span class="p">}</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="c1">// the span is still empty after sweep
</span><span class="c1"></span>			<span class="c1">// it is already in the empty list, so just retry
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">retry</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="c1">// the span is being swept by background sweeper, skip
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 找不到未分配对象的span
</span><span class="c1"></span>		<span class="k">break</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSweepDone</span><span class="p">()</span>
		<span class="nx">traceDone</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Replenish central list if empty.
</span><span class="c1"></span>	<span class="c1">// 如果依然没找到，则从mheap分配，分配后直接加入到empty
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">grow</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// At this point s is a non-empty span, queued at the end of the empty list,
</span><span class="c1"></span>	<span class="c1">// c is unlocked.
</span><span class="c1"></span><span class="nx">havespan</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">traceDone</span> <span class="p">{</span>
		<span class="nf">traceGCSweepDone</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="o">||</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;span has no free objects&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Assume all objects from this span will be allocated in the
</span><span class="c1"></span>	<span class="c1">// mcache. If it gets uncached, we&#39;ll adjust this.
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">nmalloc</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="nx">usedBytes</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">*</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">spanBytes</span><span class="p">)</span><span class="o">-</span><span class="nb">int64</span><span class="p">(</span><span class="nx">usedBytes</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="c1">// heap_live changed.
</span><span class="c1"></span>		<span class="nf">traceHeapAlloc</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// heap_live changed.
</span><span class="c1"></span>		<span class="nx">gcController</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">freeByteBase</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">whichByte</span> <span class="o">:=</span> <span class="nx">freeByteBase</span> <span class="o">/</span> <span class="mi">8</span>
	<span class="c1">// Init alloc bits cache.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="nx">whichByte</span><span class="p">)</span>

	<span class="c1">// Adjust the allocCache so that s.freeindex corresponds to the low bit in
</span><span class="c1"></span>	<span class="c1">// s.allocCache.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="o">&gt;&gt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">%</span> <span class="mi">64</span>

	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><h5 id="grow">grow<a href="#grow" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>向mheap申请一个新的span</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">grow</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// 根据mcentral的类型计算需要申请span的大小
</span><span class="c1"></span>	<span class="nx">npages</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_allocnpages</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span> <span class="o">/</span> <span class="nx">size</span>

	<span class="c1">// 向mheap申请一个新的span
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// 返回mspan.startAddr
</span><span class="c1"></span>	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">p</span> <span class="o">+</span> <span class="nx">size</span><span class="o">*</span><span class="nx">n</span>
	<span class="c1">// 分配并初始化span
</span><span class="c1"></span>	<span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()).</span><span class="nf">initSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

</code></pre></div><h5 id="alloc">alloc<a href="#alloc" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>调用alloc，分配span</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">large</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// Don&#39;t do any operations that lock the heap on the G stack.
</span><span class="c1"></span>	<span class="c1">// It might trigger stack growth, and the stack growth code needs
</span><span class="c1"></span>	<span class="c1">// to be able to allocate heap.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">alloc_m</span><span class="p">(</span><span class="nx">npage</span><span class="p">,</span> <span class="nx">spanclass</span><span class="p">,</span> <span class="nx">large</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">needzero</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><h5 id="alloc_m">alloc_m<a href="#alloc_m" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">alloc_m</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">large</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// 为了过度分配，我们这里需要分配npage前，sweep和回收至少npage
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">sweepdone</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">reclaim</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 对mheap上锁
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 更新全局计数
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nx">local_scan</span><span class="p">)</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nx">local_scan</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">tinyallocs</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nx">local_tinyallocs</span><span class="p">)</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nx">local_tinyallocs</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 分配span
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">allocSpanLocked</span><span class="p">(</span><span class="nx">npage</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_inuse</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 设置span的sweepsgen = mheap sweepgen
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>
		<span class="c1">// sweepSpans[h.sweepgen/2%2] 保存当前正在使用的span列表
</span><span class="c1"></span>		<span class="c1">// sweepSpans[1-sweepgen/2%2] 保存等待sweep的span列表
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">h</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">mSpanInUse</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span> <span class="p">=</span> <span class="nx">spanclass</span>
		<span class="k">if</span> <span class="nx">sizeclass</span> <span class="o">:=</span> <span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">();</span> <span class="nx">sizeclass</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">baseMask</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">])</span>
			<span class="nx">m</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">class_to_divmagic</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">]</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">shift</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mul</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">shift2</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">baseMask</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">baseMask</span>
		<span class="p">}</span>

		<span class="c1">// Mark in-use span in arena page bitmap.
</span><span class="c1"></span>		<span class="nx">arena</span><span class="p">,</span> <span class="nx">pageIdx</span><span class="p">,</span> <span class="nx">pageMask</span> <span class="o">:=</span> <span class="nf">pageIndexOf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="nx">arena</span><span class="p">.</span><span class="nx">pageInUse</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">]</span> <span class="o">|=</span> <span class="nx">pageMask</span>

		<span class="c1">// update stats, sweep lists
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">pagesInUse</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">large</span> <span class="p">{</span>
			<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_objects</span><span class="o">++</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">largealloc</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">nlargealloc</span><span class="o">++</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">npage</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// heap_scan and heap_live were updated.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gcController</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceHeapAlloc</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// h.spans is accessed concurrently without synchronization
</span><span class="c1"></span>	<span class="c1">// from other threads. Hence, there must be a store/store
</span><span class="c1"></span>	<span class="c1">// barrier here to ensure the writes to h.spans above happen
</span><span class="c1"></span>	<span class="c1">// before the caller can publish a pointer p to an object
</span><span class="c1"></span>	<span class="c1">// allocated from s. As soon as this happens, the garbage
</span><span class="c1"></span>	<span class="c1">// collector running on another processor could read p and
</span><span class="c1"></span>	<span class="c1">// look up s in h.spans. The unlock acts as the barrier to
</span><span class="c1"></span>	<span class="c1">// order these writes. On the read side, the data dependency
</span><span class="c1"></span>	<span class="c1">// between p and the index in h.spans orders the reads.
</span><span class="c1"></span>	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><h5 id="allocspanlocked">allocSpanLocked<a href="#allocspanlocked" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">allocSpanLocked</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">stat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>

	<span class="c1">// 从free和scav中查找符合条件的最小span
</span><span class="c1"></span>	<span class="c1">// 1. 如果free中存在，并且find scav为nil或者free找的span的pages小于等于scav，则返回free找到的span并且删除对应节点
</span><span class="c1"></span>	<span class="c1">// 2. 如果scav中存在，并且find free为nil或者free找的span pages 大于scav的，则返回scav的span并删除对应的节点
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">pickFreeSpan</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="nx">HaveSpan</span>
	<span class="p">}</span>

	<span class="c1">// 如果寻找失败，则尝试再次增加heap大小
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// 再次重试
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">pickFreeSpan</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="nx">HaveSpan</span>
	<span class="p">}</span>
	<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;grew heap, but no adequate free span found&#34;</span><span class="p">)</span>

<span class="nx">HaveSpan</span><span class="p">:</span>
	<span class="c1">// 检查得到的span
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanFree</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;candidate mspan for allocation is not free&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="p">&lt;</span> <span class="nx">npage</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;candidate mspan for allocation is too small&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 减掉我们释放回操作系统的内存
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_released</span> <span class="o">-=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">released</span><span class="p">())</span>

	<span class="c1">// 如果获取到的pages超过我们的要求的pages
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="p">&gt;</span> <span class="nx">npage</span> <span class="p">{</span>
		<span class="c1">// 分割剩余的pages，将其再放回到heap中
</span><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">mspan</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">+</span><span class="nx">npage</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">-</span><span class="nx">npage</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="p">=</span> <span class="nx">npage</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">setSpan</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">setSpan</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">base</span><span class="p">(),</span> <span class="nx">t</span><span class="p">)</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">setSpan</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">+</span><span class="nx">t</span><span class="p">.</span><span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span>
		<span class="c1">// If s was scavenged, then t may be scavenged.
</span><span class="c1"></span>		<span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">physPageBounds</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">scavenged</span> <span class="o">&amp;&amp;</span> <span class="nx">start</span> <span class="p">&lt;</span> <span class="nx">end</span> <span class="p">{</span>
			<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_released</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">end</span> <span class="o">-</span> <span class="nx">start</span><span class="p">)</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">scavenged</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">mSpanManual</span> <span class="c1">// prevent coalescing with s
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">mSpanManual</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">freeSpanLocked</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">unusedsince</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">mSpanFree</span>
	<span class="p">}</span>
	<span class="c1">// &#34;Unscavenge&#34; s only AFTER splitting so that
</span><span class="c1"></span>	<span class="c1">// we only sysUsed whatever we actually need.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">scavenged</span> <span class="p">{</span>
		<span class="c1">// sysUsed all the pages that are actually available
</span><span class="c1"></span>		<span class="c1">// in the span. Note that we don&#39;t need to decrement
</span><span class="c1"></span>		<span class="c1">// heap_released since we already did so earlier.
</span><span class="c1"></span>		<span class="nf">sysUsed</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">scavenged</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">unusedsince</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 设置spans，哪些地址对应哪个span
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nf">setSpans</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">(),</span> <span class="nx">npage</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>

	<span class="o">*</span><span class="nx">stat</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">npage</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_idle</span> <span class="o">-=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">npage</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span>

	<span class="c1">//println(&#34;spanalloc&#34;, hex(s.start&lt;&lt;_PageShift))
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">inList</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;still in list&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><h5 id="grow-1">grow<a href="#grow-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">grow</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">ask</span> <span class="o">:=</span> <span class="nx">npage</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span>
	<span class="c1">// 申请
</span><span class="c1"></span>	<span class="nx">v</span><span class="p">,</span> <span class="nx">size</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">ask</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: out of memory: cannot allocate &#34;</span><span class="p">,</span> <span class="nx">ask</span><span class="p">,</span> <span class="s">&#34;-byte block (&#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">,</span> <span class="s">&#34; in use)\n&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// Scavenge some pages out of the free treap to make up for
</span><span class="c1"></span>	<span class="c1">// the virtual memory space we just allocated. We prefer to
</span><span class="c1"></span>	<span class="c1">// scavenge the largest spans first since the cost of scavenging
</span><span class="c1"></span>	<span class="c1">// is proportional to the number of sysUnused() calls rather than
</span><span class="c1"></span>	<span class="c1">// the number of pages released, so we make fewer of those calls
</span><span class="c1"></span>	<span class="c1">// with larger spans.
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nf">scavengeLargest</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>

	<span class="c1">// 创建一个InUse的span，然后释放掉，保证能正常的合并
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">mspan</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="nx">size</span><span class="o">/</span><span class="nx">pageSize</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">setSpans</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">(),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">mSpanInUse</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">pagesInUse</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">freeSpanLocked</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><h5 id="sysalloc">sysAlloc<a href="#sysalloc" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>
<p>sysAlloc会分配至少n字节的</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="p">=</span> <span class="nf">round</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">heapArenaBytes</span><span class="p">)</span>

	<span class="c1">// 首先，尝试从arena分配
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arena</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">heapArenaBytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">n</span>
		<span class="k">goto</span> <span class="nx">mapped</span>
	<span class="p">}</span>

	<span class="c1">// 尝试增长heap
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">hint</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arenaHints</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span>
		<span class="k">if</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">down</span> <span class="p">{</span>
			<span class="nx">p</span> <span class="o">-=</span> <span class="nx">n</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">p</span><span class="o">+</span><span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">p</span> <span class="p">{</span>
			<span class="c1">// We can&#39;t use this, so don&#39;t ask.
</span><span class="c1"></span>			<span class="nx">v</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nx">p</span><span class="o">+</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">arenaBits</span> <span class="p">{</span>
			<span class="c1">// Outside addressable heap. Can&#39;t use.
</span><span class="c1"></span>			<span class="nx">v</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 调用系统的mmap函数
</span><span class="c1"></span>			<span class="nx">v</span> <span class="p">=</span> <span class="nf">sysReserve</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nx">n</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 获取成功，更新hint
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">hint</span><span class="p">.</span><span class="nx">down</span> <span class="p">{</span>
				<span class="nx">p</span> <span class="o">+=</span> <span class="nx">n</span>
			<span class="p">}</span>
			<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">p</span>
			<span class="nx">size</span> <span class="p">=</span> <span class="nx">n</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c1">// 获取失败，放弃这个hint，尝试下一个
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">sysFree</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">next</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">hint</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="c1">// The race detector assumes the heap lives in
</span><span class="c1"></span>			<span class="c1">// [0x00c000000000, 0x00e000000000), but we
</span><span class="c1"></span>			<span class="c1">// just ran out of hints in this region. Give
</span><span class="c1"></span>			<span class="c1">// a nice failure.
</span><span class="c1"></span>			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;too many address space collisions for -race mode&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// 所有的hints都失败了
</span><span class="c1"></span>		<span class="nx">v</span><span class="p">,</span> <span class="nx">size</span> <span class="p">=</span> <span class="nf">sysReserveAligned</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">heapArenaBytes</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span>
		<span class="p">}</span>

		<span class="c1">// 创建新的hints
</span><span class="c1"></span>		<span class="nx">hint</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">arenaHint</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">down</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="kc">true</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span><span class="p">,</span> <span class="nx">hint</span>
		<span class="nx">hint</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">arenaHint</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">+</span> <span class="nx">size</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span><span class="p">,</span> <span class="nx">hint</span>
	<span class="p">}</span>

	<span class="c1">// 检查指针
</span><span class="c1"></span>	<span class="p">{</span>
		<span class="kd">var</span> <span class="nx">bad</span> <span class="kt">string</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">p</span><span class="o">+</span><span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">p</span> <span class="p">{</span>
			<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;region exceeds uintptr range&#34;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">arenaBits</span> <span class="p">{</span>
			<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;base outside usable address space&#34;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nx">p</span><span class="o">+</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">arenaBits</span> <span class="p">{</span>
			<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;end outside usable address space&#34;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">bad</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="c1">// This should be impossible on most architectures,
</span><span class="c1"></span>			<span class="c1">// but it would be really confusing to debug.
</span><span class="c1"></span>			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: memory allocated by OS [&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">p</span><span class="o">+</span><span class="nx">size</span><span class="p">),</span> <span class="s">&#34;) not in usable address space: &#34;</span><span class="p">,</span> <span class="nx">bad</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;memory reservation exceeds address space limit&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">heapArenaBytes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;misrounded allocation in sysAlloc&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Back the reservation.
</span><span class="c1"></span>	<span class="nf">sysMap</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">)</span>

<span class="nx">mapped</span><span class="p">:</span>
	<span class="c1">// 创建heapArena
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">ri</span> <span class="o">:=</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">));</span> <span class="nx">ri</span> <span class="o">&lt;=</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">+</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="nx">ri</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">l2</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arenas</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l1</span><span class="p">()]</span>
		<span class="k">if</span> <span class="nx">l2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Allocate an L2 arena map.
</span><span class="c1"></span>			<span class="nx">l2</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL2Bits</span><span class="p">]</span><span class="o">*</span><span class="nx">heapArena</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">l2</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">l2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory allocating heap arena map&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorepNoWB</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">arenas</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l1</span><span class="p">()]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">l2</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">l2</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l2</span><span class="p">()]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;arena already initialized&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="kd">var</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">heapArena</span>
		<span class="nx">r</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">heapArena</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">heapArenaAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">heapArena</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory allocating heap arena metadata&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Add the arena to the arenas list.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span> <span class="o">==</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">size</span> <span class="o">:=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">))</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
			<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">size</span> <span class="p">=</span> <span class="nx">physPageSize</span>
			<span class="p">}</span>
			<span class="nx">newArray</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">notInHeap</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">newArray</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory allocating allArenas&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">oldSlice</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span>
			<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">notInHeapSlice</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">))</span> <span class="p">=</span> <span class="nx">notInHeapSlice</span><span class="p">{</span><span class="nx">newArray</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">size</span> <span class="o">/</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)}</span>
			<span class="nb">copy</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">,</span> <span class="nx">oldSlice</span><span class="p">)</span>
			<span class="c1">// Do not free the old backing array because
</span><span class="c1"></span>			<span class="c1">// there may be concurrent readers. Since we
</span><span class="c1"></span>			<span class="c1">// double the array each time, this can lead
</span><span class="c1"></span>			<span class="c1">// to at most 2x waste.
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ri</span>

		<span class="c1">// Store atomically just in case an object from the
</span><span class="c1"></span>		<span class="c1">// new heap arena becomes visible before the heap lock
</span><span class="c1"></span>		<span class="c1">// is released (which shouldn&#39;t happen, but there&#39;s
</span><span class="c1"></span>		<span class="c1">// little downside to this).
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorepNoWB</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l2</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l2</span><span class="p">()]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// Tell the race detector about the new heap memory.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racemapshadow</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>

</code></pre></div><h4 id="分配图">分配图<a href="#分配图" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>从别的地方转载的一张图
<img src="/posts/images/malloc.png" alt="malloc"></p>
<h3 id="参考">参考<a href="#参考" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<ul>
<li><a href="https://segmentfault.com/a/1190000020086739">深入理解Go-内存分配</a></li>
<li><a href="https://www.jianshu.com/p/2904efc7f1a8">图解Golang的内存分配</a></li>
<li><a href="https://www.cnblogs.com/zkweb/p/7880099.html">Golang源码探索(三) GC的实现原理</a></li>
</ul>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg></p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2021-06-27 09:32 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://leonzyang.github.io/posts/gohttpclient/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;</span><br><span>Go-深入理解HTTP Client</span>
			</a>
			<a class="prev-post" href="https://leonzyang.github.io/posts/syncmap/">
				<span class="post-nav-label">&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Go-深入理解sync.Map</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2021 <a href="https://leonzyang.github.io">LeonZhao</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://leonzyang.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://leonzyang.github.io/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js" integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin="anonymous"></script>
	

</body>

</html>
