<!DOCTYPE html>
<html lang="zh-cn">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Go-深入理解GC">
<meta itemprop="description" content="深入理解GC 垃圾回收其实就是内存回收，在一个对象不再被程序使用时，它所占用的空间就需要回收。
垃圾回收方法 我之前都用Python和Go，所以接触到的垃圾回收大致有这么几种：
引用计数法 引用计数是Python中使用的垃圾回收方法，通过对一个对象计数，当计数等于0，就代表没有其他对象引用，可以清除，但是这个方法有个缺陷，就是无法解决循环引用
优点：
 简单，实时  缺点：
 需要维护计数资源 循环使用  标记清除 通过标记垃圾对象，然后进行清除， Golang的三色标记法就是这一种
分代回收 根据对象的存活周期的不同而将内存分为3代：
 年轻代: 新创建的对象都会分配在年轻代，比如局部变量 中年代：年轻代不会回收的就会放到中年代 老年代：老年代的对象存活最久  Golang 各个版本GC改进    版本 发布时间 GC算法 STW时间 重大改变     1.1 2013.5 STW 秒级    1.3 2014.6 Mark和Sweep分离. Mark STW, Sweep并发 百ms级别    1.4 2014.12 runtime代码基本都由C和少量汇编改为Go和少量汇编, 包括GC部分, 以此实现了准确式GC,减少了堆大小, 同时对指针的写入引入了write barrier, 为1.5铺垫 百ms级别    1.5 2015.">
<meta itemprop="datePublished" content="2021-06-27T09:20:30+08:00" />
<meta itemprop="dateModified" content="2021-06-27T09:20:30+08:00" />
<meta itemprop="wordCount" content="7938">



<meta itemprop="keywords" content="" />
<meta property="og:title" content="Go-深入理解GC" />
<meta property="og:description" content="深入理解GC 垃圾回收其实就是内存回收，在一个对象不再被程序使用时，它所占用的空间就需要回收。
垃圾回收方法 我之前都用Python和Go，所以接触到的垃圾回收大致有这么几种：
引用计数法 引用计数是Python中使用的垃圾回收方法，通过对一个对象计数，当计数等于0，就代表没有其他对象引用，可以清除，但是这个方法有个缺陷，就是无法解决循环引用
优点：
 简单，实时  缺点：
 需要维护计数资源 循环使用  标记清除 通过标记垃圾对象，然后进行清除， Golang的三色标记法就是这一种
分代回收 根据对象的存活周期的不同而将内存分为3代：
 年轻代: 新创建的对象都会分配在年轻代，比如局部变量 中年代：年轻代不会回收的就会放到中年代 老年代：老年代的对象存活最久  Golang 各个版本GC改进    版本 发布时间 GC算法 STW时间 重大改变     1.1 2013.5 STW 秒级    1.3 2014.6 Mark和Sweep分离. Mark STW, Sweep并发 百ms级别    1.4 2014.12 runtime代码基本都由C和少量汇编改为Go和少量汇编, 包括GC部分, 以此实现了准确式GC,减少了堆大小, 同时对指针的写入引入了write barrier, 为1.5铺垫 百ms级别    1.5 2015." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://leonzyang.github.io/posts/gc/" />
<meta property="article:published_time" content="2021-06-27T09:20:30+08:00" />
<meta property="article:modified_time" content="2021-06-27T09:20:30+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go-深入理解GC"/>
<meta name="twitter:description" content="深入理解GC 垃圾回收其实就是内存回收，在一个对象不再被程序使用时，它所占用的空间就需要回收。
垃圾回收方法 我之前都用Python和Go，所以接触到的垃圾回收大致有这么几种：
引用计数法 引用计数是Python中使用的垃圾回收方法，通过对一个对象计数，当计数等于0，就代表没有其他对象引用，可以清除，但是这个方法有个缺陷，就是无法解决循环引用
优点：
 简单，实时  缺点：
 需要维护计数资源 循环使用  标记清除 通过标记垃圾对象，然后进行清除， Golang的三色标记法就是这一种
分代回收 根据对象的存活周期的不同而将内存分为3代：
 年轻代: 新创建的对象都会分配在年轻代，比如局部变量 中年代：年轻代不会回收的就会放到中年代 老年代：老年代的对象存活最久  Golang 各个版本GC改进    版本 发布时间 GC算法 STW时间 重大改变     1.1 2013.5 STW 秒级    1.3 2014.6 Mark和Sweep分离. Mark STW, Sweep并发 百ms级别    1.4 2014.12 runtime代码基本都由C和少量汇编改为Go和少量汇编, 包括GC部分, 以此实现了准确式GC,减少了堆大小, 同时对指针的写入引入了write barrier, 为1.5铺垫 百ms级别    1.5 2015."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Go-深入理解GC</title>
	<link rel="stylesheet" href="https://leonzyang.github.io/css/style.min.eac77496566fd7d5768fd650ddb0b2b181ca6a2d7c5fdd6fe6b8ba4bf47e566f.css" integrity="sha256-6sd0llZv19V2j9ZQ3bCysYHKai18X91v5ri6S/R+Vm8=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://leonzyang.github.io">LeonZhao的小木屋</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://leonzyang.github.io/posts/">博客</a>
				<a href="https://leonzyang.github.io/datastruct/">数据结构</a>
				<a href="https://leonzyang.github.io/algo/">算法</a>
				<a href="https://leonzyang.github.io/network/">网络</a>
				<a href="https://leonzyang.github.io/interview/">面试</a>
				<a href="https://leonzyang.github.io/about/">关于</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://leonzyang.github.io/posts/">博客</a></li>
			<li><a href="https://leonzyang.github.io/datastruct/">数据结构</a></li>
			<li><a href="https://leonzyang.github.io/algo/">算法</a></li>
			<li><a href="https://leonzyang.github.io/network/">网络</a></li>
			<li><a href="https://leonzyang.github.io/interview/">面试</a></li>
			<li><a href="https://leonzyang.github.io/about/">关于</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jun 27, 2021</span></div>
				<h1>Go-深入理解GC</h1>
			</header>
			<div class="content">
				<h2 id="深入理解gc">深入理解GC<a href="#深入理解gc" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>垃圾回收其实就是内存回收，在一个对象不再被程序使用时，它所占用的空间就需要回收。</p>
<h3 id="垃圾回收方法">垃圾回收方法<a href="#垃圾回收方法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>我之前都用Python和Go，所以接触到的垃圾回收大致有这么几种：</p>
<h4 id="引用计数法">引用计数法<a href="#引用计数法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>引用计数是Python中使用的垃圾回收方法，通过对一个对象计数，当计数等于0，就代表没有其他对象引用，可以清除，但是这个方法有个缺陷，就是无法解决循环引用</p>
<p>优点：</p>
<ol>
<li>简单，实时</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要维护计数资源</li>
<li>循环使用</li>
</ol>
<h4 id="标记清除">标记清除<a href="#标记清除" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>通过标记垃圾对象，然后进行清除， Golang的三色标记法就是这一种</p>
<h4 id="分代回收">分代回收<a href="#分代回收" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>根据对象的存活周期的不同而将内存分为3代：</p>
<ul>
<li>年轻代: 新创建的对象都会分配在年轻代，比如局部变量</li>
<li>中年代：年轻代不会回收的就会放到中年代</li>
<li>老年代：老年代的对象存活最久</li>
</ul>
<h3 id="golang-各个版本gc改进">Golang 各个版本GC改进<a href="#golang-各个版本gc改进" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<table>
<thead>
<tr>
<th>版本</th>
<th>发布时间</th>
<th>GC算法</th>
<th>STW时间</th>
<th>重大改变</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1</td>
<td>2013.5</td>
<td>STW</td>
<td>秒级</td>
<td></td>
</tr>
<tr>
<td>1.3</td>
<td>2014.6</td>
<td>Mark和Sweep分离. Mark STW, Sweep并发</td>
<td>百ms级别</td>
<td></td>
</tr>
<tr>
<td>1.4</td>
<td>2014.12</td>
<td>runtime代码基本都由C和少量汇编改为Go和少量汇编, 包括GC部分, 以此实现了准确式GC,减少了堆大小, 同时对指针的写入引入了write barrier, 为1.5铺垫</td>
<td>百ms级别</td>
<td></td>
</tr>
<tr>
<td>1.5</td>
<td>2015.8</td>
<td>三色标记法, 并发Mark, 并发Sweep. 非分代, 非移动, 并发的收集器</td>
<td>10ms-40ms级别</td>
<td>重要更新版本,生产上GC基本不会成为问题</td>
</tr>
<tr>
<td>1.6</td>
<td>2016.2</td>
<td>1.5中一些与并发GC不协调的地方更改. 集中式的GC协调协程, 改为状态机实现</td>
<td>5-20ms</td>
<td></td>
</tr>
<tr>
<td>1.7</td>
<td>2016.8</td>
<td>GC时栈收缩改为并发, span中对象分配状态由freelist改为bitmap</td>
<td>1-3ms左右</td>
<td></td>
</tr>
<tr>
<td>1.8</td>
<td>2017.2</td>
<td>hybird write barrier, 消除了stw中的重新扫描栈</td>
<td>sub ms</td>
<td>Golang GC进入Sub ms时代，hybrid write barrier</td>
</tr>
</tbody>
</table>
<h3 id="stop-the-world">Stop The World<a href="#stop-the-world" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>各个版本的STW时间
<img src="/posts/images/stw.png" alt="stw"></p>
<h3 id="三色标记法">三色标记法<a href="#三色标记法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>Golang三色标记法通过标记，将对象全部归类到3个集合，分别是白色对象、灰色对象和黑色对象。标记结束后，白色对象会被回收掉。</p>
<p><img src="/posts/images/sweep.gif" alt="sweep"></p>
<ol>
<li>首先将所有节点都放到白色对象集合</li>
<li>从根节点开始遍历对象，遍历到的白色对象从白色集合放到灰色集合中</li>
<li>遍历灰色集合中的对象，把灰色对象引用的白色对象放入到灰色集合，通过把遍历过的灰色对象放到黑色集合中</li>
<li>循环步骤3，直到灰色集合中没有对象</li>
<li>完成扫描后，白色对象就是不可达的对象，进行回收</li>
</ol>
<h3 id="stop-the-world-1">Stop The World<a href="#stop-the-world-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>在扫描之前执行STW操作，就是Runtime把所有的线程全部冻结掉，所有的线程全部冻结掉意味着⽤户逻辑肯定都是暂停的，所有的⽤户对象都不会被修改了，这时候去扫描肯定是安全的</p>
<p>在执行STW过程中，用户的逻辑是暂停的，那么我们就需要保证这个时间尽量短，才能不影响我们的功能，那Golang是如何处理的：</p>
<ul>
<li>新生的对象，一律标记为灰色对象</li>
<li>如果灰色或者黑色对象引用了白色对象，就会触发写屏障，GC就会将白色对象标记为灰色对象</li>
</ul>
<h3 id="写屏障">写屏障<a href="#写屏障" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>在标记的阶段，对象是可以进行修改的，如果在标记的过程中，对象引用发生了变更，就可能会导致回收错误，所以需要加入写屏障。 写屏障会将写操作和之后写操作对比。</p>
<h3 id="流程图">流程图<a href="#流程图" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><img src="/posts/images/gc_detail.png" alt="gc_detail"></p>
<h3 id="gc触发条件">GC触发条件<a href="#gc触发条件" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>gcTriggerAlways: 强制触发GC
gcTriggerHeap: 当堆内存大小到达一定值则触发GC
gcTriggerTime: 当具体上次GC时间超过2min，则触发GC
gcTriggerCycle: 启动新一轮GC，如果已启动则跳过，手动触发GC(runtime.GC)会使用这个条件</p>
<p>触发条件在gcTrigger.test方法，其中gcTriggerHeap会动态判断：
当heap_live大于gc_trigger，则触发gc</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="nf">test</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span> <span class="o">&gt;=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_trigger</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>gc_trigger是触发gc的值，在gcSetTriggerRatio中计算，初始值是7 / 8.0</p>
<p>gcpercent和Golang里的一个环境变量有关，GOGC，默认是100，意思是live heap size 自上次垃圾回收后，增长1倍GC触发运行，gcpercent 默认也是100
gcController.endCycle()</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="c1">// 触发比例
</span><span class="c1"></span>	<span class="kd">const</span> <span class="nx">triggerGain</span> <span class="p">=</span> <span class="mf">0.5</span>

	<span class="c1">// 目标heap增长率，默认是1.0
</span><span class="c1"></span>	<span class="nx">goalGrowthRatio</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gcpercent</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span>
	<span class="c1">// 实际heap增长率， 总大小 / (上一次GC标记的bytes) - 1
</span><span class="c1"></span>	<span class="nx">actualGrowthRatio</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span><span class="o">/</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="c1">// GC标记阶段时间
</span><span class="c1"></span>	<span class="nx">assistDuration</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">c</span><span class="p">.</span><span class="nx">markStartTime</span>

	<span class="c1">// GC标记阶段CPU使用率，0.25
</span><span class="c1"></span>	<span class="nx">utilization</span> <span class="o">:=</span> <span class="nx">gcBackgroundUtilization</span>
	<span class="c1">// Add assist utilization; avoid divide by zero.
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">assistDuration</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// assistTime 是G辅助GC标记对象所使用的时间总和
</span><span class="c1"></span>		<span class="c1">// utilization += 辅助gc标记总时间/ GC标记时间*CPU个数
</span><span class="c1"></span>		<span class="nx">utilization</span> <span class="o">+=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">assistTime</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">assistDuration</span><span class="o">*</span><span class="nb">int64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// 
</span><span class="c1"></span>	<span class="nx">triggerError</span> <span class="o">:=</span> <span class="nx">goalGrowthRatio</span> <span class="o">-</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span> <span class="o">-</span> <span class="nx">utilization</span><span class="o">/</span><span class="nx">gcGoalUtilization</span><span class="o">*</span><span class="p">(</span><span class="nx">actualGrowthRatio</span><span class="o">-</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span><span class="p">)</span>

	<span class="c1">// 渐进式调整，每次只调整一半的值
</span><span class="c1"></span>	<span class="nx">triggerRatio</span> <span class="o">:=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span> <span class="o">+</span> <span class="nx">triggerGain</span><span class="o">*</span><span class="nx">triggerError</span>
<span class="p">}</span>
</code></pre></div><h3 id="辅助gcmutator-assist">辅助GC(mutator assist)<a href="#辅助gcmutator-assist" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h3 id="gc过程">GC过程<a href="#gc过程" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>为了防止heap增速太快，在GC执行过程中如果同时运行G分配了内存，则这个G会被要求辅助GC做一部分工作</p>
<p>assistWorkPerByte计算公式在revise
assistBytesPerWork</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">revise</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">gcpercent</span> <span class="o">:=</span> <span class="nx">gcpercent</span>
	<span class="k">if</span> <span class="nx">gcpercent</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// If GC is disabled but we&#39;re running a forced GC,
</span><span class="c1"></span>		<span class="c1">// act like GOGC is huge for the below calculations.
</span><span class="c1"></span>		<span class="nx">gcpercent</span> <span class="p">=</span> <span class="mi">100000</span>
	<span class="p">}</span>
	<span class="nx">live</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">heapGoal</span><span class="p">,</span> <span class="nx">scanWorkExpected</span> <span class="kt">int64</span>
	<span class="c1">// 当前活动的heap大于下一次gc的heap_live
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">live</span> <span class="o">&lt;=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">{</span>
		<span class="c1">// 我们在软目标下
</span><span class="c1"></span>		<span class="nx">heapGoal</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="p">)</span>

		<span class="c1">// 计算预期剩余扫描工作，如果GOGC=100，只有扫描heap一半的被认为是live
</span><span class="c1"></span>		<span class="nx">scanWorkExpected</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="mi">100</span><span class="o">+</span><span class="nx">gcpercent</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 我们达到了硬限制，
</span><span class="c1"></span>		<span class="kd">const</span> <span class="nx">maxOvershoot</span> <span class="p">=</span> <span class="mf">1.1</span>
		<span class="nx">heapGoal</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="p">)</span> <span class="o">*</span> <span class="nx">maxOvershoot</span><span class="p">)</span>

		<span class="c1">// 计算扫描工作的上线
</span><span class="c1"></span>		<span class="nx">scanWorkExpected</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 计算剩余扫描工作
</span><span class="c1"></span>	<span class="nx">scanWorkRemaining</span> <span class="o">:=</span> <span class="nx">scanWorkExpected</span> <span class="o">-</span> <span class="nx">c</span><span class="p">.</span><span class="nx">scanWork</span>
	<span class="k">if</span> <span class="nx">scanWorkRemaining</span> <span class="p">&lt;</span> <span class="mi">1000</span> <span class="p">{</span>
		<span class="c1">// We set a somewhat arbitrary lower bound on
</span><span class="c1"></span>		<span class="c1">// remaining scan work since if we aim a little high,
</span><span class="c1"></span>		<span class="c1">// we can miss by a little.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// We *do* need to enforce that this is at least 1,
</span><span class="c1"></span>		<span class="c1">// since marking is racy and double-scanning objects
</span><span class="c1"></span>		<span class="c1">// may legitimately make the remaining scan work
</span><span class="c1"></span>		<span class="c1">// negative, even in the hard goal regime.
</span><span class="c1"></span>		<span class="nx">scanWorkRemaining</span> <span class="p">=</span> <span class="mi">1000</span>
	<span class="p">}</span>

	<span class="c1">// 计算剩余堆
</span><span class="c1"></span>	<span class="nx">heapRemaining</span> <span class="o">:=</span> <span class="nx">heapGoal</span> <span class="o">-</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">live</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">heapRemaining</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// This shouldn&#39;t happen, but if it does, avoid
</span><span class="c1"></span>		<span class="c1">// dividing by zero or setting the assist negative.
</span><span class="c1"></span>		<span class="nx">heapRemaining</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="c1">// 计算辅助助手
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">assistWorkPerByte</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">scanWorkRemaining</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">heapRemaining</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">assistBytesPerWork</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">heapRemaining</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">scanWorkRemaining</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h4 id="gcstart">gcStart<a href="#gcstart" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>gc触发函数</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcStart</span><span class="p">(</span><span class="nx">trigger</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 判断当前g是否可抢占， 不抢占不触发
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="o">||</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nx">mp</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// 触发gc并且开始并行扫描
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">trigger</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="c1">// 加锁
</span><span class="c1"></span>	<span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
	<span class="c1">// 检测是否触发gc
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">trigger</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 检查是否强制触发gc
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">userForced</span> <span class="p">=</span> <span class="nx">trigger</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">gcTriggerAlways</span> <span class="o">||</span> <span class="nx">trigger</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">gcTriggerCycle</span>

	<span class="c1">// 判断是否禁止了并行gc
</span><span class="c1"></span>	<span class="nx">mode</span> <span class="o">:=</span> <span class="nx">gcBackgroundMode</span>
	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcstoptheworld</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">mode</span> <span class="p">=</span> <span class="nx">gcForceMode</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcstoptheworld</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="nx">mode</span> <span class="p">=</span> <span class="nx">gcForceBlockMode</span>
	<span class="p">}</span>

	<span class="c1">// Ok, we&#39;re doing it! Stop everybody else
</span><span class="c1"></span>	<span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCStart</span><span class="p">()</span>
	<span class="p">}</span>

    <span class="c1">// 如果.mcache.flushGen不等于mheap_.sweepgen，说明有旧的数据
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">fg</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nx">flushGen</span><span class="p">);</span> <span class="nx">fg</span> <span class="o">!=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: p&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="s">&#34;flushGen&#34;</span><span class="p">,</span> <span class="nx">fg</span><span class="p">,</span> <span class="s">&#34;!= sweepgen&#34;</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;p mcache not flushed&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 启动后台扫描任务
</span><span class="c1"></span>	<span class="nf">gcBgMarkStartWorkers</span><span class="p">()</span>

	<span class="c1">// 重置标记状态
</span><span class="c1"></span>	<span class="nf">gcResetMarkState</span><span class="p">()</span>
	<span class="c1">// 重置参数
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">maxprocs</span> <span class="p">=</span> <span class="nx">gomaxprocs</span><span class="p">,</span> <span class="nx">gomaxprocs</span>
	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span> <span class="p">&gt;</span> <span class="nx">ncpu</span> <span class="p">{</span>
		<span class="c1">// This is used to compute CPU time of the STW phases,
</span><span class="c1"></span>		<span class="c1">// so it can&#39;t be more than ncpu, even if GOMAXPROCS is.
</span><span class="c1"></span>		<span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span> <span class="p">=</span> <span class="nx">ncpu</span>
	<span class="p">}</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">heap0</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">mode</span> <span class="p">=</span> <span class="nx">mode</span>
	<span class="c1">// 记录开始时间
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSTWStart</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// STOP THE WORLD
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">stopTheWorldWithSema</span><span class="p">)</span>

	<span class="c1">// 并发扫描前确认已经完成gc标记
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">finishsweep_m</span><span class="p">()</span>
	<span class="p">})</span>

	<span class="c1">// clear sched.sudogcache和sched.deferpool
</span><span class="c1"></span>	<span class="nf">clearpools</span><span class="p">()</span>

	<span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="o">++</span>

	<span class="c1">// 开启新一轮gc前重置gcController
</span><span class="c1"></span>	<span class="nx">gcController</span><span class="p">.</span><span class="nf">startCycle</span><span class="p">()</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">heapGoal</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span>

	<span class="c1">// In STW mode, disable scheduling of user Gs. This may also
</span><span class="c1"></span>	<span class="c1">// disable scheduling of this goroutine, so it may block as
</span><span class="c1"></span>	<span class="c1">// soon as we start the world again.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mode</span> <span class="o">!=</span> <span class="nx">gcBackgroundMode</span> <span class="p">{</span>
		<span class="nf">schedEnableUser</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 进入并发标记阶段，开启写屏障
</span><span class="c1"></span>	<span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCmark</span><span class="p">)</span>

	<span class="c1">// 重置后台标记任务的计数器(nproc, nwait)
</span><span class="c1"></span>	<span class="nf">gcBgMarkPrepare</span><span class="p">()</span>

	<span class="c1">// 计算扫描根对象的任务数量
</span><span class="c1"></span>	<span class="nf">gcMarkRootPrepare</span><span class="p">()</span>

	<span class="c1">// 标记所有活动的tiny 
</span><span class="c1"></span>	<span class="nf">gcMarkTinyAllocs</span><span class="p">()</span>

	<span class="c1">// 启动辅助gc
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

	<span class="c1">// 标记开始的时间
</span><span class="c1"></span>	<span class="nx">gcController</span><span class="p">.</span><span class="nx">markStartTime</span> <span class="p">=</span> <span class="nx">now</span>

	<span class="c1">// 并发标记
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// START THE WORLD
</span><span class="c1"></span>		<span class="c1">// 标记已经在进行
</span><span class="c1"></span>		<span class="nx">now</span> <span class="p">=</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span><span class="p">)</span>
		<span class="c1">// 记录停止了多久
</span><span class="c1"></span>		<span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="o">+=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span>
		<span class="nx">work</span><span class="p">.</span><span class="nx">tMark</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="p">})</span>

	<span class="c1">// STW模式下，block
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mode</span> <span class="o">!=</span> <span class="nx">gcBackgroundMode</span> <span class="p">{</span>
		<span class="nf">Gosched</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="gcbgmarkstartworkers">gcBgMarkStartWorkers<a href="#gcbgmarkstartworkers" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>后台标记任务</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcBgMarkStartWorkers</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Background marking is performed by per-P G&#39;s. Ensure that
</span><span class="c1"></span>	<span class="c1">// each P has a background GC G.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="c1">// 是否未启动
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">go</span> <span class="nf">gcBgMarkWorker</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
			<span class="c1">// 启动后等待该任务通知信号量bgMarkReady再继续
</span><span class="c1"></span>			<span class="nf">notetsleepg</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="gcbgmarkworker">gcBgMarkWorker<a href="#gcbgmarkworker" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>后台标记任务</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcBgMarkWorker</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="kd">type</span> <span class="nx">parkInfo</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">m</span>      <span class="nx">muintptr</span> <span class="c1">// Release this m on park.
</span><span class="c1"></span>		<span class="nx">attach</span> <span class="nx">puintptr</span> <span class="c1">// If non-nil, attach to this p on park.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="c1">// We pass park to a gopark unlock function, so it can&#39;t be on
</span><span class="c1"></span>	<span class="c1">// the stack (see gopark). Prevent deadlock from recursively
</span><span class="c1"></span>	<span class="c1">// starting GC by disabling preemption.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;GC worker init&#34;</span>
	<span class="nx">park</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">parkInfo</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>

	<span class="c1">// M禁止抢占
</span><span class="c1"></span>	<span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>
	<span class="c1">// 绑定P
</span><span class="c1"></span>	<span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="c1">// 通知gcBgMarkStartWorkers已准备完毕，可以继续
</span><span class="c1"></span>	<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">)</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// Go to sleep until woken by gcController.findRunnable.
</span><span class="c1"></span>		<span class="c1">// We can&#39;t releasem yet since even the call to gopark
</span><span class="c1"></span>		<span class="c1">// may be preempted.
</span><span class="c1"></span>		<span class="c1">// 休眠直到被gcController.findRunnable唤醒
</span><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">parkp</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="nx">park</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">parkInfo</span><span class="p">)(</span><span class="nx">parkp</span><span class="p">)</span>

			<span class="c1">// The worker G is no longer running, so it&#39;s
</span><span class="c1"></span>			<span class="c1">// now safe to allow preemption.
</span><span class="c1"></span>			<span class="c1">// 扫描任务不在运行，允许抢占
</span><span class="c1"></span>			<span class="nf">releasem</span><span class="p">(</span><span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>

			<span class="c1">// 如果worker没有关联P，需要关联下
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">park</span><span class="p">.</span><span class="nx">attach</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">p</span> <span class="o">:=</span> <span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
				<span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
				<span class="c1">// 把当前G设置成gcBgMarkWorker的成员
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">g</span><span class="p">)))</span> <span class="p">{</span>
					<span class="c1">// 已经有任务，设置失败，退出休眠
</span><span class="c1"></span>					<span class="k">return</span> <span class="kc">false</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">},</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">park</span><span class="p">),</span> <span class="nx">waitReasonGCWorkerIdle</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

		<span class="c1">// 如果P的gcBgMarkWorker和当前G不一致，则退出
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">gp</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c1">// 禁止抢占
</span><span class="c1"></span>		<span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>

		<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcBgMarkWorker: blackening not enabled&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// 开始时间
</span><span class="c1"></span>		<span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerStartTime</span> <span class="p">=</span> <span class="nx">startTime</span>

		<span class="nx">decnwait</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">decnwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: work.nwait=&#34;</span><span class="p">,</span> <span class="nx">decnwait</span><span class="p">,</span> <span class="s">&#34;work.nproc=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;work.nwait was &gt; work.nproc&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 标记G可抢占以便能够扫描栈（两个标记任务可以互相扫描对方），标记任务禁止栈收缩
</span><span class="c1"></span>			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
			<span class="k">switch</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">{</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcBgMarkWorker: unexpected gcMarkWorkerMode&#34;</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">gcMarkWorkerDedicatedMode</span><span class="p">:</span>
				<span class="c1">// 只执行标记
</span><span class="c1"></span>				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span>
					<span class="c1">// 抢占成功，踢出所有的runq，然后执行gp
</span><span class="c1"></span>					<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
					<span class="k">for</span> <span class="p">{</span>
						<span class="nx">gp</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
						<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
							<span class="k">break</span>
						<span class="p">}</span>
						<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
					<span class="p">}</span>
					<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="c1">// Go back to draining, this time
</span><span class="c1"></span>				<span class="c1">// without preemption.
</span><span class="c1"></span>				<span class="c1">// 继续标记，直到没有更多任务，并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
</span><span class="c1"></span>				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">gcMarkWorkerFractionalMode</span><span class="p">:</span>
				<span class="c1">// 执行标记，直到被抢占
</span><span class="c1"></span>				<span class="c1">// 需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
</span><span class="c1"></span>				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainFractional</span><span class="p">|</span><span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">gcMarkWorkerIdleMode</span><span class="p">:</span>
				<span class="c1">// 只有在P空闲的时候执行标记，直到被抢占或者达到一定量
</span><span class="c1"></span>				<span class="c1">// 需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
</span><span class="c1"></span>				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainIdle</span><span class="p">|</span><span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 恢复G的状态到运行中
</span><span class="c1"></span>			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
		<span class="p">})</span>

		<span class="c1">// 计算时间
</span><span class="c1"></span>		<span class="nx">duration</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">startTime</span>
		<span class="k">switch</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">gcMarkWorkerDedicatedMode</span><span class="p">:</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">gcMarkWorkerFractionalMode</span><span class="p">:</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">fractionalMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">gcMarkWorkerIdleMode</span><span class="p">:</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">idleMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Was this the last worker and did we run out
</span><span class="c1"></span>		<span class="c1">// of work?
</span><span class="c1"></span>		<span class="nx">incnwait</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">incnwait</span> <span class="p">&gt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: p.gcMarkWorkerMode=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span><span class="p">,</span>
				<span class="s">&#34;work.nwait=&#34;</span><span class="p">,</span> <span class="nx">incnwait</span><span class="p">,</span> <span class="s">&#34;work.nproc=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;work.nwait &gt; work.nproc&#34;</span><span class="p">)</span>
		<span class="p">}</span>


		<span class="c1">// 判断是否所有后台标记任务都完成了，并且没有多余的任务
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">incnwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 标记G可抢占，并且取消关联
</span><span class="c1"></span>			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>

			<span class="c1">// 准备进入完成标记阶段
</span><span class="c1"></span>			<span class="nf">gcMarkDone</span><span class="p">()</span>

			<span class="c1">// 禁止抢占准备重新关联P
</span><span class="c1"></span>			<span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>
			<span class="c1">// 重新关联之前的P
</span><span class="c1"></span>			<span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="startcycle">startCycle<a href="#startcycle" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>startCycle会为新一轮的GC重置状态和估计值</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">startCycle</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">bgScanCredit</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">assistTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">fractionalMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">idleMarkTime</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// If this is the first GC cycle or we&#39;re operating on a very
</span><span class="c1"></span>	<span class="c1">// small heap, fake heap_marked so it looks like gc_trigger is
</span><span class="c1"></span>	<span class="c1">// the appropriate growth from heap_marked, even though the
</span><span class="c1"></span>	<span class="c1">// real heap_marked may not have a meaningful value (on the
</span><span class="c1"></span>	<span class="c1">// first cycle) or may be much smaller (resulting in a large
</span><span class="c1"></span>	<span class="c1">// error response).
</span><span class="c1"></span>
	<span class="c1">// 如果是第一次GC或者当前的heap非常小，我们需要伪装一个heap_marked来防止后面triggerRatio过小
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_trigger</span> <span class="o">&lt;=</span> <span class="nx">heapminimum</span> <span class="p">{</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_trigger</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// 重新计算gc的heap的目标
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span> <span class="o">+</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span><span class="o">*</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">gcpercent</span><span class="p">)</span><span class="o">/</span><span class="mi">100</span>
	<span class="k">if</span> <span class="nx">gcpercent</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 确保本次heap的目标只要应该大于活动的对大小，至少应该高1MB
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">&lt;</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="o">+</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span> <span class="p">{</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span> <span class="o">+</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span>
	<span class="p">}</span>

	<span class="c1">// Compute the background mark utilization goal. In general,
</span><span class="c1"></span>	<span class="c1">// this may not come out exactly. We round the number of
</span><span class="c1"></span>	<span class="c1">// dedicated workers so that the utilization is closest to
</span><span class="c1"></span>	<span class="c1">// 25%. For small GOMAXPROCS, this would introduce too much
</span><span class="c1"></span>	<span class="c1">// error, so we add fractional workers in that case.
</span><span class="c1"></span>	<span class="c1">// 计算后台标记任务的使用率，一般情况下是25%
</span><span class="c1"></span>	<span class="c1">// totalUtilizationGoal = cpu * 0.25
</span><span class="c1"></span>	<span class="c1">// 专用的标记任务数 dedicatedMarkWorkersNeeded = cpu * 0.25 + 0.5
</span><span class="c1"></span>	<span class="nx">totalUtilizationGoal</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span> <span class="o">*</span> <span class="nx">gcBackgroundUtilization</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">totalUtilizationGoal</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
	<span class="c1">// 
</span><span class="c1"></span>	<span class="nx">utilError</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span><span class="o">/</span><span class="nx">totalUtilizationGoal</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="kd">const</span> <span class="nx">maxUtilError</span> <span class="p">=</span> <span class="mf">0.3</span>
	<span class="k">if</span> <span class="nx">utilError</span> <span class="p">&lt;</span> <span class="o">-</span><span class="nx">maxUtilError</span> <span class="o">||</span> <span class="nx">utilError</span> <span class="p">&gt;</span> <span class="nx">maxUtilError</span> <span class="p">{</span>
		<span class="c1">// Rounding put us more than 30% off our goal. With
</span><span class="c1"></span>		<span class="c1">// gcBackgroundUtilization of 25%, this happens for
</span><span class="c1"></span>		<span class="c1">// GOMAXPROCS&lt;=3 or GOMAXPROCS=6. Enable fractional
</span><span class="c1"></span>		<span class="c1">// workers to compensate.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">totalUtilizationGoal</span> <span class="p">{</span>
			<span class="c1">// 太多任务
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">=</span> <span class="p">(</span><span class="nx">totalUtilizationGoal</span> <span class="o">-</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// In STW mode, we just want dedicated workers.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcstoptheworld</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// 重置辅助gc的时间统计和gcFractionalMarkTime
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">gcAssistTime</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// Compute initial values for controls that are updated
</span><span class="c1"></span>	<span class="c1">// throughout the cycle.
</span><span class="c1"></span>	<span class="c1">// 计算辅助gc的参数
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcpacertrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;pacer: assist ratio=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">assistWorkPerByte</span><span class="p">,</span>
			<span class="s">&#34; (scan &#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34; MB in &#34;</span><span class="p">,</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">initialHeapLive</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;-&gt;&#34;</span><span class="p">,</span>
			<span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34; MB)&#34;</span><span class="p">,</span>
			<span class="s">&#34; workers=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">,</span>
			<span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="revise">revise<a href="#revise" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">revise</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">gcpercent</span> <span class="o">:=</span> <span class="nx">gcpercent</span>
	<span class="k">if</span> <span class="nx">gcpercent</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// If GC is disabled but we&#39;re running a forced GC,
</span><span class="c1"></span>		<span class="c1">// act like GOGC is huge for the below calculations.
</span><span class="c1"></span>		<span class="nx">gcpercent</span> <span class="p">=</span> <span class="mi">100000</span>
	<span class="p">}</span>
	<span class="nx">live</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">heapGoal</span><span class="p">,</span> <span class="nx">scanWorkExpected</span> <span class="kt">int64</span>
	<span class="c1">// 当前活动的heap大于下一次gc的heap_live
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">live</span> <span class="o">&lt;=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">{</span>
		<span class="c1">// 我们在软目标下
</span><span class="c1"></span>		<span class="nx">heapGoal</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="p">)</span>

		<span class="c1">// 计算预期剩余扫描工作，如果GOGC=100，只有扫描heap一半的被认为是live
</span><span class="c1"></span>		<span class="nx">scanWorkExpected</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="mi">100</span><span class="o">+</span><span class="nx">gcpercent</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 我们达到了硬限制，
</span><span class="c1"></span>		<span class="kd">const</span> <span class="nx">maxOvershoot</span> <span class="p">=</span> <span class="mf">1.1</span>
		<span class="nx">heapGoal</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="p">)</span> <span class="o">*</span> <span class="nx">maxOvershoot</span><span class="p">)</span>

		<span class="c1">// 计算扫描工作的上线
</span><span class="c1"></span>		<span class="nx">scanWorkExpected</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 计算剩余扫描工作
</span><span class="c1"></span>	<span class="nx">scanWorkRemaining</span> <span class="o">:=</span> <span class="nx">scanWorkExpected</span> <span class="o">-</span> <span class="nx">c</span><span class="p">.</span><span class="nx">scanWork</span>
	<span class="k">if</span> <span class="nx">scanWorkRemaining</span> <span class="p">&lt;</span> <span class="mi">1000</span> <span class="p">{</span>
		<span class="c1">// We set a somewhat arbitrary lower bound on
</span><span class="c1"></span>		<span class="c1">// remaining scan work since if we aim a little high,
</span><span class="c1"></span>		<span class="c1">// we can miss by a little.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// We *do* need to enforce that this is at least 1,
</span><span class="c1"></span>		<span class="c1">// since marking is racy and double-scanning objects
</span><span class="c1"></span>		<span class="c1">// may legitimately make the remaining scan work
</span><span class="c1"></span>		<span class="c1">// negative, even in the hard goal regime.
</span><span class="c1"></span>		<span class="nx">scanWorkRemaining</span> <span class="p">=</span> <span class="mi">1000</span>
	<span class="p">}</span>

	<span class="c1">// 计算剩余堆
</span><span class="c1"></span>	<span class="nx">heapRemaining</span> <span class="o">:=</span> <span class="nx">heapGoal</span> <span class="o">-</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">live</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">heapRemaining</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// This shouldn&#39;t happen, but if it does, avoid
</span><span class="c1"></span>		<span class="c1">// dividing by zero or setting the assist negative.
</span><span class="c1"></span>		<span class="nx">heapRemaining</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="c1">// Compute the mutator assist ratio so by the time the mutator
</span><span class="c1"></span>	<span class="c1">// allocates the remaining heap bytes up to next_gc, it will
</span><span class="c1"></span>	<span class="c1">// have done (or stolen) the remaining amount of scan work.
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">assistWorkPerByte</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">scanWorkRemaining</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">heapRemaining</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">assistBytesPerWork</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">heapRemaining</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">scanWorkRemaining</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="gcmarkrootprepare">gcMarkRootPrepare<a href="#gcmarkrootprepare" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>计算扫描根对象的任务数量</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkRootPrepare</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">nFlushCacheRoots</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// 计算有多少数据和BSS， rootBlockBytes是256KB
</span><span class="c1"></span>	<span class="nx">nBlocks</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">bytes</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="nx">bytes</span> <span class="o">+</span> <span class="nx">rootBlockBytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nx">rootBlockBytes</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// Scan globals.
</span><span class="c1"></span>	<span class="c1">// 计算扫描可读写的全局变量的任务数量
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">nDataRoots</span> <span class="o">:=</span> <span class="nf">nBlocks</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">edata</span> <span class="o">-</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">nDataRoots</span> <span class="p">&gt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span> <span class="p">{</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span> <span class="p">=</span> <span class="nx">nDataRoots</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 计算扫描只读的全局变量的任务数量
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">nBSSRoots</span> <span class="o">:=</span> <span class="nf">nBlocks</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">ebss</span> <span class="o">-</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">bss</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">nBSSRoots</span> <span class="p">&gt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span> <span class="p">{</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span> <span class="p">=</span> <span class="nx">nBSSRoots</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Scan span roots for finalizer specials.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We depend on addfinalizer to mark objects that get
</span><span class="c1"></span>	<span class="c1">// finalizers after root marking.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We&#39;re only interested in scanning the in-use spans,
</span><span class="c1"></span>	<span class="c1">// which will all be swept at this point. More spans
</span><span class="c1"></span>	<span class="c1">// may be added to this list during concurrent GC, but
</span><span class="c1"></span>	<span class="c1">// we only care about spans that were allocated before
</span><span class="c1"></span>	<span class="c1">// this mark phase.
</span><span class="c1"></span>	<span class="c1">// 计算扫描span中finalizer的数量
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">nSpanRoots</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">numBlocks</span><span class="p">()</span>

	<span class="c1">// Scan stacks.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Gs may be created after this point, but it&#39;s okay that we
</span><span class="c1"></span>	<span class="c1">// ignore them because they begin life without any roots, so
</span><span class="c1"></span>	<span class="c1">// there&#39;s nothing to scan, and any roots they create during
</span><span class="c1"></span>	<span class="c1">// the concurrent phase will be scanned during mark
</span><span class="c1"></span>	<span class="c1">// termination.
</span><span class="c1"></span>	<span class="c1">// 计算扫描栈的任务数量
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">nStackRoots</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglen</span><span class="p">))</span>

	<span class="c1">// 计算总任务数量
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">fixedRootCount</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nFlushCacheRoots</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nSpanRoots</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nStackRoots</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="gcmarktinyallocs">gcMarkTinyAllocs<a href="#gcmarktinyallocs" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>gcMarkTinyAllocs会标记所有的tiny</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkTinyAllocs</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">mcache</span>
		<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcw</span>
		<span class="nf">greyobject</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nx">objIndex</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="findrunnablegcworker">findRunnableGCWorker<a href="#findrunnablegcworker" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>findRunnableGCWorker会获取后台的标记任务，决定是否运行</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">findRunnableGCWorker</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcControllerState.findRunnable: blackening not enabled&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// The mark worker associated with this P is blocked
</span><span class="c1"></span>		<span class="c1">// performing a mark transition. We can&#39;t run it
</span><span class="c1"></span>		<span class="c1">// because it may be on some other run or wait queue.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// No work to be done right now. This can happen at
</span><span class="c1"></span>		<span class="c1">// the end of the mark phase when there are still
</span><span class="c1"></span>		<span class="c1">// assists tapering off. Don&#39;t bother running a worker
</span><span class="c1"></span>		<span class="c1">// now because it&#39;ll just return immediately.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// 原子减少值，如果减少后大于等于0则返回true， 否则返回true
</span><span class="c1"></span>	<span class="nx">decIfPositive</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ptr</span> <span class="o">*</span><span class="kt">int64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="o">*</span><span class="nx">ptr</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">true</span>
			<span class="p">}</span>
			<span class="c1">// We lost a race
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// 减少dedicatedMarkWorkersNeeded，成功后是dedicated
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">decIfPositive</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// This P is now dedicated to marking until the end of
</span><span class="c1"></span>		<span class="c1">// the concurrent mark phase.
</span><span class="c1"></span>		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerDedicatedMode</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// No need for fractional workers.
</span><span class="c1"></span>		<span class="c1">// 不需要
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Is this P behind on the fractional utilization
</span><span class="c1"></span>		<span class="c1">// goal?
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// This should be kept in sync with pollFractionalWorkerExit.
</span><span class="c1"></span>		<span class="nx">delta</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">markStartTime</span>
		<span class="k">if</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span><span class="p">)</span><span class="o">/</span><span class="nb">float64</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">{</span>
			<span class="c1">// Nope. No need to run a fractional worker.
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="c1">// Run a fractional worker.
</span><span class="c1"></span>		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerFractionalMode</span>
	<span class="p">}</span>

	<span class="c1">// 运行后台标记任务
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>
</code></pre></div><h3 id="starttheworldwithsema">startTheWorldWithSema<a href="#starttheworldwithsema" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stopTheWorldWithSema</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// If we hold a lock, then we won&#39;t be able to stop another M
</span><span class="c1"></span>	<span class="c1">// that is blocked trying to acquire the lock.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopTheWorld: holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 需要停止P的数量
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="p">=</span> <span class="nx">gomaxprocs</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 抢占所有运行中的G
</span><span class="c1"></span>	<span class="nf">preemptall</span><span class="p">()</span>
	<span class="c1">// 停止当前的P
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span> <span class="c1">// Pgcstop is only diagnostic.
</span><span class="c1"></span>	<span class="c1">// 减少停止的P-当前的P
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
	<span class="c1">// try to retake all P&#39;s in Psyscall status
</span><span class="c1"></span>	<span class="c1">// 尝试抢占所有处在Psyscall状态的P
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span>
		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">_Pgcstop</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
				<span class="nf">traceGoSysBlock</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
				<span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">syscalltick</span><span class="o">++</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// stop idle P&#39;s
</span><span class="c1"></span>	<span class="c1">// 再次停止空闲的P，防止进入调度
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nf">pidleget</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="nx">wait</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="p">&gt;</span> <span class="mi">0</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// wait for remaining P&#39;s to stop voluntarily
</span><span class="c1"></span>	<span class="c1">// 等待剩余的P停止
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">wait</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="c1">// 等待100微秒，然后尝试重新抢占
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">notetsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nf">preemptall</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 再次检查
</span><span class="c1"></span>	<span class="nx">bad</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;stopTheWorld: not stopped (stopwait != 0)&#34;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Pgcstop</span> <span class="p">{</span>
				<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;stopTheWorld: not stopped (status != _Pgcstop)&#34;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">freezing</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Some other thread is panicking. This can cause the
</span><span class="c1"></span>		<span class="c1">// sanity checks above to fail if the panic happens in
</span><span class="c1"></span>		<span class="c1">// the signal handler on a stopped thread. Either way,
</span><span class="c1"></span>		<span class="c1">// we should halt this thread.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">deadlock</span><span class="p">)</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">deadlock</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">bad</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="nx">bad</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="starttheworldwithsema-1">startTheWorldWithSema<a href="#starttheworldwithsema-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="nx">emitTraceEvent</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// 禁止g抢占
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 获取netpoll事件，并将其加入到待运行队列
</span><span class="c1"></span>		<span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// non-blocking
</span><span class="c1"></span>		<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 获取当前gomaxprocs
</span><span class="c1"></span>	<span class="nx">procs</span> <span class="o">:=</span> <span class="nx">gomaxprocs</span>
	<span class="k">if</span> <span class="nx">newprocs</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">procs</span> <span class="p">=</span> <span class="nx">newprocs</span>
		<span class="nx">newprocs</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">p1</span> <span class="o">:=</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span>
	<span class="c1">// 取消gc等待标记
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// 如果sysmon在等待则唤醒它
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 唤醒所有可运行的P
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">p1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">p1</span>
		<span class="nx">p1</span> <span class="p">=</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">mp</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startTheWorld: inconsistent mp-&gt;nextp&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
			<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// Start M to run P.  Do not start another M below.
</span><span class="c1"></span>			<span class="nf">newm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Capture start-the-world time before doing clean-up tasks.
</span><span class="c1"></span>	<span class="c1">// 记录事件
</span><span class="c1"></span>	<span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">emitTraceEvent</span> <span class="p">{</span>
		<span class="nf">traceGCSTWDone</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Wakeup an additional proc in case we have excessive runnable goroutines
</span><span class="c1"></span>	<span class="c1">// in local queues or in the global queue. If we don&#39;t, the proc will park itself.
</span><span class="c1"></span>	<span class="c1">// If we have lots of excessive work, resetspinning will unpark additional procs as necessary.
</span><span class="c1"></span>	<span class="c1">// 如果这里还有的空闲pidle并且m还在自旋，则继续环境
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">wakep</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="c1">// 恢复抢占请求
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span> <span class="c1">// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">startTime</span>
<span class="p">}</span>

</code></pre></div><h4 id="gcdrain">gcDrain<a href="#gcdrain" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>gcDrain 从根部和对象开始扫描，将灰色对象变黑直到没有任务需要处理</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcDrain</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">flags</span> <span class="nx">gcDrainFlags</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">needed</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcDrain phase incorrect&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
	<span class="c1">// 当前g在抢占中，直接返回
</span><span class="c1"></span>	<span class="nx">preemptible</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainUntilPreempt</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="c1">// 刷新gc扫描任务
</span><span class="c1"></span>	<span class="nx">flushBgCredit</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainFlushBgCredit</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="c1">// 是否空闲
</span><span class="c1"></span>	<span class="nx">idle</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainIdle</span> <span class="o">!=</span> <span class="mi">0</span>

	<span class="c1">// 记录初始已扫描的数量
</span><span class="c1"></span>	<span class="nx">initScanWork</span> <span class="o">:=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span>

	<span class="c1">// checkWork is the scan work before performing the next
</span><span class="c1"></span>	<span class="c1">// self-preempt check.
</span><span class="c1"></span>	<span class="c1">// checkWork 在扫描之前检查
</span><span class="c1"></span>	<span class="nx">checkWork</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">check</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span>
	<span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">gcDrainIdle</span><span class="p">|</span><span class="nx">gcDrainFractional</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">checkWork</span> <span class="p">=</span> <span class="nx">initScanWork</span> <span class="o">+</span> <span class="nx">drainCheckThreshold</span>
		<span class="k">if</span> <span class="nx">idle</span> <span class="p">{</span>
			<span class="nx">check</span> <span class="p">=</span> <span class="nx">pollWork</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainFractional</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">check</span> <span class="p">=</span> <span class="nx">pollFractionalWorkerExit</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 如果根对象未扫描完， 则先扫描根对象
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span> <span class="p">&lt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">!(</span><span class="nx">preemptible</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 从扫描队列中取出一个值
</span><span class="c1"></span>			<span class="nx">job</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">job</span> <span class="o">&gt;=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="c1">// 执行跟对象扫描
</span><span class="c1"></span>			<span class="nf">markroot</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">job</span><span class="p">)</span>
			<span class="c1">// 如果是idle模式并且有其他工作，则返回
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">check</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">done</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 消费标记队列
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">!(</span><span class="nx">preemptible</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 如果全局标记队列为空，把本地标记队列的一部分分过去
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">full</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nf">balance</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="nx">b</span> <span class="o">:=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGetFast</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGet</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// 刷新写屏障buffer，尝试再次获取标记队列
</span><span class="c1"></span>				<span class="nf">wbBufFlush</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
				<span class="nx">b</span> <span class="p">=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGet</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 为空，则退出
</span><span class="c1"></span>			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nf">scanobject</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>

		<span class="c1">// 如果扫描的对象已经超过gcCreditSlack=2000
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">&gt;=</span> <span class="nx">gcCreditSlack</span> <span class="p">{</span>
			<span class="c1">// 把扫描的对象加入到全局
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">)</span>
			<span class="c1">// 减少辅助GC的工作量和唤醒等待的G
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">flushBgCredit</span> <span class="p">{</span>
				<span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">-</span> <span class="nx">initScanWork</span><span class="p">)</span>
				<span class="nx">initScanWork</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">}</span>
			<span class="nx">checkWork</span> <span class="o">-=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>

			<span class="k">if</span> <span class="nx">checkWork</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">checkWork</span> <span class="o">+=</span> <span class="nx">drainCheckThreshold</span>
				<span class="k">if</span> <span class="nx">check</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nx">done</span><span class="p">:</span>
	<span class="c1">// 把扫描的对象数量添加到全局
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">)</span>
		<span class="c1">// 减少辅助GC的工作量和唤醒等待的G
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">flushBgCredit</span> <span class="p">{</span>
			<span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">-</span> <span class="nx">initScanWork</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="markroot">markroot<a href="#markroot" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>根对象扫描工作</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">markroot</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 根据算出的数组去执行对应的任务
</span><span class="c1"></span>	<span class="nx">baseFlushCache</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">fixedRootCount</span><span class="p">)</span>
	<span class="nx">baseData</span> <span class="o">:=</span> <span class="nx">baseFlushCache</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nFlushCacheRoots</span><span class="p">)</span>
	<span class="nx">baseBSS</span> <span class="o">:=</span> <span class="nx">baseData</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span><span class="p">)</span>
	<span class="nx">baseSpans</span> <span class="o">:=</span> <span class="nx">baseBSS</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span><span class="p">)</span>
	<span class="nx">baseStacks</span> <span class="o">:=</span> <span class="nx">baseSpans</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nSpanRoots</span><span class="p">)</span>
	<span class="nx">end</span> <span class="o">:=</span> <span class="nx">baseStacks</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nStackRoots</span><span class="p">)</span>

	<span class="c1">// Note: if you add a case here, please also update heapdump.go:dumproots.
</span><span class="c1"></span>	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">baseFlushCache</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseData</span><span class="p">:</span>
		<span class="c1">// 释放mache中的span
</span><span class="c1"></span>		<span class="nf">flushmcache</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="nx">baseFlushCache</span><span class="p">))</span>

	<span class="k">case</span> <span class="nx">baseData</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseBSS</span><span class="p">:</span>
		<span class="c1">// 扫描可读写的全局变量
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">markrootBlock</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">edata</span><span class="o">-</span><span class="nx">datap</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">gcdatamask</span><span class="p">.</span><span class="nx">bytedata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseData</span><span class="p">))</span>
		<span class="p">}</span>

	<span class="k">case</span> <span class="nx">baseBSS</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseSpans</span><span class="p">:</span>
		<span class="c1">// 扫描只读的环境变量
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">markrootBlock</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">bss</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">ebss</span><span class="o">-</span><span class="nx">datap</span><span class="p">.</span><span class="nx">bss</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">gcbssmask</span><span class="p">.</span><span class="nx">bytedata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseBSS</span><span class="p">))</span>
		<span class="p">}</span>

	<span class="k">case</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">fixedRootFinalizers</span><span class="p">:</span>
		<span class="c1">// 扫描析构器队列
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">fb</span> <span class="o">:=</span> <span class="nx">allfin</span><span class="p">;</span> <span class="nx">fb</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">fb</span> <span class="p">=</span> <span class="nx">fb</span><span class="p">.</span><span class="nx">alllink</span> <span class="p">{</span>
			<span class="nx">cnt</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fb</span><span class="p">.</span><span class="nx">cnt</span><span class="p">))</span>
			<span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fb</span><span class="p">.</span><span class="nx">fin</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">cnt</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">fb</span><span class="p">.</span><span class="nx">fin</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">&amp;</span><span class="nx">finptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>

	<span class="k">case</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">fixedRootFreeGStacks</span><span class="p">:</span>
		<span class="c1">// 释放中止的栈（Gdead）
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="nx">markrootFreeGStacks</span><span class="p">)</span>

	<span class="k">case</span> <span class="nx">baseSpans</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseStacks</span><span class="p">:</span>
		<span class="c1">// 扫描各个span的特殊对象
</span><span class="c1"></span>		<span class="nf">markrootSpans</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseSpans</span><span class="p">))</span>

	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// 扫描各个栈
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span>
		<span class="c1">// 获取需要扫描的g
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">baseStacks</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">end</span> <span class="p">{</span>
			<span class="nx">gp</span> <span class="p">=</span> <span class="nx">allgs</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseStacks</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;markroot: bad index&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// 记录开始的时间
</span><span class="c1"></span>		<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// We are not in a scan state
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Gwaiting</span> <span class="o">||</span> <span class="nx">status</span> <span class="o">==</span> <span class="nx">_Gsyscall</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tstart</span>
		<span class="p">}</span>

		<span class="c1">// scang must be done on the system stack in case
</span><span class="c1"></span>		<span class="c1">// we&#39;re trying to scan our own stack.
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 判断当前扫描的栈是不是自己的
</span><span class="c1"></span>			<span class="nx">userG</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
			<span class="nx">selfScan</span> <span class="o">:=</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">userG</span> <span class="o">&amp;&amp;</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">userG</span><span class="p">)</span> <span class="o">==</span> <span class="nx">_Grunning</span>
			<span class="k">if</span> <span class="nx">selfScan</span> <span class="p">{</span>
				<span class="c1">// 如果扫描的栈则将状态改成Gwaiting，防止死锁
</span><span class="c1"></span>				<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">userG</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
				<span class="nx">userG</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">waitReasonGarbageCollectionScan</span>
			<span class="p">}</span>

			<span class="c1">// 阻塞式的扫描
</span><span class="c1"></span>			<span class="nf">scang</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>

			<span class="k">if</span> <span class="nx">selfScan</span> <span class="p">{</span>
				<span class="c1">// 切换状态
</span><span class="c1"></span>				<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">userG</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">})</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="scang">scang<a href="#scang" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>扫描g的栈</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">scang</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Invariant; we (the caller, markroot for a specific goroutine) own gp.gcscandone.
</span><span class="c1"></span>	<span class="c1">// Nothing is racing with us now, but gcscandone might be set to true left over
</span><span class="c1"></span>	<span class="c1">// from an earlier round of stack scanning (we scan twice per GC).
</span><span class="c1"></span>	<span class="c1">// We use gcscandone to record whether the scan has been done during this round.
</span><span class="c1"></span>	<span class="c1">// 标记扫描未完成
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="c1">// See https://golang.org/cl/21503 for justification of the yield delay.
</span><span class="c1"></span>	<span class="kd">const</span> <span class="nx">yieldDelay</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span>
	<span class="kd">var</span> <span class="nx">nextYield</span> <span class="kt">int64</span>

	<span class="c1">// Endeavor to get gcscandone set to true,
</span><span class="c1"></span>	<span class="c1">// either by doing the stack scan ourselves or by coercing gp to scan itself.
</span><span class="c1"></span>	<span class="c1">// gp.gcscandone can transition from false to true when we&#39;re not looking
</span><span class="c1"></span>	<span class="c1">// (if we asked for preemption), so any time we lock the status using
</span><span class="c1"></span>	<span class="c1">// castogscanstatus we have to double-check that the scan is still not done.
</span><span class="c1"></span><span class="nx">loop</span><span class="p">:</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">!</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">);</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopg: invalid status&#34;</span><span class="p">)</span>

		<span class="k">case</span> <span class="nx">_Gdead</span><span class="p">:</span>
			<span class="c1">// 处于dead，跳过
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="k">break</span> <span class="nx">loop</span>

		<span class="k">case</span> <span class="nx">_Gcopystack</span><span class="p">:</span>
		<span class="c1">// 切换堆栈中
</span><span class="c1"></span>
		<span class="k">case</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">:</span>
			<span class="c1">// 运行中，将状态置为待扫描，一旦抢占后立即扫描
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">castogscanstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">s</span><span class="p">|</span><span class="nx">_Gscan</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">{</span>
					<span class="nf">scanstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>
					<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="p">}</span>
				<span class="nf">restartg</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
				<span class="k">break</span> <span class="nx">loop</span>
			<span class="p">}</span>

		<span class="k">case</span> <span class="nx">_Gscanwaiting</span><span class="p">:</span>
		<span class="c1">// 扫描等待中
</span><span class="c1"></span>
		<span class="k">case</span> <span class="nx">_Grunning</span><span class="p">:</span>
			<span class="c1">// Goroutine运行中，尝试抢占
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptscan</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="o">==</span> <span class="nx">stackPreempt</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="c1">// 要求抢占，进行扫描
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">castogscanstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gscanrunning</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">{</span>
					<span class="nx">gp</span><span class="p">.</span><span class="nx">preemptscan</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
				<span class="p">}</span>
				<span class="nf">casfrom_Gscanstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gscanrunning</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 第一次等10ms
</span><span class="c1"></span>			<span class="nx">nextYield</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">+</span> <span class="nx">yieldDelay</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">nextYield</span> <span class="p">{</span>
			<span class="nf">procyield</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">osyield</span><span class="p">()</span>
			<span class="c1">// 第二次5ms，后续每次递减
</span><span class="c1"></span>			<span class="nx">nextYield</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">+</span> <span class="nx">yieldDelay</span><span class="o">/</span><span class="mi">2</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 扫描完成，取消抢占标记
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">preemptscan</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// cancel scan request if no longer needed
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="scanstack">scanstack<a href="#scanstack" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>扫描栈</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">scanstack</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcscanvalid</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span><span class="o">&amp;</span><span class="nx">_Gscan</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime:scanstack: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;atomicstatus=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;scanstack - bad status&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="nx">_Gscan</span> <span class="p">{</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;atomicstatus=&#34;</span><span class="p">,</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mark - bad status&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">_Gdead</span><span class="p">:</span>
		<span class="k">return</span>
	<span class="k">case</span> <span class="nx">_Grunning</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;atomicstatus=&#34;</span><span class="p">,</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;scanstack: goroutine not stopped&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">:</span>
		<span class="c1">// 只有这三种状态允许扫描
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;can&#39;t scan our own stack&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 如果不适用太多栈，则收缩栈
</span><span class="c1"></span>	<span class="nf">shrinkstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">state</span> <span class="nx">stackScanState</span>
	<span class="nx">state</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span>

	<span class="k">if</span> <span class="nx">stackTraceDebug</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;stack trace goroutine&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Scan the saved context register. This is effectively a live
</span><span class="c1"></span>	<span class="c1">// register that gets moved back and forth between the
</span><span class="c1"></span>	<span class="c1">// register and sched.ctxt without a write barrier.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span><span class="p">)),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oneptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 扫描栈
</span><span class="c1"></span>	<span class="nx">scanframe</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">frame</span> <span class="o">*</span><span class="nx">stkframe</span><span class="p">,</span> <span class="nx">unused</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="nf">scanframeworker</span><span class="p">(</span><span class="nx">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="c1">// 枚举所有的调用帧，分别调用scanframe
</span><span class="c1"></span>	<span class="nf">gentraceback</span><span class="p">(^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mh">0x7fffffff</span><span class="p">,</span> <span class="nx">scanframe</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="c1">// 扫描其他从堆指向对象指针， 通常是defers和panics
</span><span class="c1"></span>	<span class="nf">tracebackdefers</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">scanframe</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span><span class="p">;</span> <span class="nx">d</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">d</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">{</span>
		<span class="c1">// tracebackdefers above does not scan the func value, which could
</span><span class="c1"></span>		<span class="c1">// be a stack allocated closure. See issue 30453.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">fn</span><span class="p">)),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oneptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">state</span><span class="p">.</span><span class="nf">putPtr</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">)))</span>
	<span class="p">}</span>

	<span class="c1">// Find and scan all reachable stack objects.
</span><span class="c1"></span>	<span class="c1">// 查找和扫描所有可达的对象
</span><span class="c1"></span>	<span class="nx">state</span><span class="p">.</span><span class="nf">buildIndex</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">getPtr</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">obj</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">findObject</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">obj</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">typ</span>
		<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// We&#39;ve already scanned this object.
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">obj</span><span class="p">.</span><span class="nf">setType</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="c1">// Don&#39;t scan it again.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">stackTraceDebug</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;  live stkobj at&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">off</span><span class="p">)),</span> <span class="s">&#34;of type&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nb">string</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">gcdata</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">gcdata</span>
		<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindGCProg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// This path is pretty unlikely, an object large enough
</span><span class="c1"></span>			<span class="c1">// to have a GC program allocated on the stack.
</span><span class="c1"></span>			<span class="c1">// We need some space to unpack the program into a straight
</span><span class="c1"></span>			<span class="c1">// bitmask, which we allocate/free here.
</span><span class="c1"></span>			<span class="c1">// TODO: it would be nice if there were a way to run a GC
</span><span class="c1"></span>			<span class="c1">// program without having to store all its bits. We&#39;d have
</span><span class="c1"></span>			<span class="c1">// to change from a Lempel-Ziv style program to something else.
</span><span class="c1"></span>			<span class="c1">// Or we can forbid putting objects on stacks if they require
</span><span class="c1"></span>			<span class="c1">// a gc program (see issue 27447).
</span><span class="c1"></span>			<span class="nx">s</span> <span class="p">=</span> <span class="nf">materializeGCProg</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">,</span> <span class="nx">gcdata</span><span class="p">)</span>
			<span class="nx">gcdata</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">startAddr</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="nf">scanblock</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">off</span><span class="p">),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">,</span> <span class="nx">gcdata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">dematerializeGCProg</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Deallocate object buffers.
</span><span class="c1"></span>	<span class="c1">// (Pointer buffers were all deallocated in the loop above.)
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">state</span><span class="p">.</span><span class="nx">head</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">head</span>
		<span class="nx">state</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">next</span>
		<span class="k">if</span> <span class="nx">stackTraceDebug</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">obj</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">x</span><span class="p">.</span><span class="nx">obj</span><span class="p">[:</span><span class="nx">x</span><span class="p">.</span><span class="nx">nobj</span><span class="p">]</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// reachable
</span><span class="c1"></span>					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="nb">println</span><span class="p">(</span><span class="s">&#34;  dead stkobj at&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">off</span><span class="p">)),</span> <span class="s">&#34;of type&#34;</span><span class="p">,</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">typ</span><span class="p">.</span><span class="nb">string</span><span class="p">())</span>
				<span class="c1">// Note: not necessarily really dead - only reachable-from-ptr dead.
</span><span class="c1"></span>			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">nobj</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">putempty</span><span class="p">((</span><span class="o">*</span><span class="nx">workbuf</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">state</span><span class="p">.</span><span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">state</span><span class="p">.</span><span class="nx">freeBuf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;remaining pointer buffers&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscanvalid</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><h4 id="scanblock">scanblock<a href="#scanblock" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>扫描函数，和scanobject不同的是bitmap需要手动传入</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">scanblock</span><span class="p">(</span><span class="nx">b0</span><span class="p">,</span> <span class="nx">n0</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">ptrmask</span> <span class="o">*</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">stk</span> <span class="o">*</span><span class="nx">stackScanState</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Use local copies of original parameters, so that a stack trace
</span><span class="c1"></span>	<span class="c1">// due to one of the throws below shows the original block
</span><span class="c1"></span>	<span class="c1">// base and extent.
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">b0</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">n0</span>

	<span class="c1">// 枚举扫描的地址
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="p">{</span>
		<span class="c1">// 找到bitmap对应的byte
</span><span class="c1"></span>		<span class="nx">bits</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="o">*</span><span class="nf">addb</span><span class="p">(</span><span class="nx">ptrmask</span><span class="p">,</span> <span class="nx">i</span><span class="o">/</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span><span class="p">)))</span>
		<span class="k">if</span> <span class="nx">bits</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">i</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">*</span> <span class="mi">8</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 枚举byte
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 如果包含指针
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">bits</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// 和scanobject一样，
</span><span class="c1"></span>				<span class="nx">p</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span> <span class="o">+</span> <span class="nx">i</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="c1">// 找到这个对象的span和bitmap
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span> <span class="nx">obj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
						<span class="c1">// 标记该对象存活，并加入标记队列，并且变为会死
</span><span class="c1"></span>						<span class="nf">greyobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nx">objIndex</span><span class="p">)</span>
					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">stk</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span> <span class="o">&gt;=</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span> <span class="p">&lt;</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">{</span>
						<span class="c1">// stk.obj
</span><span class="c1"></span>						<span class="nx">stk</span><span class="p">.</span><span class="nf">putPtr</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="c1">// 指向下一位
</span><span class="c1"></span>			<span class="nx">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
			<span class="c1">// 指向下个指针
</span><span class="c1"></span>			<span class="nx">i</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="greyobject">greyobject<a href="#greyobject" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>标记一个对象存活，并将其放入到灰色标记队列</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">greyobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">off</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">span</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// obj should be start of allocation, and so must be at least pointer-aligned.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">obj</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;greyobject: obj not pointer-aligned&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mbits</span> <span class="o">:=</span> <span class="nx">span</span><span class="p">.</span><span class="nf">markBitsForIndex</span><span class="p">(</span><span class="nx">objIndex</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">useCheckmark</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">printlock</span><span class="p">()</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime:greyobject: checkmarks finds unexpected unmarked object obj=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: found obj at *(&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">base</span><span class="p">),</span> <span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">off</span><span class="p">),</span> <span class="s">&#34;)\n&#34;</span><span class="p">)</span>

			<span class="c1">// Dump the source (base) object
</span><span class="c1"></span>			<span class="nf">gcDumpObject</span><span class="p">(</span><span class="s">&#34;base&#34;</span><span class="p">,</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">off</span><span class="p">)</span>

			<span class="c1">// Dump the object
</span><span class="c1"></span>			<span class="nf">gcDumpObject</span><span class="p">(</span><span class="s">&#34;obj&#34;</span><span class="p">,</span> <span class="nx">obj</span><span class="p">,</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

			<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkmark found unmarked object&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">hbits</span> <span class="o">:=</span> <span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">hbits</span><span class="p">.</span><span class="nf">isCheckmarked</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">hbits</span><span class="p">.</span><span class="nf">setCheckmarked</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">hbits</span><span class="p">.</span><span class="nf">isCheckmarked</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;setCheckmarked and isCheckmarked disagree&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gccheckmark</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">span</span><span class="p">.</span><span class="nf">isFree</span><span class="p">(</span><span class="nx">objIndex</span><span class="p">)</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: marking free object &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span> <span class="s">&#34; found at *(&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">base</span><span class="p">),</span> <span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">off</span><span class="p">),</span> <span class="s">&#34;)\n&#34;</span><span class="p">)</span>
			<span class="nf">gcDumpObject</span><span class="p">(</span><span class="s">&#34;base&#34;</span><span class="p">,</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">off</span><span class="p">)</span>
			<span class="nf">gcDumpObject</span><span class="p">(</span><span class="s">&#34;obj&#34;</span><span class="p">,</span> <span class="nx">obj</span><span class="p">,</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
			<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;marking free object&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// If marked we have nothing to do.
</span><span class="c1"></span>		<span class="c1">// 如果对象所在span的gcMarkBits对应的bit位已经标记为1，则返回
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 设置gcMarkBits对应的bit位为1
</span><span class="c1"></span>		<span class="nx">mbits</span><span class="p">.</span><span class="nf">setMarked</span><span class="p">()</span>

		<span class="c1">// 标记span
</span><span class="c1"></span>		<span class="nx">arena</span><span class="p">,</span> <span class="nx">pageIdx</span><span class="p">,</span> <span class="nx">pageMask</span> <span class="o">:=</span> <span class="nf">pageIndexOf</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">arena</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">pageMask</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arena</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">],</span> <span class="nx">pageMask</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// If this is a noscan object, fast-track it to black
</span><span class="c1"></span>		<span class="c1">// instead of greying it.
</span><span class="c1"></span>		<span class="c1">// 如果是个noscan对象，则直接将放入灰色对象标记队列
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">span</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">noscan</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 把对象放入标记队列，如果放入本地队列失败，则将其放入全局队列
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">putFast</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">gcw</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="scanobject">scanobject<a href="#scanobject" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">scanobject</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Find the bits for b and the size of the object at b.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// b is either the beginning of an object, in which case this
</span><span class="c1"></span>	<span class="c1">// is the size of the object to scan, or it points to an
</span><span class="c1"></span>	<span class="c1">// oblet, in which case we compute the size to scan below.
</span><span class="c1"></span>	<span class="c1">// 获取对象的bitmap
</span><span class="c1"></span>	<span class="nx">hbits</span> <span class="o">:=</span> <span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="c1">// 获取对象的span
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nf">spanOfUnchecked</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="c1">// 获取对象的大小
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;scanobject n == 0&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 对象大于128KB需要切割扫描
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">maxObletBytes</span> <span class="p">{</span>
		<span class="c1">// Large object. Break into oblets for better
</span><span class="c1"></span>		<span class="c1">// parallelism and lower latency.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// It&#39;s possible this is a noscan object (not
</span><span class="c1"></span>			<span class="c1">// from greyobject, but from other code
</span><span class="c1"></span>			<span class="c1">// paths), in which case we must *not* enqueue
</span><span class="c1"></span>			<span class="c1">// oblets since their bitmaps will be
</span><span class="c1"></span>			<span class="c1">// uninitialized.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">noscan</span><span class="p">()</span> <span class="p">{</span>
				<span class="c1">// Bypass the whole scan.
</span><span class="c1"></span>				<span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="c1">// Enqueue the other oblets to scan later.
</span><span class="c1"></span>			<span class="c1">// Some oblets may be in b&#39;s scalar tail, but
</span><span class="c1"></span>			<span class="c1">// these will be marked as &#34;no more pointers&#34;,
</span><span class="c1"></span>			<span class="c1">// so we&#39;ll drop out immediately when we go to
</span><span class="c1"></span>			<span class="c1">// scan those.
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">oblet</span> <span class="o">:=</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">maxObletBytes</span><span class="p">;</span> <span class="nx">oblet</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">+</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">;</span> <span class="nx">oblet</span> <span class="o">+=</span> <span class="nx">maxObletBytes</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">putFast</span><span class="p">(</span><span class="nx">oblet</span><span class="p">)</span> <span class="p">{</span>
					<span class="nx">gcw</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="nx">oblet</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Compute the size of the oblet. Since this object
</span><span class="c1"></span>		<span class="c1">// must be a large object, s.base() is the beginning
</span><span class="c1"></span>		<span class="c1">// of the object.
</span><span class="c1"></span>		<span class="nx">n</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">-</span> <span class="nx">b</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">maxObletBytes</span> <span class="p">{</span>
			<span class="nx">n</span> <span class="p">=</span> <span class="nx">maxObletBytes</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 扫描对象的指针
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">i</span> <span class="kt">uintptr</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="p">{</span>
		<span class="c1">// Find bits for this word.
</span><span class="c1"></span>		<span class="c1">// 获取对应的bit
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Avoid needless hbits.next() on last iteration.
</span><span class="c1"></span>			<span class="nx">hbits</span> <span class="p">=</span> <span class="nx">hbits</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// Load bits once. See CL 22712 and issue 16973 for discussion.
</span><span class="c1"></span>		<span class="nx">bits</span> <span class="o">:=</span> <span class="nx">hbits</span><span class="p">.</span><span class="nf">bits</span><span class="p">()</span>
		<span class="c1">// During checkmarking, 1-word objects store the checkmark
</span><span class="c1"></span>		<span class="c1">// in the type bit for the one word. The only one-word objects
</span><span class="c1"></span>		<span class="c1">// are pointers, or else they&#39;d be merged with other non-pointer
</span><span class="c1"></span>		<span class="c1">// data into larger allocations.
</span><span class="c1"></span>		<span class="c1">// 检查scan bit判断是否扫描
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">&amp;&amp;</span> <span class="nx">bits</span><span class="o">&amp;</span><span class="nx">bitScan</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">break</span> <span class="c1">// no more pointers in this object
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="c1">// 不是指针则跳过
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">bits</span><span class="o">&amp;</span><span class="nx">bitPointer</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">continue</span> <span class="c1">// not a pointer
</span><span class="c1"></span>		<span class="p">}</span>

		<span class="c1">// 取值
</span><span class="c1"></span>		<span class="nx">obj</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span> <span class="o">+</span> <span class="nx">i</span><span class="p">))</span>

		<span class="c1">// At this point we have extracted the next potential pointer.
</span><span class="c1"></span>		<span class="c1">// Quickly filter out nil and pointers back to the current object.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">obj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="o">-</span><span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="c1">// Test if obj points into the Go heap and, if so,
</span><span class="c1"></span>			<span class="c1">// mark the object.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// Note that it&#39;s possible for findObject to
</span><span class="c1"></span>			<span class="c1">// fail if obj points to a just-allocated heap
</span><span class="c1"></span>			<span class="c1">// object because of a race with growing the
</span><span class="c1"></span>			<span class="c1">// heap. In this case, we know the object was
</span><span class="c1"></span>			<span class="c1">// just allocated and hence will be marked by
</span><span class="c1"></span>			<span class="c1">// allocation itself.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span> <span class="nx">obj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">greyobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nx">objIndex</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="gcmarkdone">gcMarkDone<a href="#gcmarkdone" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>调用gcMarkDone进入完成标记阶段
在并行GC中gcMarkDone会被执行两次, 第一次会禁止本地标记队列然后重新开始后台标记任务, 第二次会进入完成标记阶段(mark termination)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkDone</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 加锁确定同一时间只有1个线程在运行
</span><span class="c1"></span>	<span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markDoneSema</span><span class="p">)</span>

<span class="nx">top</span><span class="p">:</span>
	<span class="c1">// Re-check transition condition under transition lock.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// It&#39;s critical that this checks the global work queues are
</span><span class="c1"></span>	<span class="c1">// empty before performing the ragged barrier. Otherwise,
</span><span class="c1"></span>	<span class="c1">// there could be global work that a P could take after the P
</span><span class="c1"></span>	<span class="c1">// has passed the ragged barrier.
</span><span class="c1"></span>	<span class="c1">// 再次检查
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!(</span><span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmark</span> <span class="o">&amp;&amp;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markDoneSema</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// Flush all local buffers and collect flushedWork flags.
</span><span class="c1"></span>	<span class="c1">// 刷新所有本地缓存并收集刷新任务标示
</span><span class="c1"></span>	<span class="nx">gcMarkDoneFlushed</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
		<span class="c1">// Mark the user stack as preemptible so that it may be scanned.
</span><span class="c1"></span>		<span class="c1">// Otherwise, our attempt to force all P&#39;s to a safepoint could
</span><span class="c1"></span>		<span class="c1">// result in a deadlock as we attempt to preempt a worker that&#39;s
</span><span class="c1"></span>		<span class="c1">// trying to preempt us (e.g. for a stack scan).
</span><span class="c1"></span>		<span class="c1">// 标记g为可抢占，以便对其扫描
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
		<span class="nf">forEachP</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Flush the write barrier buffer, since this may add
</span><span class="c1"></span>			<span class="c1">// work to the gcWork.
</span><span class="c1"></span>			<span class="c1">// 刷新写屏障buffer
</span><span class="c1"></span>			<span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="c1">// For debugging, shrink the write barrier
</span><span class="c1"></span>			<span class="c1">// buffer so it flushes immediately.
</span><span class="c1"></span>			<span class="c1">// wbBuf.reset will keep it at this size as
</span><span class="c1"></span>			<span class="c1">// long as throwOnGCWork is set.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
				<span class="nx">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">wbBuf</span>
				<span class="nx">b</span><span class="p">.</span><span class="nx">end</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">wbBufEntryPointers</span><span class="p">]))</span>
				<span class="nx">b</span><span class="p">.</span><span class="nx">debugGen</span> <span class="p">=</span> <span class="nx">gcWorkPauseGen</span>
			<span class="p">}</span>
			<span class="c1">// Flush the gcWork, since this may create global work
</span><span class="c1"></span>			<span class="c1">// and set the flushedWork flag.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// TODO(austin): Break up these workbufs to
</span><span class="c1"></span>			<span class="c1">// better distribute work.
</span><span class="c1"></span>			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">dispose</span><span class="p">()</span>
			<span class="c1">// Collect the flushedWork flag.
</span><span class="c1"></span>			<span class="c1">// 统计flushedWork
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span> <span class="p">{</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcMarkDoneFlushed</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
				<span class="c1">// For debugging, freeze the gcWork
</span><span class="c1"></span>				<span class="c1">// until we know whether we&#39;ve reached
</span><span class="c1"></span>				<span class="c1">// completion or not. If we think
</span><span class="c1"></span>				<span class="c1">// we&#39;ve reached completion, but
</span><span class="c1"></span>				<span class="c1">// there&#39;s a paused gcWork, then
</span><span class="c1"></span>				<span class="c1">// that&#39;s a bug.
</span><span class="c1"></span>				<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseGen</span> <span class="p">=</span> <span class="nx">gcWorkPauseGen</span>
				<span class="c1">// Capture the G&#39;s stack.
</span><span class="c1"></span>				<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseStack</span> <span class="p">{</span>
					<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseStack</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="p">}</span>
				<span class="nf">callers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseStack</span><span class="p">[:])</span>
			<span class="p">}</span>
		<span class="p">})</span>
		<span class="c1">// 重置g的状
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">gcMarkDoneFlushed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
			<span class="c1">// Release paused gcWorks.
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcWorkPauseGen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// More grey objects were discovered since the
</span><span class="c1"></span>		<span class="c1">// previous termination check, so there may be more
</span><span class="c1"></span>		<span class="c1">// work to do. Keep going. It&#39;s possible the
</span><span class="c1"></span>		<span class="c1">// transition condition became true again during the
</span><span class="c1"></span>		<span class="c1">// ragged barrier, so re-check it.
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
		<span class="nx">throwOnGCWork</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="c1">// Release paused gcWorks. If there are any, they
</span><span class="c1"></span>		<span class="c1">// should now observe throwOnGCWork and panic.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcWorkPauseGen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 记录完成标记的时间和开始STW的时间
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">tMarkTerm</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="c1">// 禁止G抢占
</span><span class="c1"></span>	<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;gcing&#34;</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSTWStart</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// STW 
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">stopTheWorldWithSema</span><span class="p">)</span>
	<span class="c1">// The gcphase is _GCmark, it will transition to _GCmarktermination
</span><span class="c1"></span>	<span class="c1">// below. The important thing is that the wb remains active until
</span><span class="c1"></span>	<span class="c1">// all marking is complete. This includes writes made by the GC.
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
		<span class="c1">// For debugging, double check that no work was added after we
</span><span class="c1"></span>		<span class="c1">// went around above and disable write barrier buffering.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
			<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcw</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">printlock</span><span class="p">()</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: P &#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="s">&#34; flushedWork &#34;</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf1</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf1=&lt;nil&gt;&#34;</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf1.n=&#34;</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf1</span><span class="p">.</span><span class="nx">nobj</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf2=&lt;nil&gt;&#34;</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf2.n=&#34;</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf2</span><span class="p">.</span><span class="nx">nobj</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseGen</span> <span class="o">==</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">putGen</span> <span class="p">{</span>
					<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: checkPut already failed at this generation&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;throwOnGCWork&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// For unknown reasons (see issue #27993), there is
</span><span class="c1"></span>		<span class="c1">// sometimes work left over when we enter mark
</span><span class="c1"></span>		<span class="c1">// termination. Detect this and resume concurrent
</span><span class="c1"></span>		<span class="c1">// mark. This is obviously unfortunate.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Switch to the system stack to call wbBufFlush1,
</span><span class="c1"></span>		<span class="c1">// though in this case it doesn&#39;t matter because we&#39;re
</span><span class="c1"></span>		<span class="c1">// non-preemptible anyway.
</span><span class="c1"></span>		<span class="nx">restart</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
				<span class="c1">// 刷新写屏障buffer
</span><span class="c1"></span>				<span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">restart</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">})</span>
		<span class="k">if</span> <span class="nx">restart</span> <span class="p">{</span>
			<span class="c1">// 标记为可抢占
</span><span class="c1"></span>			<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
			<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="c1">// 启动STW
</span><span class="c1"></span>				<span class="nx">now</span> <span class="o">:=</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
				<span class="c1">// 暂停的时间
</span><span class="c1"></span>				<span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="o">+=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span>
			<span class="p">})</span>
			<span class="k">goto</span> <span class="nx">top</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 禁止gc辅助助手和后台任务
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="c1">// 唤醒所有因为辅助GC而休眠的G
</span><span class="c1"></span>	<span class="nf">gcWakeAllAssists</span><span class="p">()</span>

	<span class="c1">// Likewise, release the transition lock. Blocked
</span><span class="c1"></span>	<span class="c1">// workers and assists will run when we start the
</span><span class="c1"></span>	<span class="c1">// world again.
</span><span class="c1"></span>	<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markDoneSema</span><span class="p">)</span>

	<span class="c1">// In STW mode, re-enable user goroutines. These will be
</span><span class="c1"></span>	<span class="c1">// queued to run after we start the world.
</span><span class="c1"></span>	<span class="nf">schedEnableUser</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>

	<span class="c1">// 计算下一次GC需要的heap大小
</span><span class="c1"></span>	<span class="nx">nextTriggerRatio</span> <span class="o">:=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">endCycle</span><span class="p">()</span>

	<span class="c1">// 完成标记界面，会重新Start the world
</span><span class="c1"></span>	<span class="nf">gcMarkTermination</span><span class="p">(</span><span class="nx">nextTriggerRatio</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="gcmarktermination">gcMarkTermination<a href="#gcmarktermination" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>进入标记完成阶段</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkTermination</span><span class="p">(</span><span class="nx">nextTriggerRatio</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 世界停止了....
</span><span class="c1"></span>
	<span class="c1">// 禁止辅助GC和后台标记任务运行
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="c1">// 进入GC完成标记阶段，开启写屏障
</span><span class="c1"></span>	<span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCmarktermination</span><span class="p">)</span>

	<span class="nx">work</span><span class="p">.</span><span class="nx">heap1</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span>
	<span class="c1">// 记录开始时间
</span><span class="c1"></span>	<span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>

	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="c1">// 禁止抢占
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;gcing&#34;</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
	<span class="c1">// 设置Gwaiting状态
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">waitReasonGarbageCollection</span>

	<span class="c1">// 切换到g0
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 开始标记
</span><span class="c1"></span>		<span class="nf">gcMark</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>
		<span class="c1">// 必须直接返回，因为外面的栈有可能被移动，所以我们不能直接访问外面的变量
</span><span class="c1"></span>	<span class="p">})</span>

	<span class="c1">// 重新切换到g0执行
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">work</span><span class="p">.</span><span class="nx">heap2</span> <span class="p">=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">bytesMarked</span>
		<span class="c1">// 如果启动了checkmark，检查所有的对象是否都有标记
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gccheckmark</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Run a full non-parallel, stop-the-world
</span><span class="c1"></span>			<span class="c1">// mark using checkmark bits, to check that we
</span><span class="c1"></span>			<span class="c1">// didn&#39;t forget to mark anything during the
</span><span class="c1"></span>			<span class="c1">// concurrent mark process.
</span><span class="c1"></span>			<span class="nf">gcResetMarkState</span><span class="p">()</span>
			<span class="nf">initCheckmarks</span><span class="p">()</span>
			<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">gcw</span>
			<span class="nf">gcDrain</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nf">dispose</span><span class="p">()</span>
			<span class="nf">clearCheckmarks</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="c1">// 更新GC状态为关闭，关闭写屏障
</span><span class="c1"></span>		<span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCoff</span><span class="p">)</span>
		<span class="c1">// 唤醒后台庆松任务
</span><span class="c1"></span>		<span class="nf">gcSweep</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">mode</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 将g状态修改为运行中
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCDone</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// 运行g抢占
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>

	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gc done but gcphase != _GCoff&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 更新下一轮的gc trigger
</span><span class="c1"></span>	<span class="nf">gcSetTriggerRatio</span><span class="p">(</span><span class="nx">nextTriggerRatio</span><span class="p">)</span>

	<span class="c1">// 更新时间统计
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="nx">sec</span><span class="p">,</span> <span class="nx">nsec</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">time_now</span><span class="p">()</span>
	<span class="nx">unixNow</span> <span class="o">:=</span> <span class="nx">sec</span><span class="o">*</span><span class="mf">1e9</span> <span class="o">+</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">nsec</span><span class="p">)</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="o">+=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">tEnd</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">last_gc_unix</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">unixNow</span><span class="p">))</span> <span class="c1">// must be Unix time to make sense to user
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">last_gc_nanotime</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span> <span class="c1">// monotonic time for us
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_ns</span><span class="p">[</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_ns</span><span class="p">))]</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_end</span><span class="p">[</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_end</span><span class="p">))]</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">unixNow</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_total_ns</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span><span class="p">)</span>

	<span class="c1">// 更新任务总时间
</span><span class="c1"></span>	<span class="nx">sweepTermCpu</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">tMark</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span><span class="p">)</span>
	<span class="c1">// We report idle marking time below, but omit it from the
</span><span class="c1"></span>	<span class="c1">// overall utilization here since it&#39;s &#34;free&#34;.
</span><span class="c1"></span>	<span class="nx">markCpu</span> <span class="o">:=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistTime</span> <span class="o">+</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span> <span class="o">+</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">fractionalMarkTime</span>
	<span class="nx">markTermCpu</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">tEnd</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tMarkTerm</span><span class="p">)</span>
	<span class="nx">cycleCpu</span> <span class="o">:=</span> <span class="nx">sweepTermCpu</span> <span class="o">+</span> <span class="nx">markCpu</span> <span class="o">+</span> <span class="nx">markTermCpu</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">totaltime</span> <span class="o">+=</span> <span class="nx">cycleCpu</span>

	<span class="c1">// 计算总的GC CPU利用率
</span><span class="c1"></span>	<span class="nx">totalCpu</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">totaltime</span> <span class="o">+</span> <span class="p">(</span><span class="nx">now</span><span class="o">-</span><span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span><span class="p">)</span><span class="o">*</span><span class="nb">int64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_cpu_fraction</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">totaltime</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">totalCpu</span><span class="p">)</span>

	<span class="c1">// 重置清扫状态
</span><span class="c1"></span>	<span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">sweep</span><span class="p">.</span><span class="nx">npausesweep</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">userForced</span> <span class="p">{</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">numforcedgc</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="c1">// 统计GC执行的次数和唤醒等待清扫的G
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="o">++</span>
	<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">list</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Finish the current heap profiling cycle and start a new
</span><span class="c1"></span>	<span class="c1">// heap profiling cycle. We do this before starting the world
</span><span class="c1"></span>	<span class="c1">// so events don&#39;t leak into the wrong cycle.
</span><span class="c1"></span>	<span class="c1">// 性能统计
</span><span class="c1"></span>	<span class="nf">mProf_NextCycle</span><span class="p">()</span>

	<span class="c1">// START THE WORLD
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">})</span>

	<span class="c1">// Flush the heap profile so we can start a new cycle next GC.
</span><span class="c1"></span>	<span class="c1">// This is relatively expensive, so we don&#39;t do it with the
</span><span class="c1"></span>	<span class="c1">// world stopped.
</span><span class="c1"></span>	<span class="c1">// 性能统计
</span><span class="c1"></span>	<span class="nf">mProf_Flush</span><span class="p">()</span>

	<span class="c1">// Prepare workbufs for freeing by the sweeper. We do this
</span><span class="c1"></span>	<span class="c1">// asynchronously because it can take non-trivial time.
</span><span class="c1"></span>	<span class="c1">// 移动
</span><span class="c1"></span>	<span class="nf">prepareFreeWorkbufs</span><span class="p">()</span>

	<span class="c1">// 释放空闲的spans
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">freeStackSpans</span><span class="p">)</span>

	<span class="c1">// Ensure all mcaches are flushed. Each P will flush its own
</span><span class="c1"></span>	<span class="c1">// mcache before allocating, but idle Ps may not. Since this
</span><span class="c1"></span>	<span class="c1">// is necessary to sweep all spans, we need to ensure all
</span><span class="c1"></span>	<span class="c1">// mcaches are flushed before we start the next GC cycle.
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">forEachP</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
		<span class="p">})</span>
	<span class="p">})</span>

	<span class="c1">// Print gctrace before dropping worldsema. As soon as we drop
</span><span class="c1"></span>	<span class="c1">// worldsema another cycle could start and smash the stats
</span><span class="c1"></span>	<span class="c1">// we&#39;re trying to print.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gctrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">util</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_cpu_fraction</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

		<span class="kd">var</span> <span class="nx">sbuf</span> <span class="p">[</span><span class="mi">24</span><span class="p">]</span><span class="kt">byte</span>
		<span class="nf">printlock</span><span class="p">()</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;gc &#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="p">,</span>
			<span class="s">&#34; @&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nf">itoaDiv</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span><span class="o">-</span><span class="nx">runtimeInitTime</span><span class="p">)</span><span class="o">/</span><span class="mf">1e6</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="s">&#34;s &#34;</span><span class="p">,</span>
			<span class="nx">util</span><span class="p">,</span> <span class="s">&#34;%: &#34;</span><span class="p">)</span>
		<span class="nx">prev</span> <span class="o">:=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span>
		<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ns</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">int64</span><span class="p">{</span><span class="nx">work</span><span class="p">.</span><span class="nx">tMark</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tMarkTerm</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tEnd</span><span class="p">}</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;+&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">fmtNSAsMS</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">ns</span><span class="o">-</span><span class="nx">prev</span><span class="p">))))</span>
			<span class="nx">prev</span> <span class="p">=</span> <span class="nx">ns</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34; ms clock, &#34;</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ns</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">int64</span><span class="p">{</span><span class="nx">sweepTermCpu</span><span class="p">,</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistTime</span><span class="p">,</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span> <span class="o">+</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">fractionalMarkTime</span><span class="p">,</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">idleMarkTime</span><span class="p">,</span> <span class="nx">markTermCpu</span><span class="p">}</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
				<span class="c1">// Separate mark time components with /.
</span><span class="c1"></span>				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;+&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">fmtNSAsMS</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">ns</span><span class="p">))))</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34; ms cpu, &#34;</span><span class="p">,</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">heap0</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;-&gt;&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">heap1</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;-&gt;&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">heap2</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34; MB, &#34;</span><span class="p">,</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">heapGoal</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34; MB goal, &#34;</span><span class="p">,</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">maxprocs</span><span class="p">,</span> <span class="s">&#34; P&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">userForced</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34; (forced)&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">printunlock</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>
	<span class="c1">// Careful: another GC cycle may start now.
</span><span class="c1"></span>
	<span class="c1">// 允许g可以被抢占
</span><span class="c1"></span>	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nx">mp</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// now that gc is done, kick off finalizer thread if needed
</span><span class="c1"></span>	<span class="c1">// gc已完成
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">concurrentSweep</span> <span class="p">{</span>
		<span class="c1">// give the queued finalizers, if any, a chance to run
</span><span class="c1"></span>		<span class="c1">// 非并行GC，让M开始调度
</span><span class="c1"></span>		<span class="nf">Gosched</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="gcsweep">gcSweep<a href="#gcsweep" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>唤醒后台清扫任务</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcSweep</span><span class="p">(</span><span class="nx">mode</span> <span class="nx">gcMode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcSweep being done but phase is not GCoff&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 增加sweepgen，sweepSpan两个队列角色会交换，所有的span会变成待清扫
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">+=</span> <span class="mi">2</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nx">index</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// We should have drained this list during the last
</span><span class="c1"></span>		<span class="c1">// sweep phase. We certainly need to start this phase
</span><span class="c1"></span>		<span class="c1">// with an empty swept list.
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;non-empty swept list&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSwept</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepArenas</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">allArenas</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimIndex</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimCredit</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 非并行GC或者是强制模式(runtime.GC)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">_ConcurrentSweep</span> <span class="o">||</span> <span class="nx">mode</span> <span class="o">==</span> <span class="nx">gcForceBlockMode</span> <span class="p">{</span>
		<span class="c1">// Special case synchronous sweep.
</span><span class="c1"></span>		<span class="c1">// Record that no proportional sweeping has to happen.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepPagesPerByte</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="c1">// Sweep all spans eagerly.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">sweep</span><span class="p">.</span><span class="nx">npausesweep</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="c1">// Free workbufs eagerly.
</span><span class="c1"></span>		<span class="nf">prepareFreeWorkbufs</span><span class="p">()</span>
		<span class="k">for</span> <span class="nf">freeSomeWbufs</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">}</span>
		<span class="c1">// All &#34;free&#34; events for this mark/sweep cycle have
</span><span class="c1"></span>		<span class="c1">// now happened, so we can make this profile cycle
</span><span class="c1"></span>		<span class="c1">// available immediately.
</span><span class="c1"></span>		<span class="nf">mProf_NextCycle</span><span class="p">()</span>
		<span class="nf">mProf_Flush</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 后台清扫
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">{</span>
		<span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="nf">ready</span><span class="p">(</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h4 id="bgsweep">bgsweep<a href="#bgsweep" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">bgsweep</span><span class="p">(</span><span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sweep</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// 等待唤醒
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>
	<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonGCSweepWait</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 循环清扫
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// sweepone清扫heap上的数据，如果返回page number ==^uintptr(0)表示清理完成
</span><span class="c1"></span>		<span class="k">for</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span><span class="o">++</span>
			<span class="nf">Gosched</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// 释放一些未标记队列buf到heap，返回true则需要再释放一些
</span><span class="c1"></span>		<span class="k">for</span> <span class="nf">freeSomeWbufs</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">Gosched</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="c1">// 是否清扫完成，未完成则继续循环， sweepdone != 0
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">isSweepDone</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// This can happen if a GC runs between
</span><span class="c1"></span>			<span class="c1">// gosweepone returning ^0 above
</span><span class="c1"></span>			<span class="c1">// and the lock being acquired.
</span><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 让清扫任务进入休眠
</span><span class="c1"></span>		<span class="c1">// goparkunlock 会将goroutine变为等待状态，并且解锁，等待goready唤醒
</span><span class="c1"></span>		<span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonGCSweepWait</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="sweepone">sweepone<a href="#sweepone" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">sweepRatio</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepPagesPerByte</span> <span class="c1">// For debugging
</span><span class="c1"></span>
	<span class="c1">// 禁止抢占
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
		<span class="k">return</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 同时执行sweep任务数量
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepers</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// 找出一个需要清扫的span
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="nx">sg</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">pop</span><span class="p">()</span>
		<span class="c1">// 没有需要清扫的span，退出
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// span没在使用，换而言之其他M正在清扫这个span
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanInUse</span> <span class="p">{</span>
			<span class="c1">// This can happen if direct sweeping already
</span><span class="c1"></span>			<span class="c1">// swept this span, but in that case the sweep
</span><span class="c1"></span>			<span class="c1">// generation should always be up-to-date.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!(</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: bad span s.state=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="s">&#34; s.sweepgen=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34; sweepgen=&#34;</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;non in-use span in unswept list&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 增加span的sweepgen，如果增加失败，表示有其他M已经操作了，直接退出
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 清扫sapn
</span><span class="c1"></span>	<span class="nx">npages</span> <span class="o">:=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">npages</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Whole span was freed. Count it toward the
</span><span class="c1"></span>			<span class="c1">// page reclaimer credit since these pages can
</span><span class="c1"></span>			<span class="c1">// now be used for span allocation.
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimCredit</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// Span is still in-use, so this returned no
</span><span class="c1"></span>			<span class="c1">// pages to the heap and the span needs to
</span><span class="c1"></span>			<span class="c1">// move to the swept in-use list.
</span><span class="c1"></span>			<span class="nx">npages</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 更新sweepers
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcpacertrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;pacer: sweep done at heap size &#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;MB; allocated &#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="o">-</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepHeapLiveBasis</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;MB during sweep; swept &#34;</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSwept</span><span class="p">,</span> <span class="s">&#34; pages at &#34;</span><span class="p">,</span> <span class="nx">sweepRatio</span><span class="p">,</span> <span class="s">&#34; pages/byte\n&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="k">return</span> <span class="nx">npages</span>
<span class="p">}</span>
</code></pre></div><h4 id="sweep">sweep<a href="#sweep" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>清扫单个span</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="nf">sweep</span><span class="p">(</span><span class="nx">preserve</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// It&#39;s critical that we enter this function with preemption disabled,
</span><span class="c1"></span>	<span class="c1">// GC must not start while we are in the middle of this function.
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mspan.sweep: m is not locked&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">sweepgen</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanInUse</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">!=</span> <span class="nx">sweepgen</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;mspan.sweep: state=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="s">&#34; sweepgen=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34; mheap.sweepgen=&#34;</span><span class="p">,</span> <span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mspan.sweep: bad span state&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSweepSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">*</span> <span class="nx">_PageSize</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 计数++
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSwept</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">))</span>

	<span class="nx">spc</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="kc">false</span>

	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span>
	<span class="nx">freeToHeap</span> <span class="o">:=</span> <span class="kc">false</span>

	<span class="c1">// The allocBits indicate which unmarked objects don&#39;t need to be
</span><span class="c1"></span>	<span class="c1">// processed since they were free at the end of the last GC cycle
</span><span class="c1"></span>	<span class="c1">// and were not allocated since then.
</span><span class="c1"></span>	<span class="c1">// If the allocBits index is &gt;= s.freeindex and the bit
</span><span class="c1"></span>	<span class="c1">// is not marked then the object remains unallocated
</span><span class="c1"></span>	<span class="c1">// since the last GC.
</span><span class="c1"></span>	<span class="c1">// This situation is analogous to being on a freelist.
</span><span class="c1"></span>
	<span class="c1">// Unlink &amp; free special records for any objects we&#39;re about to free.
</span><span class="c1"></span>	<span class="c1">// Two complications here:
</span><span class="c1"></span>	<span class="c1">// 1. An object can have both finalizer and profile special records.
</span><span class="c1"></span>	<span class="c1">//    In such case we need to queue finalizer for execution,
</span><span class="c1"></span>	<span class="c1">//    mark the object as live and preserve the profile special.
</span><span class="c1"></span>	<span class="c1">// 2. A tiny object can have several finalizers setup for different offsets.
</span><span class="c1"></span>	<span class="c1">//    If such object is not marked, we need to queue all finalizers at once.
</span><span class="c1"></span>	<span class="c1">// Both 1 and 2 are possible at the same time.
</span><span class="c1"></span>	<span class="nx">specialp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">specials</span>
	<span class="nx">special</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">specialp</span>
	<span class="k">for</span> <span class="nx">special</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// A finalizer can be set for an inner byte of an object, find object beginning.
</span><span class="c1"></span>		<span class="nx">objIndex</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">special</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">/</span> <span class="nx">size</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">objIndex</span><span class="o">*</span><span class="nx">size</span>
		<span class="nx">mbits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">markBitsForIndex</span><span class="p">(</span><span class="nx">objIndex</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// This object is not marked and has at least one special record.
</span><span class="c1"></span>			<span class="c1">// Pass 1: see if it has at least one finalizer.
</span><span class="c1"></span>			<span class="nx">hasFin</span> <span class="o">:=</span> <span class="kc">false</span>
			<span class="nx">endOffset</span> <span class="o">:=</span> <span class="nx">p</span> <span class="o">-</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">size</span>
			<span class="k">for</span> <span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">special</span><span class="p">;</span> <span class="nx">tmp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">tmp</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">endOffset</span><span class="p">;</span> <span class="nx">tmp</span> <span class="p">=</span> <span class="nx">tmp</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">tmp</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">_KindSpecialFinalizer</span> <span class="p">{</span>
					<span class="c1">// Stop freeing of object if it has a finalizer.
</span><span class="c1"></span>					<span class="nx">mbits</span><span class="p">.</span><span class="nf">setMarkedNonAtomic</span><span class="p">()</span>
					<span class="nx">hasFin</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="c1">// Pass 2: queue all finalizers _or_ handle profile record.
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">special</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">special</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">endOffset</span> <span class="p">{</span>
				<span class="c1">// Find the exact byte for which the special was setup
</span><span class="c1"></span>				<span class="c1">// (as opposed to object beginning).
</span><span class="c1"></span>				<span class="nx">p</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">special</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">special</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">_KindSpecialFinalizer</span> <span class="o">||</span> <span class="p">!</span><span class="nx">hasFin</span> <span class="p">{</span>
					<span class="c1">// Splice out special record.
</span><span class="c1"></span>					<span class="nx">y</span> <span class="o">:=</span> <span class="nx">special</span>
					<span class="nx">special</span> <span class="p">=</span> <span class="nx">special</span><span class="p">.</span><span class="nx">next</span>
					<span class="o">*</span><span class="nx">specialp</span> <span class="p">=</span> <span class="nx">special</span>
					<span class="nf">freespecial</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="c1">// This is profile record, but the object has finalizers (so kept alive).
</span><span class="c1"></span>					<span class="c1">// Keep special record.
</span><span class="c1"></span>					<span class="nx">specialp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">special</span><span class="p">.</span><span class="nx">next</span>
					<span class="nx">special</span> <span class="p">=</span> <span class="o">*</span><span class="nx">specialp</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// object is still live: keep special record
</span><span class="c1"></span>			<span class="nx">specialp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">special</span><span class="p">.</span><span class="nx">next</span>
			<span class="nx">special</span> <span class="p">=</span> <span class="o">*</span><span class="nx">specialp</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">allocfreetrace</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">clobberfree</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">raceenabled</span> <span class="o">||</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="c1">// Find all newly freed objects. This doesn&#39;t have to
</span><span class="c1"></span>		<span class="c1">// efficient; allocfreetrace has massive overhead.
</span><span class="c1"></span>		<span class="nx">mbits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">markBitsForBase</span><span class="p">()</span>
		<span class="nx">abits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">allocBitsForIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">abits</span><span class="p">.</span><span class="nx">index</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">||</span> <span class="nx">abits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">())</span> <span class="p">{</span>
				<span class="nx">x</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">i</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
				<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">allocfreetrace</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nf">tracefree</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">clobberfree</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nf">clobberfree</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
					<span class="nf">racefree</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
					<span class="nf">msanfree</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">mbits</span><span class="p">.</span><span class="nf">advance</span><span class="p">()</span>
			<span class="nx">abits</span><span class="p">.</span><span class="nf">advance</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 计算这个span上要释放的对象数量
</span><span class="c1"></span>	<span class="nx">nalloc</span> <span class="o">:=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">countAlloc</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nalloc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 如果span sizeclass=0，代表大对象，需要释放到heap
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">freeToHeap</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nx">nfreed</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="o">-</span> <span class="nx">nalloc</span>
	<span class="k">if</span> <span class="nx">nalloc</span> <span class="p">&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">,</span> <span class="s">&#34; nalloc=&#34;</span><span class="p">,</span> <span class="nx">nalloc</span><span class="p">,</span> <span class="s">&#34; previous allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34; nfreed=&#34;</span><span class="p">,</span> <span class="nx">nfreed</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sweep increased allocation count&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="nx">nalloc</span>
	<span class="nx">wasempty</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span>
	<span class="c1">// 重置freeindex
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// reset allocation index to start of span.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">traceReclaimed</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">nfreed</span><span class="p">)</span> <span class="o">*</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="p">}</span>

	<span class="c1">// 将gcmarkBits变为allocBits
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">allocBits</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ggcmarkBitscmarkBits</span>
	<span class="c1">// 重新分配
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">gcmarkBits</span> <span class="p">=</span> <span class="nf">newMarkBits</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>

	<span class="c1">// 初始化allocBits
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="c1">// 如果需要释放到heap或者span无存活对象则更新sweepgen
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">freeToHeap</span> <span class="o">||</span> <span class="nx">nfreed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// The span must be in our exclusive ownership until we update sweepgen,
</span><span class="c1"></span>		<span class="c1">// check for potential races.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanInUse</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">!=</span> <span class="nx">sweepgen</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;mspan.sweep: state=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="s">&#34; sweepgen=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34; mheap.sweepgen=&#34;</span><span class="p">,</span> <span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mspan.sweep: bad span state after sweep&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// Serialization point.
</span><span class="c1"></span>		<span class="c1">// At this point the mark bits are cleared and allocation ready
</span><span class="c1"></span>		<span class="c1">// to go so release the span.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sweepgen</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">nfreed</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 将span返回mcentral，res表示是否成功
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">local_nsmallfree</span><span class="p">[</span><span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()]</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">nfreed</span><span class="p">)</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">preserve</span><span class="p">,</span> <span class="nx">wasempty</span><span class="p">)</span>
		<span class="c1">// mcentral.freeSpan updates sweepgen
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">freeToHeap</span> <span class="p">{</span>
		<span class="c1">// 释放大块span到heap
</span><span class="c1"></span>		<span class="c1">// Free large span to heap
</span><span class="c1"></span>
		<span class="c1">// NOTE(rsc,dvyukov): The original implementation of efence
</span><span class="c1"></span>		<span class="c1">// in CL 22060046 used sysFree instead of sysFault, so that
</span><span class="c1"></span>		<span class="c1">// the operating system would eventually give the memory
</span><span class="c1"></span>		<span class="c1">// back to us again, so that an efence program could run
</span><span class="c1"></span>		<span class="c1">// longer without running out of memory. Unfortunately,
</span><span class="c1"></span>		<span class="c1">// calling sysFree here without any kind of adjustment of the
</span><span class="c1"></span>		<span class="c1">// heap data structures means that when the memory does
</span><span class="c1"></span>		<span class="c1">// come back to us, we have the wrong metadata for it, either in
</span><span class="c1"></span>		<span class="c1">// the mspan structures or in the garbage collection bitmap.
</span><span class="c1"></span>		<span class="c1">// Using sysFault here means that the program will run out of
</span><span class="c1"></span>		<span class="c1">// memory fairly quickly in efence mode, but at least it won&#39;t
</span><span class="c1"></span>		<span class="c1">// have mysterious crashes due to confused memory reuse.
</span><span class="c1"></span>		<span class="c1">// It should be possible to switch back to sysFree if we also
</span><span class="c1"></span>		<span class="c1">// implement and then call some kind of mheap.deleteSpan.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">efence</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// prevent mlookup from finding this span
</span><span class="c1"></span>			<span class="nf">sysFault</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()),</span> <span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_nlargefree</span><span class="o">++</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_largefree</span> <span class="o">+=</span> <span class="nx">size</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">res</span> <span class="p">{</span>
		<span class="c1">// The span has been swept and is still in-use, so put
</span><span class="c1"></span>		<span class="c1">// it on the swept in-use list.
</span><span class="c1"></span>		<span class="c1">// span已经清扫过但是还是使用则放到swept in-use队列
</span><span class="c1"></span>		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></div><h3 id="参考">参考<a href="#参考" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><a href="https://www.cnblogs.com/zkweb/p/7880099.html">https://www.cnblogs.com/zkweb/p/7880099.html</a></p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg></p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2021-06-27 09:20 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://leonzyang.github.io/posts/gobuild/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;</span><br><span>Go-深入理解go程序运行和编译</span>
			</a>
			<a class="prev-post" href="https://leonzyang.github.io/posts/defer/">
				<span class="post-nav-label">&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Go-深入理解Defer</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2021 <a href="https://leonzyang.github.io">LeonZhao</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://leonzyang.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://leonzyang.github.io/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js" integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin="anonymous"></script>
	

</body>

</html>
