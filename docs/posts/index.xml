<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on LeonZhao的小木屋</title>
		<link>https://leonzyang.github.io/posts/</link>
		<description>Recent content in Posts on LeonZhao的小木屋</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh-cn</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sun, 27 Jun 2021 09:58:40 +0800</lastBuildDate>
		<atom:link href="https://leonzyang.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Python-生成器</title>
			<link>https://leonzyang.github.io/posts/py-generator/</link>
			<pubDate>Sun, 27 Jun 2021 09:58:40 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/py-generator/</guid>
			<description>深入理解生成器 生成器是一种特殊的迭代器，当每次调用yield，函数就会暂停。生成器的好处就是节省内存空间。生成器有两种类型：生成器函数和生成器表达式
生成器表达式 将列表推导式[]改成()就行
gen=(i for i in range(10)) gen # &amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x104d21960&amp;gt; isinstance(gen, types.GeneratorType) # True isinstance(gen, collections.Iterator) # True isinstance(gen, collections.Iterable) # True 生成器函数yield def func(): yield 1 yield 2 yield 3 f = func() print(next(f)) # 1 print(next(f)) # 2 print(next(f)) # 3 next 通过next(next其实也是调用__next__)可以进行迭代使用，当达到最后一个元素之后，就会抛出StopIteration
send 通过send我们可以想生成器函数发送数据，第一次发送必须是next之后，否则会报错，当然我们可以先调用send(None), 等价于next
send可以向生成器传值的同时会让生成器前进到下一个yield语句，并将yield右侧的值作为返回值
def func(): x = yield 1 r = yield x print(r) f = func() f.send(None) print(f.</description>
			<content type="html"><![CDATA[<h2 id="深入理解生成器">深入理解生成器</h2>
<p>生成器是一种特殊的迭代器，当每次调用yield，函数就会暂停。生成器的好处就是节省内存空间。生成器有两种类型：生成器函数和生成器表达式</p>
<h3 id="生成器表达式">生成器表达式</h3>
<p>将列表推导式[]改成()就行</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">gen</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">gen</span>  <span class="c1"># &lt;generator object &lt;genexpr&gt; at 0x104d21960&gt;</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">)</span>   <span class="c1"># True</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterator</span><span class="p">)</span>  <span class="c1"># True</span>
<span class="nb">isinstance</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">)</span>  <span class="c1"># True</span>
</code></pre></div><h3 id="生成器函数yield">生成器函数yield</h3>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="k">yield</span> <span class="mi">1</span>
    <span class="k">yield</span> <span class="mi">2</span>
    <span class="k">yield</span> <span class="mi">3</span>


<span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>  <span class="c1"># 1</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>  <span class="c1"># 2</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>  <span class="c1"># 3</span>
</code></pre></div><h4 id="next">next</h4>
<p>通过next(next其实也是调用__next__)可以进行迭代使用，当达到最后一个元素之后，就会抛出StopIteration</p>
<h4 id="send">send</h4>
<p>通过send我们可以想生成器函数发送数据，第一次发送必须是next之后，否则会报错，当然我们可以先调用send(None), 等价于next</p>
<p><code>send</code>可以向生成器传值的同时会让生成器前进到下一个<code>yield</code>语句，并将<code>yield</code>右侧的值作为返回值</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">x</span>
    <span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>


<span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="p">()</span>
<span class="n">f</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&#34;ok&#34;</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
</code></pre></div><p>首先我们先调用send初始化生成器，然后再<code>send(&quot;ok&quot;)</code>, 会将x进行覆盖，然后传给r，最后返回的就是&quot;ok&quot;</p>
<h4 id="协程状态">协程状态</h4>
<p><code>GEN_CREATE</code> 等待开始执行
<code>GEN_RUNNING</code> 解释器正在执行
<code>GEN_SUSPENDED</code> 在yield表达式处暂停
<code>GEN_CLOSED</code> 执行结束
使用<code>inspect.getgeneratorstat(generator)</code>可以查看</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">getgeneratorstate</span>

<span class="k">def</span> <span class="nf">md</span><span class="p">():</span>
    <span class="k">yield</span> <span class="mi">1</span>
    <span class="k">yield</span> <span class="mi">2</span>


<span class="n">m</span> <span class="o">=</span> <span class="n">md</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">getgeneratorstate</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>  <span class="c1"># GEN_CREATED</span>

<span class="n">m</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">getgeneratorstate</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>  <span class="c1"># GEN_SUSPENDED</span>

<span class="n">m</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">getgeneratorstate</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>  <span class="c1"># GEN_SUSPENDED</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">m</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">print</span><span class="p">(</span><span class="n">getgeneratorstate</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>  <span class="c1"># GEN_CLOSED</span>
</code></pre></div><h4 id="yield-from">yield from</h4>
<p>yield from是<a href="https://www.python.org/dev/peps/pep-0380/">pep380</a>后加入的，可以将一个可迭代对象直接转为生成器</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="c1"># 不用在这样写</span>
    <span class="c1"># for i in range(10):</span>
    <span class="c1">#     yield i</span>
    <span class="k">yield</span> <span class="kn">from</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">func</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">i</span>
</code></pre></div><h4 id="throw">throw</h4>
<p>throw(typ[,val[,tb]])可以在yield出抛出某个异常, 如果捕获到这个错误，那么生成器会前进到下个yield，并将产出值做为throw的返回值，否则中止生成器</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="s1">&#39;a&#39;</span>
    <span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&#34;catch &#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="k">yield</span> <span class="s1">&#39;b&#39;</span>


<span class="n">gen</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>     
<span class="k">print</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">))</span> 

<span class="c1">### 输出</span>
<span class="c1"># a</span>
<span class="c1"># catch  error</span>
<span class="c1"># b</span>
</code></pre></div><h4 id="return">return</h4>
<p>生成器返回值，在python2中是不能使用return做返回值的，但是python3中却可以</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
    <span class="k">yield</span>
    <span class="k">return</span> <span class="s1">&#39;a&#39;</span>


<span class="n">gen</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
<span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;catch &#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</code></pre></div><p>执行上面返回的是catch e，当运行return，会把return的返回值做为StopIteration的值传递出去</p>
<h4 id="close">close</h4>
<p>停止生成器，我们可以调用f.close(), close其实就是抛出一个GeneratorExit异常，让生成器退出，如果一个生成器函数被close掉后，还继续使用send或者next调用，会抛出异常StopIteration</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
    <span class="k">yield</span> <span class="mi">1</span>
    <span class="k">yield</span> <span class="mi">2</span>
    <span class="k">yield</span> <span class="mi">3</span>


<span class="n">gen</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>
<span class="n">gen</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Python-生成器</title>
			<link>https://leonzyang.github.io/posts/py-decorator/</link>
			<pubDate>Sun, 27 Jun 2021 09:58:27 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/py-decorator/</guid>
			<description>理解装饰器 装饰器是Python里面经常使用到的一个功能，通过装饰器我们能在不修改函数的情况下为函数增加一些功能，装饰器通过语法糖调用
装饰器 普通装饰器 def logger(func): def decorator(*args, **kwargs): print(&amp;#34;func start&amp;#34;) func(*args, **kwargs) return decorator @logger def func(name): print(&amp;#34;my name is %s&amp;#34; % name) func(&amp;#34;leon&amp;#34;) 这是个装饰器的简单例子，整个调用其实就相当于logger(func(name)), 如果是有多个装饰的情况下，那么调用顺序是怎样的？
@A @B @C def func(): pass 上面执行的的过程就是A(B(C(func())))
wraps 我们先看一个例子
def logger(func): def decorator(*args, **kwargs): print(&amp;#34;func start&amp;#34;) func(*args, **kwargs) return decorator @logger def func(name): print(&amp;#34;my name is %s&amp;#34; % name) func(&amp;#34;leon&amp;#34;) print(func.__name__) # decorator 当我们调用func.name 原本上应该输出func，但是因为加入了装饰器，导致__name__、__doc__等一些构造函数被改变了，那么如果我们如何解决这个问题呢？ 这里就需要用到functools.wraps，我们看下加入wraps试下
from functools import wraps def logger(func): @wraps(func) def decorator(*args, **kwargs): print(&amp;#34;func start&amp;#34;) func(*args, **kwargs) return decorator @logger def func(name): print(&amp;#34;my name is %s&amp;#34; % name) func(&amp;#34;leon&amp;#34;) print(func.</description>
			<content type="html"><![CDATA[<h2 id="理解装饰器">理解装饰器</h2>
<p>装饰器是Python里面经常使用到的一个功能，通过装饰器我们能在不修改函数的情况下为函数增加一些功能，装饰器通过语法糖调用</p>
<h3 id="装饰器">装饰器</h3>
<h4 id="普通装饰器">普通装饰器</h4>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&#34;func start&#34;</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decorator</span>

<span class="nd">@logger</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;my name is </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>


<span class="n">func</span><span class="p">(</span><span class="s2">&#34;leon&#34;</span><span class="p">)</span>
</code></pre></div><p>这是个装饰器的简单例子，整个调用其实就相当于logger(func(name)), 如果是有多个装饰的情况下，那么调用顺序是怎样的？</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="nd">@A</span>
<span class="nd">@B</span>
<span class="nd">@C</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="k">pass</span>
</code></pre></div><p>上面执行的的过程就是A(B(C(func())))</p>
<h4 id="wraps">wraps</h4>
<p>我们先看一个例子</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&#34;func start&#34;</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decorator</span>

<span class="nd">@logger</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;my name is </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>


<span class="n">func</span><span class="p">(</span><span class="s2">&#34;leon&#34;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>   <span class="c1"># decorator</span>
</code></pre></div><p>当我们调用func.<strong>name</strong> 原本上应该输出func，但是因为加入了装饰器，导致__name__、__doc__等一些构造函数被改变了，那么如果我们如何解决这个问题呢？
这里就需要用到functools.wraps，我们看下加入wraps试下</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&#34;func start&#34;</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decorator</span>

<span class="nd">@logger</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;my name is </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>


<span class="n">func</span><span class="p">(</span><span class="s2">&#34;leon&#34;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>    <span class="c1"># func</span>
</code></pre></div><p>这里__name__是我们预期的，wraps到底做了些什么事情，这里我们看下源码</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">WRAPPER_ASSIGNMENTS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;__annotations__&#39;</span><span class="p">)</span>
<span class="n">WRAPPER_UPDATES</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__dict__&#39;</span><span class="p">,)</span>
<span class="k">def</span> <span class="nf">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span>
                   <span class="n">wrapped</span><span class="p">,</span>
                   <span class="n">assigned</span> <span class="o">=</span> <span class="n">WRAPPER_ASSIGNMENTS</span><span class="p">,</span>
                   <span class="n">updated</span> <span class="o">=</span> <span class="n">WRAPPER_UPDATES</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;Update a wrapper function to look like the wrapped function
</span><span class="s2">
</span><span class="s2">       wrapper is the function to be updated
</span><span class="s2">       wrapped is the original function
</span><span class="s2">       assigned is a tuple naming the attributes assigned directly
</span><span class="s2">       from the wrapped function to the wrapper function (defaults to
</span><span class="s2">       functools.WRAPPER_ASSIGNMENTS)
</span><span class="s2">       updated is a tuple naming the attributes of the wrapper that
</span><span class="s2">       are updated with the corresponding attribute from the wrapped
</span><span class="s2">       function (defaults to functools.WRAPPER_UPDATES)
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">assigned</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">updated</span><span class="p">:</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="p">{}))</span>
    <span class="c1"># Issue #17482: set __wrapped__ last so we don&#39;t inadvertently copy it</span>
    <span class="c1"># from the wrapped function when updating __dict__</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">__wrapped__</span> <span class="o">=</span> <span class="n">wrapped</span>
    <span class="c1"># Return the wrapper so this can be used as a decorator via partial()</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">def</span> <span class="nf">wraps</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span>
          <span class="n">assigned</span> <span class="o">=</span> <span class="n">WRAPPER_ASSIGNMENTS</span><span class="p">,</span>
          <span class="n">updated</span> <span class="o">=</span> <span class="n">WRAPPER_UPDATES</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;Decorator factory to apply update_wrapper() to a wrapper function
</span><span class="s2">
</span><span class="s2">       Returns a decorator that invokes update_wrapper() with the decorated
</span><span class="s2">       function as the wrapper argument and the arguments to wraps() as the
</span><span class="s2">       remaining arguments. Default arguments are as for update_wrapper().
</span><span class="s2">       This is a convenience function to simplify applying partial() to
</span><span class="s2">       update_wrapper().
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">update_wrapper</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span>
                   <span class="n">assigned</span><span class="o">=</span><span class="n">assigned</span><span class="p">,</span> <span class="n">updated</span><span class="o">=</span><span class="n">updated</span><span class="p">)</span>

</code></pre></div><p>从源码上看wraps最终是调用了update_wrapper， 这里会将___name__,__doc__等一些构造函数从原函数赋值到wrapped的的函数中</p>
<h4 id="带参数的装饰器">带参数的装饰器</h4>
<p>如果我们想给装饰器加一些参数呢，这个要怎么做？</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">need_logger</span><span class="p">(</span><span class="n">need</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">need</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&#34;func start&#34;</span><span class="p">)</span>
            <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">decorator</span>
    <span class="k">return</span> <span class="n">logger</span>

<span class="nd">@need_logger</span><span class="p">(</span><span class="n">need</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;my name is </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>


<span class="n">func</span><span class="p">(</span><span class="s2">&#34;leon&#34;</span><span class="p">)</span>
</code></pre></div><p>如果装饰器要带参数的话，我们需要再把装饰器加一层，这个是函数的，我们也可以用类实现带参数的装饰器</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">CustomLogger</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">need</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">need</span> <span class="o">=</span> <span class="n">need</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">need</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&#34;func start 2&#34;</span><span class="p">)</span>
            <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">decorator</span>


<span class="nd">@CustomLogger</span><span class="p">(</span><span class="n">need</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&#34;my name is </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
</code></pre></div><p>第二种方法是不是有点不一样的感觉，通过类，我们可以将装饰器封装成一个完成包，去集成我们自己的功能</p>
<h3 id="内置的三个装饰器">内置的三个装饰器</h3>
<p>这里我们讲一下Python里面内置的装饰器</p>
<h4 id="property">property</h4>
<p>通过@property我们可以将一个函数变成一个属性进行调用，很大程度的方便了我们使用</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Demo</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
    
    <span class="nd">@get_value.setter</span>
    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>


<span class="n">d</span> <span class="o">=</span> <span class="n">Demo</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get_value</span><span class="p">)</span>   <span class="c1"># 0</span>

<span class="n">d</span><span class="o">.</span><span class="n">set_value</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get_value</span><span class="p">)</span>   <span class="c1"># 1</span>
</code></pre></div><h4 id="classmethod">classmethod</h4>
<p>classmethod和类绑定，不是和实例绑定, classmethod接收一个类参数cls, 可以修改类的状态，并将其作用到所有的类实例上</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Demo</span><span class="p">():</span>
    <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_value2</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">value</span>


<span class="k">print</span><span class="p">(</span><span class="n">Demo</span><span class="o">.</span><span class="n">get_value2</span><span class="p">())</span>  <span class="c1"># 2</span>
<span class="k">print</span><span class="p">(</span><span class="n">Demo</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>    <span class="c1"># 2</span>
</code></pre></div><p>可以看到，我们通过类方法修改的值已经作用域所有的类实例了</p>
<h4 id="staticmethod">staticmethod</h4>
<p>静态方法跟普通函数没什么区别，通过类和实例都可以直接该函数</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Demo</span><span class="p">():</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_value</span><span class="p">():</span>
        <span class="k">return</span> <span class="s2">&#34;ok&#34;</span>

<span class="k">print</span><span class="p">(</span><span class="n">Demo</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>  <span class="c1"># ok</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Python-单例模式</title>
			<link>https://leonzyang.github.io/posts/py-singleleton/</link>
			<pubDate>Sun, 27 Jun 2021 09:58:17 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/py-singleleton/</guid>
			<description>单例模式 包导入模式 class Singleton: pass singleton = Singleton() 装饰器模式 def SingletonDec(cls): _instance = {} def _singleton(*args, **kwargs): if cls not in _instance: _instance[cls] = cls(*args, **kwargs) return _instance[cls] return _singleton @SingletonDec class Foo: pass 类 class Singleton: def __new__(cls, *args, **kwargs): if not hasattr(cls, &amp;#39;_instance&amp;#39;): cls._instance = super().__new__(cls) return cls._instance 元类 class Singleton(type): def __call__(cls, *args, **kwargs): if not hasattr(cls, &amp;#39;_instance&amp;#39;): cls._instance = super().__call__(*args, **kwargs) return cls._instance class Foo(metaclass=Singleton): pass </description>
			<content type="html"><![CDATA[<h2 id="单例模式">单例模式</h2>
<h3 id="包导入模式">包导入模式</h3>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Singleton</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">singleton</span> <span class="o">=</span> <span class="n">Singleton</span><span class="p">()</span>
</code></pre></div><h3 id="装饰器模式">装饰器模式</h3>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">SingletonDec</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="n">_instance</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_singleton</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_instance</span><span class="p">:</span>
            <span class="n">_instance</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_instance</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">_singleton</span>

<span class="nd">@SingletonDec</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">pass</span>
</code></pre></div><h3 id="类">类</h3>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Singleton</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_instance&#39;</span><span class="p">):</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_instance</span>
</code></pre></div><h3 id="元类">元类</h3>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Singleton</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_instance&#39;</span><span class="p">):</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_instance</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Singleton</span><span class="p">):</span>
    <span class="k">pass</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go-深入理解HTTP Client</title>
			<link>https://leonzyang.github.io/posts/gohttpclient/</link>
			<pubDate>Sun, 27 Jun 2021 09:36:17 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/gohttpclient/</guid>
			<description>深入理解HTTP Client 数据结构 Client type Client struct { // HTTP Requests的 	Transport RoundTripper // HTTP重定向 	CheckRedirect func(req *Request, via []*Request) error // Cookie 	Jar CookieJar // 客户端请求的超时时间，默认为0，代表永远不超时 	Timeout time.Duration } Transport Transport会缓存连接进行重用
type Transport struct { idleMu sync.Mutex wantIdle bool // user has requested to close all idle conns  // connectMethodKey 是一个map key，保存了proxy, schema, addr，然后排列生成一个字符串 	idleConn map[connectMethodKey][]*persistConn // 从最近到最晚 	idleConnCh map[connectMethodKey]chan *persistConn idleLRU connLRU reqMu sync.</description>
			<content type="html"><![CDATA[<h2 id="深入理解http-client">深入理解HTTP Client</h2>
<h3 id="数据结构">数据结构</h3>
<h4 id="client">Client</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// HTTP Requests的
</span><span class="c1"></span>	<span class="nx">Transport</span> <span class="nx">RoundTripper</span>

    <span class="c1">// HTTP重定向
</span><span class="c1"></span>	<span class="nx">CheckRedirect</span> <span class="kd">func</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">via</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// Cookie
</span><span class="c1"></span>	<span class="nx">Jar</span> <span class="nx">CookieJar</span>

    <span class="c1">// 客户端请求的超时时间，默认为0，代表永远不超时
</span><span class="c1"></span>	<span class="nx">Timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
<span class="p">}</span>
</code></pre></div><h4 id="transport">Transport</h4>
<p>Transport会缓存连接进行重用</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Transport</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">idleMu</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">wantIdle</span>   <span class="kt">bool</span>                                <span class="c1">// user has requested to close all idle conns
</span><span class="c1"></span>    <span class="c1">// connectMethodKey 是一个map key，保存了proxy, schema, addr，然后排列生成一个字符串
</span><span class="c1"></span>	<span class="nx">idleConn</span>   <span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">][]</span><span class="o">*</span><span class="nx">persistConn</span> <span class="c1">// 从最近到最晚
</span><span class="c1"></span>	<span class="nx">idleConnCh</span> <span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">]</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">persistConn</span> 
	<span class="nx">idleLRU</span>    <span class="nx">connLRU</span>

	<span class="nx">reqMu</span>       <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">reqCanceler</span> <span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">Request</span><span class="p">]</span><span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span>

	<span class="nx">altMu</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>   <span class="c1">// guards changing altProto only
</span><span class="c1"></span>	<span class="nx">altProto</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span> <span class="c1">// of nil or map[string]RoundTripper, key is URI scheme
</span><span class="c1"></span>
	<span class="nx">connCountMu</span>          <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">connPerHostCount</span>     <span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">]</span><span class="kt">int</span>
	<span class="nx">connPerHostAvailable</span> <span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">]</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>

	<span class="c1">// Proxy specifies a function to return a proxy for a given
</span><span class="c1"></span>	<span class="c1">// Request. If the function returns a non-nil error, the
</span><span class="c1"></span>	<span class="c1">// request is aborted with the provided error.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The proxy type is determined by the URL scheme. &#34;http&#34;,
</span><span class="c1"></span>	<span class="c1">// &#34;https&#34;, and &#34;socks5&#34; are supported. If the scheme is empty,
</span><span class="c1"></span>	<span class="c1">// &#34;http&#34; is assumed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If Proxy is nil or returns a nil *URL, no proxy is used.
</span><span class="c1"></span>	<span class="nx">Proxy</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// DialContext specifies the dial function for creating unencrypted TCP connections.
</span><span class="c1"></span>	<span class="c1">// If DialContext is nil (and the deprecated Dial below is also nil),
</span><span class="c1"></span>	<span class="c1">// then the transport dials using package net.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// DialContext runs concurrently with calls to RoundTrip.
</span><span class="c1"></span>	<span class="c1">// A RoundTrip call that initiates a dial may end up using
</span><span class="c1"></span>	<span class="c1">// a connection dialed previously when the earlier connection
</span><span class="c1"></span>	<span class="c1">// becomes idle before the later DialContext completes.
</span><span class="c1"></span>	<span class="nx">DialContext</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">network</span><span class="p">,</span> <span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// Dial specifies the dial function for creating unencrypted TCP connections.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Dial runs concurrently with calls to RoundTrip.
</span><span class="c1"></span>	<span class="c1">// A RoundTrip call that initiates a dial may end up using
</span><span class="c1"></span>	<span class="c1">// a connection dialed previously when the earlier connection
</span><span class="c1"></span>	<span class="c1">// becomes idle before the later Dial completes.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Deprecated: Use DialContext instead, which allows the transport
</span><span class="c1"></span>	<span class="c1">// to cancel dials as soon as they are no longer needed.
</span><span class="c1"></span>	<span class="c1">// If both are set, DialContext takes priority.
</span><span class="c1"></span>	<span class="nx">Dial</span> <span class="kd">func</span><span class="p">(</span><span class="nx">network</span><span class="p">,</span> <span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// DialTLS specifies an optional dial function for creating
</span><span class="c1"></span>	<span class="c1">// TLS connections for non-proxied HTTPS requests.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If DialTLS is nil, Dial and TLSClientConfig are used.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If DialTLS is set, the Dial hook is not used for HTTPS
</span><span class="c1"></span>	<span class="c1">// requests and the TLSClientConfig and TLSHandshakeTimeout
</span><span class="c1"></span>	<span class="c1">// are ignored. The returned net.Conn is assumed to already be
</span><span class="c1"></span>	<span class="c1">// past the TLS handshake.
</span><span class="c1"></span>	<span class="nx">DialTLS</span> <span class="kd">func</span><span class="p">(</span><span class="nx">network</span><span class="p">,</span> <span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// TLSClientConfig specifies the TLS configuration to use with
</span><span class="c1"></span>	<span class="c1">// tls.Client.
</span><span class="c1"></span>	<span class="c1">// If nil, the default configuration is used.
</span><span class="c1"></span>	<span class="c1">// If non-nil, HTTP/2 support may not be enabled by default.
</span><span class="c1"></span>	<span class="nx">TLSClientConfig</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span>

	<span class="c1">// TLSHandshakeTimeout specifies the maximum amount of time waiting to
</span><span class="c1"></span>	<span class="c1">// wait for a TLS handshake. Zero means no timeout.
</span><span class="c1"></span>	<span class="nx">TLSHandshakeTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// DisableKeepAlives, if true, disables HTTP keep-alives and
</span><span class="c1"></span>	<span class="c1">// will only use the connection to the server for a single
</span><span class="c1"></span>	<span class="c1">// HTTP request.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This is unrelated to the similarly named TCP keep-alives.
</span><span class="c1"></span>	<span class="nx">DisableKeepAlives</span> <span class="kt">bool</span>

	<span class="c1">// DisableCompression, if true, prevents the Transport from
</span><span class="c1"></span>	<span class="c1">// requesting compression with an &#34;Accept-Encoding: gzip&#34;
</span><span class="c1"></span>	<span class="c1">// request header when the Request contains no existing
</span><span class="c1"></span>	<span class="c1">// Accept-Encoding value. If the Transport requests gzip on
</span><span class="c1"></span>	<span class="c1">// its own and gets a gzipped response, it&#39;s transparently
</span><span class="c1"></span>	<span class="c1">// decoded in the Response.Body. However, if the user
</span><span class="c1"></span>	<span class="c1">// explicitly requested gzip it is not automatically
</span><span class="c1"></span>	<span class="c1">// uncompressed.
</span><span class="c1"></span>	<span class="nx">DisableCompression</span> <span class="kt">bool</span>

	<span class="c1">// MaxIdleConns controls the maximum number of idle (keep-alive)
</span><span class="c1"></span>    <span class="c1">// connections across all hosts. Zero means no limit.
</span><span class="c1"></span>    <span class="c1">// 所有host的最大空闲连接数
</span><span class="c1"></span>	<span class="nx">MaxIdleConns</span> <span class="kt">int</span>

	<span class="c1">// MaxIdleConnsPerHost, if non-zero, controls the maximum idle
</span><span class="c1"></span>	<span class="c1">// (keep-alive) connections to keep per-host. If zero,
</span><span class="c1"></span>    <span class="c1">// DefaultMaxIdleConnsPerHost is used.
</span><span class="c1"></span>    <span class="c1">// 每个host的最大空闲连接数
</span><span class="c1"></span>	<span class="nx">MaxIdleConnsPerHost</span> <span class="kt">int</span>

	<span class="c1">// MaxConnsPerHost optionally limits the total number of
</span><span class="c1"></span>	<span class="c1">// connections per host, including connections in the dialing,
</span><span class="c1"></span>	<span class="c1">// active, and idle states. On limit violation, dials will block.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Zero means no limit.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For HTTP/2, this currently only controls the number of new
</span><span class="c1"></span>	<span class="c1">// connections being created at a time, instead of the total
</span><span class="c1"></span>	<span class="c1">// number. In practice, hosts using HTTP/2 only have about one
</span><span class="c1"></span>    <span class="c1">// idle connection, though.
</span><span class="c1"></span>    <span class="c1">// 每个host的最大连接数
</span><span class="c1"></span>	<span class="nx">MaxConnsPerHost</span> <span class="kt">int</span>

	<span class="c1">// IdleConnTimeout is the maximum amount of time an idle
</span><span class="c1"></span>	<span class="c1">// (keep-alive) connection will remain idle before closing
</span><span class="c1"></span>	<span class="c1">// itself.
</span><span class="c1"></span>    <span class="c1">// Zero means no limit.
</span><span class="c1"></span>    <span class="c1">// 空闲连接的过期时间
</span><span class="c1"></span>	<span class="nx">IdleConnTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// ResponseHeaderTimeout, if non-zero, specifies the amount of
</span><span class="c1"></span>	<span class="c1">// time to wait for a server&#39;s response headers after fully
</span><span class="c1"></span>	<span class="c1">// writing the request (including its body, if any). This
</span><span class="c1"></span>	<span class="c1">// time does not include the time to read the response body.
</span><span class="c1"></span>	<span class="nx">ResponseHeaderTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// ExpectContinueTimeout, if non-zero, specifies the amount of
</span><span class="c1"></span>	<span class="c1">// time to wait for a server&#39;s first response headers after fully
</span><span class="c1"></span>	<span class="c1">// writing the request headers if the request has an
</span><span class="c1"></span>	<span class="c1">// &#34;Expect: 100-continue&#34; header. Zero means no timeout and
</span><span class="c1"></span>	<span class="c1">// causes the body to be sent immediately, without
</span><span class="c1"></span>	<span class="c1">// waiting for the server to approve.
</span><span class="c1"></span>	<span class="c1">// This time does not include the time to send the request header.
</span><span class="c1"></span>	<span class="nx">ExpectContinueTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// TLSNextProto specifies how the Transport switches to an
</span><span class="c1"></span>	<span class="c1">// alternate protocol (such as HTTP/2) after a TLS NPN/ALPN
</span><span class="c1"></span>	<span class="c1">// protocol negotiation. If Transport dials an TLS connection
</span><span class="c1"></span>	<span class="c1">// with a non-empty protocol name and TLSNextProto contains a
</span><span class="c1"></span>	<span class="c1">// map entry for that key (such as &#34;h2&#34;), then the func is
</span><span class="c1"></span>	<span class="c1">// called with the request&#39;s authority (such as &#34;example.com&#34;
</span><span class="c1"></span>	<span class="c1">// or &#34;example.com:1234&#34;) and the TLS connection. The function
</span><span class="c1"></span>	<span class="c1">// must return a RoundTripper that then handles the request.
</span><span class="c1"></span>	<span class="c1">// If TLSNextProto is not nil, HTTP/2 support is not enabled
</span><span class="c1"></span>	<span class="c1">// automatically.
</span><span class="c1"></span>	<span class="nx">TLSNextProto</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">func</span><span class="p">(</span><span class="nx">authority</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="nx">RoundTripper</span>

	<span class="c1">// ProxyConnectHeader optionally specifies headers to send to
</span><span class="c1"></span>	<span class="c1">// proxies during CONNECT requests.
</span><span class="c1"></span>	<span class="nx">ProxyConnectHeader</span> <span class="nx">Header</span>

	<span class="c1">// MaxResponseHeaderBytes specifies a limit on how many
</span><span class="c1"></span>	<span class="c1">// response bytes are allowed in the server&#39;s response
</span><span class="c1"></span>	<span class="c1">// header.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Zero means to use a default limit.
</span><span class="c1"></span>	<span class="nx">MaxResponseHeaderBytes</span> <span class="kt">int64</span>

	<span class="c1">// nextProtoOnce guards initialization of TLSNextProto and
</span><span class="c1"></span>	<span class="c1">// h2transport (via onceSetNextProtoDefaults)
</span><span class="c1"></span>	<span class="nx">nextProtoOnce</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="nx">h2transport</span>   <span class="nx">h2Transport</span> <span class="c1">// non-nil if http2 wired up
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="persistconn">persistConn</h4>
<p>persistConn封装了一个连接，表示持久连接</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">persistConn</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// alt optionally specifies the TLS NextProto RoundTripper.
</span><span class="c1"></span>	<span class="c1">// This is used for HTTP/2 today and future protocols later.
</span><span class="c1"></span>	<span class="c1">// If it&#39;s non-nil, the rest of the fields are unused.
</span><span class="c1"></span>	<span class="nx">alt</span> <span class="nx">RoundTripper</span>

	<span class="nx">t</span>         <span class="o">*</span><span class="nx">Transport</span>
	<span class="nx">cacheKey</span>  <span class="nx">connectMethodKey</span>
	<span class="nx">conn</span>      <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span>
	<span class="nx">tlsState</span>  <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span>
	<span class="nx">br</span>        <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span>       <span class="c1">// from conn
</span><span class="c1"></span>	<span class="nx">bw</span>        <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Writer</span>       <span class="c1">// to conn
</span><span class="c1"></span>	<span class="nx">nwrite</span>    <span class="kt">int64</span>               <span class="c1">// bytes written
</span><span class="c1"></span>	<span class="c1">// roundTrip 写， readLoop 读
</span><span class="c1"></span>	<span class="nx">reqch</span>     <span class="kd">chan</span> <span class="nx">requestAndChan</span> <span class="c1">// written by roundTrip; read by readLoop
</span><span class="c1"></span>	<span class="c1">// roundTrip 写，writeLoop读
</span><span class="c1"></span>	<span class="nx">writech</span>   <span class="kd">chan</span> <span class="nx">writeRequest</span>   <span class="c1">// written by roundTrip; read by writeLoop
</span><span class="c1"></span>	<span class="c1">// 当连接closed，该chan会被close
</span><span class="c1"></span>	<span class="nx">closech</span>   <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>       <span class="c1">// closed when conn closed
</span><span class="c1"></span>	<span class="nx">isProxy</span>   <span class="kt">bool</span>
	<span class="nx">sawEOF</span>    <span class="kt">bool</span>  <span class="c1">// whether we&#39;ve seen EOF from conn; owned by readLoop
</span><span class="c1"></span>	<span class="nx">readLimit</span> <span class="kt">int64</span> <span class="c1">// bytes allowed to be read; owned by readLoop
</span><span class="c1"></span>	<span class="c1">// writeErrCh passes the request write error (usually nil)
</span><span class="c1"></span>	<span class="c1">// from the writeLoop goroutine to the readLoop which passes
</span><span class="c1"></span>	<span class="c1">// it off to the res.Body reader, which then uses it to decide
</span><span class="c1"></span>	<span class="c1">// whether or not a connection can be reused. Issue 7569.
</span><span class="c1"></span>	<span class="nx">writeErrCh</span> <span class="kd">chan</span> <span class="kt">error</span>

	<span class="nx">writeLoopDone</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="c1">// closed when write loop ends
</span><span class="c1"></span>
	<span class="c1">// Both guarded by Transport.idleMu:
</span><span class="c1"></span>	<span class="nx">idleAt</span>    <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>   <span class="c1">// time it last become idle
</span><span class="c1"></span>	<span class="nx">idleTimer</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span> <span class="c1">// holding an AfterFunc to close it
</span><span class="c1"></span>
	<span class="nx">mu</span>                   <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards following fields
</span><span class="c1"></span>	<span class="nx">numExpectedResponses</span> <span class="kt">int</span>
	<span class="c1">// 如果closed，则为非nil
</span><span class="c1"></span>	<span class="nx">closed</span>               <span class="kt">error</span> <span class="c1">// set non-nil when conn is closed, before closech is closed
</span><span class="c1"></span>	<span class="nx">canceledErr</span>          <span class="kt">error</span> <span class="c1">// set non-nil if conn is canceled
</span><span class="c1"></span>	<span class="c1">// 如果broken为true，则该链接不会复用
</span><span class="c1"></span>	<span class="nx">broken</span>               <span class="kt">bool</span>  <span class="c1">// an error has happened on this connection; marked broken so it&#39;s not reused.
</span><span class="c1"></span>	<span class="nx">reused</span>               <span class="kt">bool</span>  <span class="c1">// whether conn has had successful request/response and is being reused.
</span><span class="c1"></span>	<span class="c1">// mutateHeaderFunc is an optional func to modify extra
</span><span class="c1"></span>	<span class="c1">// headers on each outbound request before it&#39;s written. (the
</span><span class="c1"></span>	<span class="c1">// original Request given to RoundTrip is not modified)
</span><span class="c1"></span>	<span class="nx">mutateHeaderFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">Header</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h5 id="默认参数">默认参数</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">DefaultTransport</span> <span class="nx">RoundTripper</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Transport</span><span class="p">{</span>
	<span class="nx">Proxy</span><span class="p">:</span> <span class="nx">ProxyFromEnvironment</span><span class="p">,</span>
	<span class="nx">DialContext</span><span class="p">:</span> <span class="p">(</span><span class="o">&amp;</span><span class="nx">net</span><span class="p">.</span><span class="nx">Dialer</span><span class="p">{</span>
		<span class="nx">Timeout</span><span class="p">:</span>   <span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
		<span class="nx">KeepAlive</span><span class="p">:</span> <span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
		<span class="nx">DualStack</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
	<span class="p">}).</span><span class="nx">DialContext</span><span class="p">,</span>
	<span class="nx">MaxIdleConns</span><span class="p">:</span>          <span class="mi">100</span><span class="p">,</span>
	<span class="nx">IdleConnTimeout</span><span class="p">:</span>       <span class="mi">90</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
	<span class="nx">TLSHandshakeTimeout</span><span class="p">:</span>   <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
	<span class="nx">ExpectContinueTimeout</span><span class="p">:</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><h3 id="请求">请求</h3>
<h4 id="do">Do</h4>
<p>当我们请求一个接口的时候，我们通常使用client.Do进行调用</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Do也是直接调用do
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nf">do</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="nx">retres</span> <span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">reterr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">testHookClientDoResult</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">testHookClientDoResult</span><span class="p">(</span><span class="nx">retres</span><span class="p">,</span> <span class="nx">reterr</span><span class="p">)</span> <span class="p">}()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">url</span><span class="p">.</span><span class="nx">Error</span><span class="p">{</span>
			<span class="nx">Op</span><span class="p">:</span>  <span class="nf">urlErrorOp</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">),</span>
			<span class="nx">Err</span><span class="p">:</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: nil Request.URL&#34;</span><span class="p">),</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">deadline</span>      <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">deadline</span><span class="p">()</span>
		<span class="nx">reqs</span>          <span class="p">[]</span><span class="o">*</span><span class="nx">Request</span>
		<span class="nx">resp</span>          <span class="o">*</span><span class="nx">Response</span>
		<span class="nx">copyHeaders</span>   <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">makeHeadersCopier</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
		<span class="nx">reqBodyClosed</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// have we closed the current req.Body?
</span><span class="c1"></span>
		<span class="c1">// Redirect behavior:
</span><span class="c1"></span>		<span class="nx">redirectMethod</span> <span class="kt">string</span>
		<span class="nx">includeBody</span>    <span class="kt">bool</span>
	<span class="p">)</span>
	<span class="nx">uerr</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="c1">// the body may have been closed already by c.send()
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">reqBodyClosed</span> <span class="p">{</span>
			<span class="c1">// closeBody 其实也是调用Body.Close
</span><span class="c1"></span>			<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="kd">var</span> <span class="nx">urlStr</span> <span class="kt">string</span>
		<span class="k">if</span> <span class="nx">resp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Request</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">urlStr</span> <span class="p">=</span> <span class="nf">stripPassword</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">urlStr</span> <span class="p">=</span> <span class="nf">stripPassword</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">url</span><span class="p">.</span><span class="nx">Error</span><span class="p">{</span>
			<span class="nx">Op</span><span class="p">:</span>  <span class="nf">urlErrorOp</span><span class="p">(</span><span class="nx">reqs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Method</span><span class="p">),</span>
			<span class="nx">URL</span><span class="p">:</span> <span class="nx">urlStr</span><span class="p">,</span>
			<span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// For all but the first request, create the next
</span><span class="c1"></span>		<span class="c1">// request hop and replace req.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">reqs</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">loc</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Location&#34;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">loc</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
				<span class="nx">resp</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;%d response missing Location header&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="nx">u</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">loc</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">resp</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to parse Location header %q: %v&#34;</span><span class="p">,</span> <span class="nx">loc</span><span class="p">,</span> <span class="nx">err</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="nx">host</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
			<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Host</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Host</span> <span class="o">!=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Host</span> <span class="p">{</span>
				<span class="c1">// If the caller specified a custom Host header and the
</span><span class="c1"></span>				<span class="c1">// redirect location is relative, preserve the Host header
</span><span class="c1"></span>				<span class="c1">// through the redirect. See issue #22233.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">u</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">loc</span><span class="p">);</span> <span class="nx">u</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">u</span><span class="p">.</span><span class="nf">IsAbs</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">host</span> <span class="p">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Host</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">ireq</span> <span class="o">:=</span> <span class="nx">reqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Request</span><span class="p">{</span>
				<span class="nx">Method</span><span class="p">:</span>   <span class="nx">redirectMethod</span><span class="p">,</span>
				<span class="nx">Response</span><span class="p">:</span> <span class="nx">resp</span><span class="p">,</span>
				<span class="nx">URL</span><span class="p">:</span>      <span class="nx">u</span><span class="p">,</span>
				<span class="nx">Header</span><span class="p">:</span>   <span class="nb">make</span><span class="p">(</span><span class="nx">Header</span><span class="p">),</span>
				<span class="nx">Host</span><span class="p">:</span>     <span class="nx">host</span><span class="p">,</span>
				<span class="nx">Cancel</span><span class="p">:</span>   <span class="nx">ireq</span><span class="p">.</span><span class="nx">Cancel</span><span class="p">,</span>
				<span class="nx">ctx</span><span class="p">:</span>      <span class="nx">ireq</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">includeBody</span> <span class="o">&amp;&amp;</span> <span class="nx">ireq</span><span class="p">.</span><span class="nx">GetBody</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">ireq</span><span class="p">.</span><span class="nf">GetBody</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">resp</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
					<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="nx">ireq</span><span class="p">.</span><span class="nx">ContentLength</span>
			<span class="p">}</span>

			<span class="c1">// Copy original headers before setting the Referer,
</span><span class="c1"></span>			<span class="c1">// in case the user set Referer on their first request.
</span><span class="c1"></span>			<span class="c1">// If they really want to override, they can do it in
</span><span class="c1"></span>			<span class="c1">// their CheckRedirect func.
</span><span class="c1"></span>			<span class="nf">copyHeaders</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>

			<span class="c1">// Add the Referer header from the most recent
</span><span class="c1"></span>			<span class="c1">// request URL to the new one, if it&#39;s not https-&gt;http:
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">ref</span> <span class="o">:=</span> <span class="nf">refererForURL</span><span class="p">(</span><span class="nx">reqs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">reqs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">URL</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">);</span> <span class="nx">ref</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Referer&#34;</span><span class="p">,</span> <span class="nx">ref</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">checkRedirect</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">reqs</span><span class="p">)</span>

			<span class="c1">// Sentinel error to let users select the
</span><span class="c1"></span>			<span class="c1">// previous response, without closing its
</span><span class="c1"></span>			<span class="c1">// body. See Issue 10069.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ErrUseLastResponse</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span>
			<span class="p">}</span>

			<span class="c1">// Close the previous response&#39;s body. But
</span><span class="c1"></span>			<span class="c1">// read at least some of the body so if it&#39;s
</span><span class="c1"></span>			<span class="c1">// small the underlying TCP connection will be
</span><span class="c1"></span>			<span class="c1">// re-used. No need to check for errors: if it
</span><span class="c1"></span>			<span class="c1">// fails, the Transport won&#39;t reuse it anyway.
</span><span class="c1"></span>			<span class="kd">const</span> <span class="nx">maxBodySlurpSize</span> <span class="p">=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span>
			<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">&lt;=</span> <span class="nx">maxBodySlurpSize</span> <span class="p">{</span>
				<span class="nx">io</span><span class="p">.</span><span class="nf">CopyN</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">maxBodySlurpSize</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="c1">// Special case for Go 1 compatibility: return both the response
</span><span class="c1"></span>				<span class="c1">// and an error if the CheckRedirect function failed.
</span><span class="c1"></span>				<span class="c1">// See https://golang.org/issue/3795
</span><span class="c1"></span>				<span class="c1">// The resp.Body has already been closed.
</span><span class="c1"></span>				<span class="nx">ue</span> <span class="o">:=</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="nx">ue</span><span class="p">.(</span><span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">Error</span><span class="p">).</span><span class="nx">URL</span> <span class="p">=</span> <span class="nx">loc</span>
				<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">ue</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">reqs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">reqs</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
		<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
		<span class="kd">var</span> <span class="nx">didTimeout</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span>
		<span class="k">if</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">didTimeout</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">deadline</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// c.send() always closes req.Body
</span><span class="c1"></span>			<span class="nx">reqBodyClosed</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">deadline</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">didTimeout</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">httpError</span><span class="p">{</span>
					<span class="c1">// TODO: early in cycle: s/Client.Timeout exceeded/timeout or context cancelation/
</span><span class="c1"></span>					<span class="nx">err</span><span class="p">:</span>     <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; (Client.Timeout exceeded while awaiting headers)&#34;</span><span class="p">,</span>
					<span class="nx">timeout</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="kd">var</span> <span class="nx">shouldRedirect</span> <span class="kt">bool</span>
		<span class="nx">redirectMethod</span><span class="p">,</span> <span class="nx">shouldRedirect</span><span class="p">,</span> <span class="nx">includeBody</span> <span class="p">=</span> <span class="nf">redirectBehavior</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">reqs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">shouldRedirect</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>

		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="clientsend">client.send</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nf">send</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">didTimeout</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Jar</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">cookie</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Jar</span><span class="p">.</span><span class="nf">Cookies</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">req</span><span class="p">.</span><span class="nf">AddCookie</span><span class="p">(</span><span class="nx">cookie</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">resp</span><span class="p">,</span> <span class="nx">didTimeout</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">send</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">transport</span><span class="p">(),</span> <span class="nx">deadline</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">didTimeout</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Jar</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">rc</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nf">Cookies</span><span class="p">();</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rc</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">Jar</span><span class="p">.</span><span class="nf">SetCookies</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="nx">rc</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="send">send</h4>
<p>发送HTTP请求</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">send</span><span class="p">(</span><span class="nx">ireq</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">rt</span> <span class="nx">RoundTripper</span><span class="p">,</span> <span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">didTimeout</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">req</span> <span class="o">:=</span> <span class="nx">ireq</span> <span class="c1">// req is either the original request, or a modified fork
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">rt</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">alwaysFalse</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: no Client.Transport or DefaultTransport&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">alwaysFalse</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: nil Request.URL&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">RequestURI</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">alwaysFalse</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: Request.RequestURI can&#39;t be set in client requests.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// forkReq forks req into a shallow clone of ireq the first
</span><span class="c1"></span>	<span class="c1">// time it&#39;s called.
</span><span class="c1"></span>	<span class="nx">forkReq</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ireq</span> <span class="o">==</span> <span class="nx">req</span> <span class="p">{</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Request</span><span class="p">)</span>
			<span class="o">*</span><span class="nx">req</span> <span class="p">=</span> <span class="o">*</span><span class="nx">ireq</span> <span class="c1">// shallow clone
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Most the callers of send (Get, Post, et al) don&#39;t need
</span><span class="c1"></span>	<span class="c1">// Headers, leaving it uninitialized. We guarantee to the
</span><span class="c1"></span>	<span class="c1">// Transport that this has been initialized, though.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">forkReq</span><span class="p">()</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">Header</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">u</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">User</span><span class="p">;</span> <span class="nx">u</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Authorization&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">username</span> <span class="o">:=</span> <span class="nx">u</span><span class="p">.</span><span class="nf">Username</span><span class="p">()</span>
		<span class="nx">password</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">u</span><span class="p">.</span><span class="nf">Password</span><span class="p">()</span>
		<span class="nf">forkReq</span><span class="p">()</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span> <span class="p">=</span> <span class="nx">ireq</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">clone</span><span class="p">()</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Authorization&#34;</span><span class="p">,</span> <span class="s">&#34;Basic &#34;</span><span class="o">+</span><span class="nf">basicAuth</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">password</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">deadline</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">forkReq</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">stopTimer</span><span class="p">,</span> <span class="nx">didTimeout</span> <span class="o">:=</span> <span class="nf">setRequestCancel</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">rt</span><span class="p">,</span> <span class="nx">deadline</span><span class="p">)</span>
	<span class="c1">// 处理 req
</span><span class="c1"></span>	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">RoundTrip</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">stopTimer</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">resp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;RoundTripper returned a response &amp; error; ignoring response&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">tlsErr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">tls</span><span class="p">.</span><span class="nx">RecordHeaderError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// If we get a bad TLS record header, check to see if the
</span><span class="c1"></span>			<span class="c1">// response looks like HTTP and give a more helpful error.
</span><span class="c1"></span>			<span class="c1">// See golang.org/issue/11111.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nb">string</span><span class="p">(</span><span class="nx">tlsErr</span><span class="p">.</span><span class="nx">RecordHeader</span><span class="p">[:])</span> <span class="o">==</span> <span class="s">&#34;HTTP/&#34;</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: server gave HTTP response to HTTPS client&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">didTimeout</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">deadline</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">cancelTimerBody</span><span class="p">{</span>
			<span class="nx">stop</span><span class="p">:</span>          <span class="nx">stopTimer</span><span class="p">,</span>
			<span class="nx">rc</span><span class="p">:</span>            <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span>
			<span class="nx">reqDidTimeout</span><span class="p">:</span> <span class="nx">didTimeout</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="roundtrip">roundTrip</h4>
<p>roundTrip实现了HTTP的RoundTripper</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">roundTrip</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">nextProtoOnce</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">onceSetNextProtoDefaults</span><span class="p">)</span>
	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">()</span>
	<span class="nx">trace</span> <span class="o">:=</span> <span class="nx">httptrace</span><span class="p">.</span><span class="nf">ContextClientTrace</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: nil Request.URL&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: nil Request.Header&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">scheme</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Scheme</span>
	<span class="nx">isHTTP</span> <span class="o">:=</span> <span class="nx">scheme</span> <span class="o">==</span> <span class="s">&#34;http&#34;</span> <span class="o">||</span> <span class="nx">scheme</span> <span class="o">==</span> <span class="s">&#34;https&#34;</span>
	<span class="k">if</span> <span class="nx">isHTTP</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">vv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">httpguts</span><span class="p">.</span><span class="nf">ValidHeaderFieldName</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;net/http: invalid header field name %q&#34;</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vv</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">httpguts</span><span class="p">.</span><span class="nf">ValidHeaderFieldValue</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;net/http: invalid header field value %q for key %v&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">useRegisteredProtocol</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">altProto</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">altProto</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">RoundTripper</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">altRT</span> <span class="o">:=</span> <span class="nx">altProto</span><span class="p">[</span><span class="nx">scheme</span><span class="p">];</span> <span class="nx">altRT</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">altRT</span><span class="p">.</span><span class="nf">RoundTrip</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">ErrSkipAltProtocol</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">isHTTP</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">badStringError</span><span class="p">{</span><span class="s">&#34;unsupported protocol scheme&#34;</span><span class="p">,</span> <span class="nx">scheme</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Method</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">validMethod</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;net/http: invalid method %q&#34;</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Host</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;http: no Host in request URL&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span>
		<span class="k">default</span><span class="p">:</span>
		<span class="p">}</span>

		<span class="c1">// treq gets modified by roundTrip, so we need to recreate for each retry.
</span><span class="c1"></span>		<span class="nx">treq</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">transportRequest</span><span class="p">{</span><span class="nx">Request</span><span class="p">:</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">trace</span><span class="p">:</span> <span class="nx">trace</span><span class="p">}</span>
		<span class="nx">cm</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">connectMethodForRequest</span><span class="p">(</span><span class="nx">treq</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>

        <span class="c1">// 获取一个连接从缓存或者是新建
</span><span class="c1"></span>		<span class="nx">pconn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">getConn</span><span class="p">(</span><span class="nx">treq</span><span class="p">,</span> <span class="nx">cm</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span>
		<span class="k">if</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">alt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// HTTP/2 path.
</span><span class="c1"></span>			<span class="nx">t</span><span class="p">.</span><span class="nf">decHostConnCount</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nf">key</span><span class="p">())</span> <span class="c1">// don&#39;t count cached http2 conns toward conns per host
</span><span class="c1"></span>			<span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>   <span class="c1">// not cancelable with CancelRequest
</span><span class="c1"></span>			<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">alt</span><span class="p">.</span><span class="nf">RoundTrip</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 处理req和resp
</span><span class="c1"></span>			<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">roundTrip</span><span class="p">(</span><span class="nx">treq</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">pconn</span><span class="p">.</span><span class="nf">shouldRetryRequest</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Issue 16465: return underlying net.Conn.Read error from peek,
</span><span class="c1"></span>			<span class="c1">// as we&#39;ve historically done.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">transportReadFromServerError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">err</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="nf">testHookRoundTripRetried</span><span class="p">()</span>

		<span class="c1">// Rewind the body if we&#39;re able to.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">GetBody</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">newReq</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">req</span>
			<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
			<span class="nx">newReq</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">GetBody</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
			<span class="p">}</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newReq</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="getconn">getConn</h4>
<p>getConn获取一个连接</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">getConn</span><span class="p">(</span><span class="nx">treq</span> <span class="o">*</span><span class="nx">transportRequest</span><span class="p">,</span> <span class="nx">cm</span> <span class="nx">connectMethod</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">persistConn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">req</span> <span class="o">:=</span> <span class="nx">treq</span><span class="p">.</span><span class="nx">Request</span>
	<span class="nx">trace</span> <span class="o">:=</span> <span class="nx">treq</span><span class="p">.</span><span class="nx">trace</span>
	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">GetConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">trace</span><span class="p">.</span><span class="nf">GetConn</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nf">addr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="c1">// 获取空闲连接
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pc</span><span class="p">,</span> <span class="nx">idleSince</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">getIdleConn</span><span class="p">(</span><span class="nx">cm</span><span class="p">);</span> <span class="nx">pc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">GotConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">trace</span><span class="p">.</span><span class="nf">GotConn</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nf">gotIdleConnTrace</span><span class="p">(</span><span class="nx">idleSince</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="c1">// set request canceler to some non-nil function so we
</span><span class="c1"></span>		<span class="c1">// can detect whether it was cleared between now and when
</span><span class="c1"></span>		<span class="c1">// we enter roundTrip
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span> <span class="p">{})</span>
		<span class="k">return</span> <span class="nx">pc</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="kd">type</span> <span class="nx">dialRes</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">pc</span>  <span class="o">*</span><span class="nx">persistConn</span>
		<span class="nx">err</span> <span class="kt">error</span>
	<span class="p">}</span>
	<span class="nx">dialc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">dialRes</span><span class="p">)</span>
	<span class="nx">cmKey</span> <span class="o">:=</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">key</span><span class="p">()</span>

	<span class="c1">// Copy these hooks so we don&#39;t race on the postPendingDial in
</span><span class="c1"></span>	<span class="c1">// the goroutine we launch. Issue 11136.
</span><span class="c1"></span>	<span class="nx">testHookPrePendingDial</span> <span class="o">:=</span> <span class="nx">testHookPrePendingDial</span>
	<span class="nx">testHookPostPendingDial</span> <span class="o">:=</span> <span class="nx">testHookPostPendingDial</span>

	<span class="nx">handlePendingDial</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">testHookPrePendingDial</span><span class="p">()</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">dialc</span><span class="p">;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">putOrCloseIdleConn</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">pc</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">decHostConnCount</span><span class="p">(</span><span class="nx">cmKey</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nf">testHookPostPendingDial</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>

	<span class="nx">cancelc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> <span class="nx">cancelc</span> <span class="o">&lt;-</span> <span class="nx">err</span> <span class="p">})</span>
	<span class="c1">// 如果连接超过每个host最大允许连接，则阻塞的获取连接
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">MaxConnsPerHost</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">t</span><span class="p">.</span><span class="nf">incHostConnCount</span><span class="p">(</span><span class="nx">cmKey</span><span class="p">):</span>
			<span class="c1">// 判断每个host最大连接有没有设置或者有没有超过限制，如果都没满足，则继续
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">pc</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">t</span><span class="p">.</span><span class="nf">getIdleConnCh</span><span class="p">(</span><span class="nx">cm</span><span class="p">):</span>
			<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">GotConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">trace</span><span class="p">.</span><span class="nf">GotConn</span><span class="p">(</span><span class="nx">httptrace</span><span class="p">.</span><span class="nx">GotConnInfo</span><span class="p">{</span><span class="nx">Conn</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">Reused</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">isReused</span><span class="p">()})</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">pc</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">req</span><span class="p">.</span><span class="nx">Cancel</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errRequestCanceledConn</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Done</span><span class="p">():</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Err</span><span class="p">()</span>
		<span class="k">case</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">cancelc</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">errRequestCanceled</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">errRequestCanceledConn</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

    <span class="c1">// 没有空闲的连接，需要新建
</span><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">pc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">dialConn</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cm</span><span class="p">)</span>
		<span class="nx">dialc</span> <span class="o">&lt;-</span> <span class="nx">dialRes</span><span class="p">{</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">err</span><span class="p">}</span>
	<span class="p">}()</span>

	<span class="nx">idleConnCh</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">getIdleConnCh</span><span class="p">(</span><span class="nx">cm</span><span class="p">)</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">dialc</span><span class="p">:</span>
		<span class="c1">// Our dial finished.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">pc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">GotConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">pc</span><span class="p">.</span><span class="nx">alt</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">trace</span><span class="p">.</span><span class="nf">GotConn</span><span class="p">(</span><span class="nx">httptrace</span><span class="p">.</span><span class="nx">GotConnInfo</span><span class="p">{</span><span class="nx">Conn</span><span class="p">:</span> <span class="nx">v</span><span class="p">.</span><span class="nx">pc</span><span class="p">.</span><span class="nx">conn</span><span class="p">})</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="c1">// Our dial failed. See why to return a nicer error
</span><span class="c1"></span>		<span class="c1">// value.
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nf">decHostConnCount</span><span class="p">(</span><span class="nx">cmKey</span><span class="p">)</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">req</span><span class="p">.</span><span class="nx">Cancel</span><span class="p">:</span>
			<span class="c1">// It was an error due to cancelation, so prioritize that
</span><span class="c1"></span>			<span class="c1">// error value. (Issue 16049)
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errRequestCanceledConn</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Done</span><span class="p">():</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Err</span><span class="p">()</span>
		<span class="k">case</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">cancelc</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">errRequestCanceled</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">errRequestCanceledConn</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="c1">// It wasn&#39;t an error due to cancelation, so
</span><span class="c1"></span>			<span class="c1">// return the original error message:
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">err</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">pc</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">idleConnCh</span><span class="p">:</span>
		<span class="c1">// Another request finished first and its net.Conn
</span><span class="c1"></span>		<span class="c1">// became available before our dial. Or somebody
</span><span class="c1"></span>		<span class="c1">// else&#39;s dial that they didn&#39;t use.
</span><span class="c1"></span>		<span class="c1">// But our dial is still going, so give it away
</span><span class="c1"></span>		<span class="c1">// when it finishes:
</span><span class="c1"></span>		<span class="nf">handlePendingDial</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">GotConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">trace</span><span class="p">.</span><span class="nf">GotConn</span><span class="p">(</span><span class="nx">httptrace</span><span class="p">.</span><span class="nx">GotConnInfo</span><span class="p">{</span><span class="nx">Conn</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">Reused</span><span class="p">:</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">isReused</span><span class="p">()})</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">pc</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">req</span><span class="p">.</span><span class="nx">Cancel</span><span class="p">:</span>
		<span class="nf">handlePendingDial</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errRequestCanceledConn</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Done</span><span class="p">():</span>
		<span class="nf">handlePendingDial</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Err</span><span class="p">()</span>
	<span class="k">case</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">cancelc</span><span class="p">:</span>
		<span class="nf">handlePendingDial</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">errRequestCanceled</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">errRequestCanceledConn</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="getidleconn">getIdleConn</h4>
<p>获取空闲的连接</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">getIdleConn</span><span class="p">(</span><span class="nx">cm</span> <span class="nx">connectMethod</span><span class="p">)</span> <span class="p">(</span><span class="nx">pconn</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">,</span> <span class="nx">idleSince</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">key</span><span class="p">()</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">idleMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 从idleConn获取空闲连接
</span><span class="c1"></span>		<span class="nx">pconns</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleConn</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{}</span>
        <span class="p">}</span>
        <span class="c1">// 只有一个空闲连接
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pconns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">pconn</span> <span class="p">=</span> <span class="nx">pconns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="nb">delete</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">idleConn</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 有2个或者2个以上空闲连接，用最近的的
</span><span class="c1"></span>			<span class="nx">pconn</span> <span class="p">=</span> <span class="nx">pconns</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">pconns</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">idleConn</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pconns</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">pconns</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="c1">// 从idle cache中删除该连接
</span><span class="c1"></span>        <span class="nx">t</span><span class="p">.</span><span class="nx">idleLRU</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">pconn</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">isBroken</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// 有小概率，连接已消亡和removeIdleConn
</span><span class="c1"></span>			<span class="c1">// There is a tiny window where this is
</span><span class="c1"></span>			<span class="c1">// possible, between the connecting dying and
</span><span class="c1"></span>			<span class="c1">// the persistConn readLoop calling
</span><span class="c1"></span>			<span class="c1">// Transport.removeIdleConn. Just skip it and
</span><span class="c1"></span>			<span class="c1">// carry on.
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">pconn</span><span class="p">,</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">idleAt</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="getidleconnch">getIdleConnCh</h4>
<p>getIdleConnCh返回一个chan用来接收persistConn，如果没有使用持久连接，会返回nil</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">getIdleConnCh</span><span class="p">(</span><span class="nx">cm</span> <span class="nx">connectMethod</span><span class="p">)</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">persistConn</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">DisableKeepAlives</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">key</span><span class="p">()</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">idleMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">wantIdle</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleConnCh</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">idleConnCh</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">connectMethodKey</span><span class="p">]</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ch</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">idleConnCh</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">idleConnCh</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ch</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ch</span>
<span class="p">}</span>

</code></pre></div><h4 id="dialconn">dialConn</h4>
<p>新建连接</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Transport</span><span class="p">)</span> <span class="nf">dialConn</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">cm</span> <span class="nx">connectMethod</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">persistConn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 新建persistConn
</span><span class="c1"></span>	<span class="nx">pconn</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">persistConn</span><span class="p">{</span>
		<span class="nx">t</span><span class="p">:</span>             <span class="nx">t</span><span class="p">,</span>
		<span class="nx">cacheKey</span><span class="p">:</span>      <span class="nx">cm</span><span class="p">.</span><span class="nf">key</span><span class="p">(),</span>
		<span class="nx">reqch</span><span class="p">:</span>         <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">requestAndChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="nx">writech</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">writeRequest</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="nx">closech</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
		<span class="nx">writeErrCh</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="nx">writeLoopDone</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
	<span class="p">}</span>
	<span class="nx">trace</span> <span class="o">:=</span> <span class="nx">httptrace</span><span class="p">.</span><span class="nf">ContextClientTrace</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="nx">wrapErr</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cm</span><span class="p">.</span><span class="nx">proxyURL</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Return a typed error, per Issue 16997
</span><span class="c1"></span>			<span class="k">return</span> <span class="o">&amp;</span><span class="nx">net</span><span class="p">.</span><span class="nx">OpError</span><span class="p">{</span><span class="nx">Op</span><span class="p">:</span> <span class="s">&#34;proxyconnect&#34;</span><span class="p">,</span> <span class="nx">Net</span><span class="p">:</span> <span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">Err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">scheme</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#34;https&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">DialTLS</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
		<span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">DialTLS</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">addr</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">wrapErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">wrapErr</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;net/http: Transport.DialTLS returned (nil, nil)&#34;</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">tc</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span><span class="p">.(</span><span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Conn</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// Handshake here, in case DialTLS didn&#39;t. TLSNextProto below
</span><span class="c1"></span>			<span class="c1">// depends on it for knowing the connection state.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">TLSHandshakeStart</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">trace</span><span class="p">.</span><span class="nf">TLSHandshakeStart</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tc</span><span class="p">.</span><span class="nf">Handshake</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">go</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">TLSHandshakeDone</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">trace</span><span class="p">.</span><span class="nf">TLSHandshakeDone</span><span class="p">(</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span><span class="p">{},</span> <span class="nx">err</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
			<span class="p">}</span>
			<span class="nx">cs</span> <span class="o">:=</span> <span class="nx">tc</span><span class="p">.</span><span class="nf">ConnectionState</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">TLSHandshakeDone</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">trace</span><span class="p">.</span><span class="nf">TLSHandshakeDone</span><span class="p">(</span><span class="nx">cs</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">pconn</span><span class="p">.</span><span class="nx">tlsState</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">cs</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 新建连接
</span><span class="c1"></span>		<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">dial</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">addr</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">wrapErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span> <span class="p">=</span> <span class="nx">conn</span>
		<span class="k">if</span> <span class="nx">cm</span><span class="p">.</span><span class="nf">scheme</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#34;https&#34;</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">firstTLSHost</span> <span class="kt">string</span>
			<span class="k">if</span> <span class="nx">firstTLSHost</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="nx">cm</span><span class="p">.</span><span class="nf">addr</span><span class="p">());</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">wrapErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">addTLS</span><span class="p">(</span><span class="nx">firstTLSHost</span><span class="p">,</span> <span class="nx">trace</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">wrapErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Proxy setup.
</span><span class="c1"></span>	<span class="c1">// 忽略...
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">MaxConnsPerHost</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 封装连接·
</span><span class="c1"></span>		<span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">connCloseListener</span><span class="p">{</span><span class="nx">Conn</span><span class="p">:</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">t</span><span class="p">:</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">cmKey</span><span class="p">:</span> <span class="nx">pconn</span><span class="p">.</span><span class="nx">cacheKey</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">pconn</span><span class="p">.</span><span class="nx">br</span> <span class="p">=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">pconn</span><span class="p">)</span>
    <span class="nx">pconn</span><span class="p">.</span><span class="nx">bw</span> <span class="p">=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewWriter</span><span class="p">(</span><span class="nx">persistConnWriter</span><span class="p">{</span><span class="nx">pconn</span><span class="p">})</span>
    <span class="c1">// 开启两个loop
</span><span class="c1"></span>	<span class="k">go</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">readLoop</span><span class="p">()</span>
	<span class="k">go</span> <span class="nx">pconn</span><span class="p">.</span><span class="nf">writeLoop</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">pconn</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><h4 id="persistconnroundtrip">persistConn.roundTrip</h4>
<p>roundTrip处理往返的数据，和readLoop、writeLoop进行交互</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="nf">roundTrip</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">transportRequest</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">testHookEnterRoundTrip</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">replaceReqCanceler</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">cancelRequest</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">putOrCloseIdleConn</span><span class="p">(</span><span class="nx">pc</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errRequestCanceled</span>
	<span class="p">}</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">numExpectedResponses</span><span class="o">++</span>
	<span class="nx">headerFn</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">mutateHeaderFunc</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">headerFn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">headerFn</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nf">extraHeaders</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="c1">// Ask for a compressed version if the caller didn&#39;t set their
</span><span class="c1"></span>	<span class="c1">// own value for Accept-Encoding. We only attempt to
</span><span class="c1"></span>	<span class="c1">// uncompress the gzip stream if we were the layer that
</span><span class="c1"></span>	<span class="c1">// requested it.
</span><span class="c1"></span>	<span class="nx">requestedGzip</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">DisableCompression</span> <span class="o">&amp;&amp;</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Accept-Encoding&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Range&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Method</span> <span class="o">!=</span> <span class="s">&#34;HEAD&#34;</span> <span class="p">{</span>
		<span class="c1">// Request gzip only, not deflate. Deflate is ambiguous and
</span><span class="c1"></span>		<span class="c1">// not as universally supported anyway.
</span><span class="c1"></span>		<span class="c1">// See: https://zlib.net/zlib_faq.html#faq39
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Note that we don&#39;t request this for HEAD requests,
</span><span class="c1"></span>		<span class="c1">// due to a bug in nginx:
</span><span class="c1"></span>		<span class="c1">//   https://trac.nginx.org/nginx/ticket/358
</span><span class="c1"></span>		<span class="c1">//   https://golang.org/issue/5522
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// We don&#39;t request gzip if the request is for a range, since
</span><span class="c1"></span>		<span class="c1">// auto-decoding a portion of a gzipped document will just fail
</span><span class="c1"></span>		<span class="c1">// anyway. See https://golang.org/issue/8923
</span><span class="c1"></span>		<span class="nx">requestedGzip</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">extraHeaders</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Accept-Encoding&#34;</span><span class="p">,</span> <span class="s">&#34;gzip&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">continueCh</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nf">ProtoAtLeast</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Body</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nf">expectsContinue</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">continueCh</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">DisableKeepAlives</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">req</span><span class="p">.</span><span class="nf">wantsClose</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">extraHeaders</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Connection&#34;</span><span class="p">,</span> <span class="s">&#34;close&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">gone</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">gone</span><span class="p">)</span>

	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="kd">const</span> <span class="nx">debugRoundTrip</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="c1">// Write the request concurrently with waiting for a response,
</span><span class="c1"></span>	<span class="c1">// in case the server decides to reply before reading our full
</span><span class="c1"></span>	<span class="c1">// request body.
</span><span class="c1"></span>	<span class="nx">startBytesWritten</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">nwrite</span>
	<span class="nx">writeErrCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 将请求写入writech，有writeLoop
</span><span class="c1"></span>	<span class="nx">pc</span><span class="p">.</span><span class="nx">writech</span> <span class="o">&lt;-</span> <span class="nx">writeRequest</span><span class="p">{</span><span class="nx">req</span><span class="p">,</span> <span class="nx">writeErrCh</span><span class="p">,</span> <span class="nx">continueCh</span><span class="p">}</span>

	<span class="nx">resc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">responseAndError</span><span class="p">)</span>
	<span class="c1">// 写入reqch， 由readLoop读取
</span><span class="c1"></span>	<span class="nx">pc</span><span class="p">.</span><span class="nx">reqch</span> <span class="o">&lt;-</span> <span class="nx">requestAndChan</span><span class="p">{</span>
		<span class="nx">req</span><span class="p">:</span>        <span class="nx">req</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span>
		<span class="nx">ch</span><span class="p">:</span>         <span class="nx">resc</span><span class="p">,</span>
		<span class="nx">addedGzip</span><span class="p">:</span>  <span class="nx">requestedGzip</span><span class="p">,</span>
		<span class="nx">continueCh</span><span class="p">:</span> <span class="nx">continueCh</span><span class="p">,</span>
		<span class="nx">callerGone</span><span class="p">:</span> <span class="nx">gone</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">respHeaderTimer</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
	<span class="nx">cancelChan</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Cancel</span>
	<span class="nx">ctxDoneChan</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Done</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nf">testHookWaitResLoop</span><span class="p">()</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">writeErrCh</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">debugRoundTrip</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;writeErrCh resv: %T/%#v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">pc</span><span class="p">.</span><span class="nb">close</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;write error: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">))</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">mapRoundTripError</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">startBytesWritten</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nx">ResponseHeaderTimeout</span><span class="p">;</span> <span class="nx">d</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">debugRoundTrip</span> <span class="p">{</span>
					<span class="nx">req</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;starting timer for %v&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
				<span class="k">defer</span> <span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span> <span class="c1">// prevent leaks
</span><span class="c1"></span>				<span class="nx">respHeaderTimer</span> <span class="p">=</span> <span class="nx">timer</span><span class="p">.</span><span class="nx">C</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">closech</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">debugRoundTrip</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;closech recv: %T %#v&#34;</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">closed</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">mapRoundTripError</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">startBytesWritten</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">respHeaderTimer</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">debugRoundTrip</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;timeout waiting for response headers.&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nb">close</span><span class="p">(</span><span class="nx">errTimeout</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errTimeout</span>
		<span class="k">case</span> <span class="nx">re</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">resc</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nx">res</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
				<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;internal error: exactly one of res or err should be set; nil=%v&#34;</span><span class="p">,</span> <span class="nx">re</span><span class="p">.</span><span class="nx">res</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">debugRoundTrip</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;resc recv: %p, %T/%#v&#34;</span><span class="p">,</span> <span class="nx">re</span><span class="p">.</span><span class="nx">res</span><span class="p">,</span> <span class="nx">re</span><span class="p">.</span><span class="nx">err</span><span class="p">,</span> <span class="nx">re</span><span class="p">.</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">re</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">mapRoundTripError</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">startBytesWritten</span><span class="p">,</span> <span class="nx">re</span><span class="p">.</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">re</span><span class="p">.</span><span class="nx">res</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">cancelChan</span><span class="p">:</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">CancelRequest</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span>
			<span class="nx">cancelChan</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctxDoneChan</span><span class="p">:</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">cancelRequest</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Err</span><span class="p">())</span>
			<span class="nx">cancelChan</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">ctxDoneChan</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="readloop">readLoop</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="nf">readLoop</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">closeErr</span> <span class="o">:=</span> <span class="nx">errReadLoopExiting</span> <span class="c1">// default value, if not changed below
</span><span class="c1"></span>	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nb">close</span><span class="p">(</span><span class="nx">closeErr</span><span class="p">)</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">removeIdleConn</span><span class="p">(</span><span class="nx">pc</span><span class="p">)</span>
	<span class="p">}()</span>

    <span class="c1">// 将空闲连接放入到idleConn
</span><span class="c1"></span>	<span class="nx">tryPutIdleConn</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">trace</span> <span class="o">*</span><span class="nx">httptrace</span><span class="p">.</span><span class="nx">ClientTrace</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">tryPutIdleConn</span><span class="p">(</span><span class="nx">pc</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">closeErr</span> <span class="p">=</span> <span class="nx">err</span>
			<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">PutIdleConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">errKeepAlivesDisabled</span> <span class="p">{</span>
				<span class="nx">trace</span><span class="p">.</span><span class="nf">PutIdleConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">PutIdleConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">trace</span><span class="p">.</span><span class="nf">PutIdleConn</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// eofc is used to block caller goroutines reading from Response.Body
</span><span class="c1"></span>	<span class="c1">// at EOF until this goroutines has (potentially) added the connection
</span><span class="c1"></span>	<span class="c1">// back to the idle pool.
</span><span class="c1"></span>	<span class="c1">// eofc是个无缓存的chan
</span><span class="c1"></span>	<span class="nx">eofc</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">eofc</span><span class="p">)</span> <span class="c1">// unblock reader on errors
</span><span class="c1"></span>
	<span class="c1">// Read this once, before loop starts. (to avoid races in tests)
</span><span class="c1"></span>	<span class="nx">testHookMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">testHookReadLoopBeforeNextRead</span> <span class="o">:=</span> <span class="nx">testHookReadLoopBeforeNextRead</span>
	<span class="nx">testHookMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="nx">alive</span> <span class="o">:=</span> <span class="kc">true</span>
	<span class="k">for</span> <span class="nx">alive</span> <span class="p">{</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">readLimit</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">maxHeaderResponseSize</span><span class="p">()</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">br</span><span class="p">.</span><span class="nf">Peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

		<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">numExpectedResponses</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nf">readLoopPeekFailLocked</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

		<span class="nx">rc</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">reqch</span>
		<span class="nx">trace</span> <span class="o">:=</span> <span class="nx">httptrace</span><span class="p">.</span><span class="nf">ContextClientTrace</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">())</span>

		<span class="kd">var</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">readResponse</span><span class="p">(</span><span class="nx">rc</span><span class="p">,</span> <span class="nx">trace</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">transportReadFromServerError</span><span class="p">{</span><span class="nx">err</span><span class="p">}</span>
			<span class="nx">closeErr</span> <span class="p">=</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">readLimit</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;net/http: server response headers exceeded %d bytes; aborted&#34;</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">maxHeaderResponseSize</span><span class="p">())</span>
			<span class="p">}</span>

			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">responseAndError</span><span class="p">{</span><span class="nx">err</span><span class="p">:</span> <span class="nx">err</span><span class="p">}:</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">callerGone</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">readLimit</span> <span class="p">=</span> <span class="nx">maxInt64</span> <span class="c1">// effictively no limit for response bodies
</span><span class="c1"></span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">numExpectedResponses</span><span class="o">--</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

		<span class="nx">bodyWritable</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nf">bodyIsWritable</span><span class="p">()</span>
		<span class="nx">hasBody</span> <span class="o">:=</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">Method</span> <span class="o">!=</span> <span class="s">&#34;HEAD&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">!=</span> <span class="mi">0</span>

		<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Close</span> <span class="o">||</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">Close</span> <span class="o">||</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">&lt;=</span> <span class="mi">199</span> <span class="o">||</span> <span class="nx">bodyWritable</span> <span class="p">{</span>
			<span class="c1">// Don&#39;t do keep-alive on error if either party requested a close
</span><span class="c1"></span>			<span class="c1">// or we get an unexpected informational (1xx) response.
</span><span class="c1"></span>			<span class="c1">// StatusCode 100 is already handled above.
</span><span class="c1"></span>			<span class="nx">alive</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">!</span><span class="nx">hasBody</span> <span class="o">||</span> <span class="nx">bodyWritable</span> <span class="p">{</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>

			<span class="c1">// Put the idle conn back into the pool before we send the response
</span><span class="c1"></span>			<span class="c1">// so if they process it quickly and make another request, they&#39;ll
</span><span class="c1"></span>			<span class="c1">// get this same conn. But we use the unbuffered channel &#39;rc&#39;
</span><span class="c1"></span>			<span class="c1">// to guarantee that persistConn.roundTrip got out of its select
</span><span class="c1"></span>			<span class="c1">// potentially waiting for this persistConn to close.
</span><span class="c1"></span>			<span class="c1">// but after
</span><span class="c1"></span>			<span class="nx">alive</span> <span class="p">=</span> <span class="nx">alive</span> <span class="o">&amp;&amp;</span>
				<span class="p">!</span><span class="nx">pc</span><span class="p">.</span><span class="nx">sawEOF</span> <span class="o">&amp;&amp;</span>
				<span class="nx">pc</span><span class="p">.</span><span class="nf">wroteRequest</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
				<span class="nf">tryPutIdleConn</span><span class="p">(</span><span class="nx">trace</span><span class="p">)</span>

			<span class="k">if</span> <span class="nx">bodyWritable</span> <span class="p">{</span>
				<span class="nx">closeErr</span> <span class="p">=</span> <span class="nx">errCallerOwnsConn</span>
			<span class="p">}</span>

			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">responseAndError</span><span class="p">{</span><span class="nx">res</span><span class="p">:</span> <span class="nx">resp</span><span class="p">}:</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">callerGone</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="c1">// Now that they&#39;ve read from the unbuffered channel, they&#39;re safely
</span><span class="c1"></span>			<span class="c1">// out of the select that also waits on this goroutine to die, so
</span><span class="c1"></span>			<span class="c1">// we&#39;re allowed to exit now if needed (if alive is false)
</span><span class="c1"></span>			<span class="nf">testHookReadLoopBeforeNextRead</span><span class="p">()</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">waitForBodyRead</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="nx">body</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">bodyEOFSignal</span><span class="p">{</span>
			<span class="nx">body</span><span class="p">:</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span>
			<span class="nx">earlyCloseFn</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
				<span class="nx">waitForBodyRead</span> <span class="o">&lt;-</span> <span class="kc">false</span>
				<span class="o">&lt;-</span><span class="nx">eofc</span> <span class="c1">// will be closed by deferred call at the end of the function
</span><span class="c1"></span>				<span class="k">return</span> <span class="kc">nil</span>

			<span class="p">},</span>
			<span class="nx">fn</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
				<span class="nx">isEOF</span> <span class="o">:=</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span>
				<span class="nx">waitForBodyRead</span> <span class="o">&lt;-</span> <span class="nx">isEOF</span>
				<span class="k">if</span> <span class="nx">isEOF</span> <span class="p">{</span>
					<span class="o">&lt;-</span><span class="nx">eofc</span> <span class="c1">// see comment above eofc declaration
</span><span class="c1"></span>				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">cerr</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">canceled</span><span class="p">();</span> <span class="nx">cerr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
						<span class="k">return</span> <span class="nx">cerr</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">},</span>
		<span class="p">}</span>

		<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="nx">body</span>
		<span class="k">if</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">addedGzip</span> <span class="o">&amp;&amp;</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">EqualFold</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Content-Encoding&#34;</span><span class="p">),</span> <span class="s">&#34;gzip&#34;</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">gzipReader</span><span class="p">{</span><span class="nx">body</span><span class="p">:</span> <span class="nx">body</span><span class="p">}</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Del</span><span class="p">(</span><span class="s">&#34;Content-Encoding&#34;</span><span class="p">)</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Del</span><span class="p">(</span><span class="s">&#34;Content-Length&#34;</span><span class="p">)</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">Uncompressed</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>

		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">responseAndError</span><span class="p">{</span><span class="nx">res</span><span class="p">:</span> <span class="nx">resp</span><span class="p">}:</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">callerGone</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// Before looping back to the top of this function and peeking on
</span><span class="c1"></span>		<span class="c1">// the bufio.Reader, wait for the caller goroutine to finish
</span><span class="c1"></span>		<span class="c1">// reading the response body. (or for cancelation or death)
</span><span class="c1"></span>		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">bodyEOF</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">waitForBodyRead</span><span class="p">:</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">setReqCanceler</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// before pc might return to idle pool
</span><span class="c1"></span>			<span class="nx">alive</span> <span class="p">=</span> <span class="nx">alive</span> <span class="o">&amp;&amp;</span>
				<span class="nx">bodyEOF</span> <span class="o">&amp;&amp;</span>
				<span class="p">!</span><span class="nx">pc</span><span class="p">.</span><span class="nx">sawEOF</span> <span class="o">&amp;&amp;</span>
				<span class="nx">pc</span><span class="p">.</span><span class="nf">wroteRequest</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
				<span class="nf">tryPutIdleConn</span><span class="p">(</span><span class="nx">trace</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">bodyEOF</span> <span class="p">{</span>
				<span class="nx">eofc</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">Cancel</span><span class="p">:</span>
			<span class="nx">alive</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">CancelRequest</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">alive</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">cancelRequest</span><span class="p">(</span><span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">,</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Err</span><span class="p">())</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">closech</span><span class="p">:</span>
			<span class="nx">alive</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="nf">testHookReadLoopBeforeNextRead</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="writeloop">writeLoop</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="nf">writeLoop</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">writeLoopDone</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">wr</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">writech</span><span class="p">:</span>
			<span class="nx">startBytesWritten</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">nwrite</span>
			<span class="nx">err</span> <span class="o">:=</span> <span class="nx">wr</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">bw</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">isProxy</span><span class="p">,</span> <span class="nx">wr</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">extra</span><span class="p">,</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">waitForContinue</span><span class="p">(</span><span class="nx">wr</span><span class="p">.</span><span class="nx">continueCh</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">bre</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">requestBodyReadError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">bre</span><span class="p">.</span><span class="kt">error</span>
				<span class="c1">// Errors reading from the user&#39;s
</span><span class="c1"></span>				<span class="c1">// Request.Body are high priority.
</span><span class="c1"></span>				<span class="c1">// Set it here before sending on the
</span><span class="c1"></span>				<span class="c1">// channels below or calling
</span><span class="c1"></span>				<span class="c1">// pc.close() which tears town
</span><span class="c1"></span>				<span class="c1">// connections and causes other
</span><span class="c1"></span>				<span class="c1">// errors.
</span><span class="c1"></span>				<span class="nx">wr</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nf">setError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">bw</span><span class="p">.</span><span class="nf">Flush</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">wr</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">nwrite</span> <span class="o">==</span> <span class="nx">startBytesWritten</span> <span class="p">{</span>
					<span class="nx">err</span> <span class="p">=</span> <span class="nx">nothingWrittenError</span><span class="p">{</span><span class="nx">err</span><span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">pc</span><span class="p">.</span><span class="nx">writeErrCh</span> <span class="o">&lt;-</span> <span class="nx">err</span> <span class="c1">// to the body reader, which might recycle us
</span><span class="c1"></span>			<span class="nx">wr</span><span class="p">.</span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">err</span>         <span class="c1">// to the roundTrip function
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">pc</span><span class="p">.</span><span class="nb">close</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">pc</span><span class="p">.</span><span class="nx">closech</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="respbody">resp.Body</h3>
<p>我们在读取response body返回的时候，要求我们执行下resp.Body.Close(), 为什么要这么做？ 我们看下对应的Body.Close都做了些什么？</p>
<h4 id="close">Close</h4>
<p>Body.Close</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">es</span> <span class="o">*</span><span class="nx">bodyEOFSignal</span><span class="p">)</span> <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">es</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">es</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">es</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">es</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="c1">// 关闭
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">es</span><span class="p">.</span><span class="nx">earlyCloseFn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">es</span><span class="p">.</span><span class="nx">rerr</span> <span class="o">!=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">es</span><span class="p">.</span><span class="nf">earlyCloseFn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">es</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">es</span><span class="p">.</span><span class="nf">condfn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="earlyclosefn">earlyCloseFn</h4>
<p>earlyCloseFn 就是这段，当调用Body.Close后readLoop就会执行earlyCloseFn</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">		<span class="nx">body</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">bodyEOFSignal</span><span class="p">{</span>
			<span class="nx">body</span><span class="p">:</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span>
			<span class="nx">earlyCloseFn</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
				<span class="nx">waitForBodyRead</span> <span class="o">&lt;-</span> <span class="kc">false</span>
				<span class="o">&lt;-</span><span class="nx">eofc</span> <span class="c1">// will be closed by deferred call at the end of the function
</span><span class="c1"></span>				<span class="k">return</span> <span class="kc">nil</span>

			<span class="p">},</span>
			<span class="nx">fn</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
				<span class="nx">isEOF</span> <span class="o">:=</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span>
				<span class="nx">waitForBodyRead</span> <span class="o">&lt;-</span> <span class="nx">isEOF</span>
				<span class="k">if</span> <span class="nx">isEOF</span> <span class="p">{</span>
					<span class="o">&lt;-</span><span class="nx">eofc</span> <span class="c1">// see comment above eofc declaration
</span><span class="c1"></span>				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">cerr</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nf">canceled</span><span class="p">();</span> <span class="nx">cerr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
						<span class="k">return</span> <span class="nx">cerr</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">},</span>
		<span class="p">}</span>
</code></pre></div><h4 id="readloop-1">readLoop</h4>
<p>readLoop退出前会执行tryPutIdleConn将空闲连接放入到连接池，然后执行defer close</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nb">close</span><span class="p">(</span><span class="nx">closeErr</span><span class="p">)</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">removeIdleConn</span><span class="p">(</span><span class="nx">pc</span><span class="p">)</span>
	<span class="p">}()</span>

    <span class="nx">tryPutIdleConn</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">trace</span> <span class="o">*</span><span class="nx">httptrace</span><span class="p">.</span><span class="nx">ClientTrace</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">t</span><span class="p">.</span><span class="nf">tryPutIdleConn</span><span class="p">(</span><span class="nx">pc</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">closeErr</span> <span class="p">=</span> <span class="nx">err</span>
			<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">PutIdleConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">errKeepAlivesDisabled</span> <span class="p">{</span>
				<span class="nx">trace</span><span class="p">.</span><span class="nf">PutIdleConn</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">trace</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">PutIdleConn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">trace</span><span class="p">.</span><span class="nf">PutIdleConn</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
</code></pre></div><h4 id="close-1">close</h4>
<p>close 主要会去close pc.closech， pc.closech 关闭后，会将writeLoop释放掉</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="nb">close</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nf">closeLocked</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pc</span> <span class="o">*</span><span class="nx">persistConn</span><span class="p">)</span> <span class="nf">closeLocked</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;nil error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">broken</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">pc</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="nx">err</span>
		<span class="k">if</span> <span class="nx">pc</span><span class="p">.</span><span class="nx">alt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Do nothing; can only get here via getConn&#39;s
</span><span class="c1"></span>			<span class="c1">// handlePendingDial&#39;s putOrCloseIdleConn when
</span><span class="c1"></span>			<span class="c1">// it turns out the abandoned connection in
</span><span class="c1"></span>			<span class="c1">// flight ended up negotiating an alternate
</span><span class="c1"></span>			<span class="c1">// protocol. We don&#39;t use the connection
</span><span class="c1"></span>			<span class="c1">// freelist for http2. That&#39;s done by the
</span><span class="c1"></span>			<span class="c1">// alternate protocol&#39;s RoundTripper.
</span><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">errCallerOwnsConn</span> <span class="p">{</span>
				<span class="nx">pc</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="nb">close</span><span class="p">(</span><span class="nx">pc</span><span class="p">.</span><span class="nx">closech</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">pc</span><span class="p">.</span><span class="nx">mutateHeaderFunc</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>这样当Close完毕后，readLoop和writeLoop都会关闭，如果我们读取了resp.Body 不去关闭，一是我们的持久连接不会复用；二是内存开销会变大(不断派生readLoop,writeLoop)，所以为了还是要关闭Body.Close</p>
]]></content>
		</item>
		
		<item>
			<title>Go-深入理解内存分配</title>
			<link>https://leonzyang.github.io/posts/malloc/</link>
			<pubDate>Sun, 27 Jun 2021 09:32:23 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/malloc/</guid>
			<description>深入理解内存分配 CPU缓存 CPU的发展的速度远快于内存的发展，CPU的处理速度也比内存访问速度快很多。这样很多情况下，CPU必须要等内存的相应，为了应对这种情况，CPU多谢缓存就出现了。
计算机内存金字塔图 缓存大小L1&amp;lt;L2&amp;lt;L3, 速度L1&amp;gt;L2&amp;gt;L3， L1和L2通常用在单核中，L3则用来多核中。CPU缓存的命中率代表了CPU缓存复用的情况。 CPU读取数据是从先从缓存中寻找，如果找到就立即返回给CPU处理，如果没有找到，就从相对慢的速度中读取并返回给CPU处理，同时把这个数据加入缓存中。
程序内存 unix系统进程内存占用示意图  text段在内存映射中是只读的，data和bss是可读可写 data和bss属于静态内存分配。data是初始化过的，bss是未出华的  TCmalloc TCmalloc全称Thread-Cacheing Malloc, 即线程缓存的malloc，是由Google开发的内存分配器(https://gperftools.github.io/gperftools/tcmalloc.html)。
TCmalloc通过多级缓存，降低了多线程中锁竞争的情况，通过不同的sizeclass，空间利用率高，碎片少。
如果想了解细节可以看下：
 tcmalloc浅析 TCMalloc解密  Go内存分配 Golang内存分配最开始也是TCmalloc的，后来再次基础上也改动了许多，包括内存池、预分配和延迟分配等。
介绍 Page: Golang里面的Page大小是8KB（x64操作系统页一般是4KB），一般是操作系统页的几倍 maxTinySize： 小于16Byte tinySizeClass: 16B &amp;lt; size &amp;lt;= 32KB maxSmallSize： size &amp;gt; 32K Spans: 存放mspan的指针，指针大小是8byte，每个指针指向arena的一个page bitmap:用于保存arena对应某个地址是否存在对象，以及对象是否被GC扫描过 arena：由一堆page组成 object:
从别的地方引用的一张内存管理图 go内存结构 总共分为3个区域，spans，bitmap和areaa
mspan 每个mspan对一个一个page bitmap 每个bitmap对应arena 4个指针的内存，相当于2bit对应1个指针大小的内存，两个2bit分别代表是否指针和是否应该扫描 size class 每个mspan会按照SizeClass的大小分配成若干的object，每个object可以存储一个对象。并且使用allocBits表示object使用情况，mspan会按照上面的分配原则给object分配对象
// class bytes/obj bytes/span objects tail waste max waste // 1 8 8192 1024 0 87.</description>
			<content type="html"><![CDATA[<h2 id="深入理解内存分配">深入理解内存分配</h2>
<h3 id="cpu缓存">CPU缓存</h3>
<p>CPU的发展的速度远快于内存的发展，CPU的处理速度也比内存访问速度快很多。这样很多情况下，CPU必须要等内存的相应，为了应对这种情况，CPU多谢缓存就出现了。</p>
<p>计算机内存金字塔图
<img src="/posts/images/mem_line.png" alt="mem_line"></p>
<p><img src="/posts/images/cpu.png" alt="cpu">
缓存大小L1&lt;L2&lt;L3, 速度L1&gt;L2&gt;L3， L1和L2通常用在单核中，L3则用来多核中。CPU缓存的命中率代表了CPU缓存复用的情况。 CPU读取数据是从先从缓存中寻找，如果找到就立即返回给CPU处理，如果没有找到，就从相对慢的速度中读取并返回给CPU处理，同时把这个数据加入缓存中。</p>
<h3 id="程序内存">程序内存</h3>
<p>unix系统进程内存占用示意图
<img src="/posts/images/unix_mem.png" alt="mem1"></p>
<ul>
<li>text段在内存映射中是只读的，data和bss是可读可写</li>
<li>data和bss属于静态内存分配。data是初始化过的，bss是未出华的</li>
</ul>
<h3 id="tcmalloc">TCmalloc</h3>
<p>TCmalloc全称Thread-Cacheing Malloc, 即线程缓存的malloc，是由Google开发的内存分配器(<a href="https://gperftools.github.io/gperftools/tcmalloc.html">https://gperftools.github.io/gperftools/tcmalloc.html</a>)。</p>
<p>TCmalloc通过多级缓存，降低了多线程中锁竞争的情况，通过不同的sizeclass，空间利用率高，碎片少。</p>
<p><img src="/posts/images/tcmalloc.png" alt="tcmalloc"></p>
<p>如果想了解细节可以看下：</p>
<ul>
<li><a href="https://yq.aliyun.com/articles/6045">tcmalloc浅析</a></li>
<li><a href="https://wallenwang.com/2018/11/tcmalloc/">TCMalloc解密</a></li>
</ul>
<h3 id="go内存分配">Go内存分配</h3>
<p>Golang内存分配最开始也是TCmalloc的，后来再次基础上也改动了许多，包括内存池、预分配和延迟分配等。</p>
<h4 id="介绍">介绍</h4>
<p>Page: Golang里面的Page大小是8KB（x64操作系统页一般是4KB），一般是操作系统页的几倍
maxTinySize： 小于16Byte
tinySizeClass: 16B &lt; size &lt;= 32KB
maxSmallSize： size &gt; 32K
Spans: 存放mspan的指针，指针大小是8byte，每个指针指向arena的一个page
bitmap:用于保存arena对应某个地址是否存在对象，以及对象是否被GC扫描过
arena：由一堆page组成
object:</p>
<p>从别的地方引用的一张内存管理图
<img src="/posts/images/mem.png" alt="mem"></p>
<h4 id="go内存结构">go内存结构</h4>
<p><img src="/posts/images/mheap.png" alt="heap">
总共分为3个区域，spans，bitmap和areaa</p>
<h5 id="mspan">mspan</h5>
<p>每个mspan对一个一个page
<img src="/posts/images/spans.png" alt="spans"></p>
<h5 id="bitmap">bitmap</h5>
<p>每个bitmap对应arena 4个指针的内存，相当于2bit对应1个指针大小的内存，两个2bit分别代表是否指针和是否应该扫描
<img src="/posts/images/bitmap.png" alt="bitmap"></p>
<h4 id="size-class">size class</h4>
<p>每个mspan会按照SizeClass的大小分配成若干的object，每个object可以存储一个对象。并且使用allocBits表示object使用情况，mspan会按照上面的分配原则给object分配对象</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// class  bytes/obj  bytes/span  objects  tail waste  max waste
</span><span class="c1">//     1          8        8192     1024           0     87.50%
</span><span class="c1">//     2         16        8192      512           0     43.75%
</span><span class="c1">//     3         32        8192      256           0     46.88%
</span><span class="c1">//     4         48        8192      170          32     31.52%
</span><span class="c1">//     5         64        8192      128           0     23.44%
</span><span class="c1">//     6         80        8192      102          32     19.07%
</span><span class="c1">//     7         96        8192       85          32     15.95%
</span><span class="c1">//     8        112        8192       73          16     13.56%
</span><span class="c1">//     9        128        8192       64           0     11.72%
</span><span class="c1">//    10        144        8192       56         128     11.82%
</span><span class="c1">//    11        160        8192       51          32      9.73%
</span><span class="c1">//    12        176        8192       46          96      9.59%
</span><span class="c1">//    13        192        8192       42         128      9.25%
</span><span class="c1">//    14        208        8192       39          80      8.12%
</span><span class="c1">//    15        224        8192       36         128      8.15%
</span><span class="c1">//    16        240        8192       34          32      6.62%
</span><span class="c1">//    17        256        8192       32           0      5.86%
</span><span class="c1">//    18        288        8192       28         128     12.16%
</span><span class="c1">//    19        320        8192       25         192     11.80%
</span><span class="c1">//    20        352        8192       23          96      9.88%
</span><span class="c1">//    21        384        8192       21         128      9.51%
</span><span class="c1">//    22        416        8192       19         288     10.71%
</span><span class="c1">//    23        448        8192       18         128      8.37%
</span><span class="c1">//    24        480        8192       17          32      6.82%
</span><span class="c1">//    25        512        8192       16           0      6.05%
</span><span class="c1">//    26        576        8192       14         128     12.33%
</span><span class="c1">//    27        640        8192       12         512     15.48%
</span><span class="c1">//    28        704        8192       11         448     13.93%
</span><span class="c1">//    29        768        8192       10         512     13.94%
</span><span class="c1">//    30        896        8192        9         128     15.52%
</span><span class="c1">//    31       1024        8192        8           0     12.40%
</span><span class="c1">//    32       1152        8192        7         128     12.41%
</span><span class="c1">//    33       1280        8192        6         512     15.55%
</span><span class="c1">//    34       1408       16384       11         896     14.00%
</span><span class="c1">//    35       1536        8192        5         512     14.00%
</span><span class="c1">//    36       1792       16384        9         256     15.57%
</span><span class="c1">//    37       2048        8192        4           0     12.45%
</span><span class="c1">//    38       2304       16384        7         256     12.46%
</span><span class="c1">//    39       2688        8192        3         128     15.59%
</span><span class="c1">//    40       3072       24576        8           0     12.47%
</span><span class="c1">//    41       3200       16384        5         384      6.22%
</span><span class="c1">//    42       3456       24576        7         384      8.83%
</span><span class="c1">//    43       4096        8192        2           0     15.60%
</span><span class="c1">//    44       4864       24576        5         256     16.65%
</span><span class="c1">//    45       5376       16384        3         256     10.92%
</span><span class="c1">//    46       6144       24576        4           0     12.48%
</span><span class="c1">//    47       6528       32768        5         128      6.23%
</span><span class="c1">//    48       6784       40960        6         256      4.36%
</span><span class="c1">//    49       6912       49152        7         768      3.37%
</span><span class="c1">//    50       8192        8192        1           0     15.61%
</span><span class="c1">//    51       9472       57344        6         512     14.28%
</span><span class="c1">//    52       9728       49152        5         512      3.64%
</span><span class="c1">//    53      10240       40960        4           0      4.99%
</span><span class="c1">//    54      10880       32768        3         128      6.24%
</span><span class="c1">//    55      12288       24576        2           0     11.45%
</span><span class="c1">//    56      13568       40960        3         256      9.99%
</span><span class="c1">//    57      14336       57344        4           0      5.35%
</span><span class="c1">//    58      16384       16384        1           0     12.49%
</span><span class="c1">//    59      18432       73728        4           0     11.11%
</span><span class="c1">//    60      19072       57344        3         128      3.57%
</span><span class="c1">//    61      20480       40960        2           0      6.87%
</span><span class="c1">//    62      21760       65536        3         256      6.25%
</span><span class="c1">//    63      24576       24576        1           0     11.45%
</span><span class="c1">//    64      27264       81920        3         128     10.00%
</span><span class="c1">//    65      28672       57344        2           0      4.91%
</span><span class="c1">//    66      32768       32768        1           0     12.50%
</span></code></pre></div><p>class: class ID, 每个span都有class ID
bytes/obj: 对象的字节数
bytes/span: 每个span占用的字节数
objects: 每个span可以分配的对象 (bytes/span) / (bytes/obj)
waste bytes: 每个span产生的碎片， (bytes/span) % (bytes/obj)</p>
<p>这么做有什么好处呢？ 可以看下这个图
<img src="/posts/images/mem_used.png" alt="mem_used">
如果p2释放掉后，是不是就会造成有很多内存碎片？</p>
<h5 id="span-class">span class</h5>
<p>每个Size Class对应两个mspan，一个是含指针对象，一个是不含指针对象的，主要是方便GC</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">Size_Class</span> <span class="p">=</span> <span class="nx">Span_class</span> <span class="o">/</span> <span class="mi">2</span>
</code></pre></div><h4 id="mspan-1">mspan</h4>
<p>mspan是个双向链表，是go里面最小的管理单元，是由一堆Pages组成的连续内存</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mspan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// next span in list, or nil if none
</span><span class="c1"></span>	<span class="nx">prev</span> <span class="o">*</span><span class="nx">mspan</span>     <span class="c1">// previous span in list, or nil if none
</span><span class="c1"></span>	<span class="nx">list</span> <span class="o">*</span><span class="nx">mSpanList</span> <span class="c1">// For debugging. TODO: Remove.
</span><span class="c1"></span>
	<span class="nx">startAddr</span> <span class="kt">uintptr</span> <span class="c1">// span其实地址
</span><span class="c1"></span>	<span class="nx">npages</span>    <span class="kt">uintptr</span> <span class="c1">// 页数
</span><span class="c1"></span>
	<span class="nx">manualFreeList</span> <span class="nx">gclinkptr</span> <span class="c1">// list of free objects in mSpanManual spans
</span><span class="c1"></span>
	<span class="c1">// 定位下一个空闲的object， 范围在0~nelems
</span><span class="c1"></span>	<span class="nx">freeindex</span> <span class="kt">uintptr</span>
	<span class="c1">// object的数量
</span><span class="c1"></span>	<span class="nx">nelems</span> <span class="kt">uintptr</span> <span class="c1">// number of object in the span.
</span><span class="c1"></span>
	<span class="c1">// 缓存freeindex开始的bitmap， allocCache是allocBits的补码
</span><span class="c1"></span>	<span class="nx">allocCache</span> <span class="kt">uint64</span>

	<span class="c1">// 分配位图，每一位代表是否已分配
</span><span class="c1"></span>	<span class="nx">allocBits</span>  <span class="o">*</span><span class="nx">gcBits</span>

	<span class="c1">// 用于在gc的时候标记哪些对象存活，每次GC后gcmarkBits变成allocBits
</span><span class="c1"></span>	<span class="nx">gcmarkBits</span> <span class="o">*</span><span class="nx">gcBits</span>

	<span class="nx">sweepgen</span>    <span class="kt">uint32</span>
	<span class="nx">divMul</span>      <span class="kt">uint16</span>     <span class="c1">// for divide by elemsize - divMagic.mul
</span><span class="c1"></span>	<span class="nx">baseMask</span>    <span class="kt">uint16</span>     <span class="c1">// if non-0, elemsize is a power of 2, &amp; this will get object allocation base
</span><span class="c1"></span>	<span class="c1">// 已分配的object数量
</span><span class="c1"></span>	<span class="nx">allocCount</span>  <span class="kt">uint16</span>     <span class="c1">// number of allocated objects
</span><span class="c1"></span>	<span class="nx">spanclass</span>   <span class="nx">spanClass</span>  <span class="c1">// size class and noscan (uint8)
</span><span class="c1"></span>	<span class="nx">state</span>       <span class="nx">mSpanState</span> <span class="c1">// mspaninuse etc
</span><span class="c1"></span>	<span class="nx">needzero</span>    <span class="kt">uint8</span>      <span class="c1">// needs to be zeroed before allocation
</span><span class="c1"></span>	<span class="nx">divShift</span>    <span class="kt">uint8</span>      <span class="c1">// for divide by elemsize - divMagic.shift
</span><span class="c1"></span>	<span class="nx">divShift2</span>   <span class="kt">uint8</span>      <span class="c1">// for divide by elemsize - divMagic.shift2
</span><span class="c1"></span>	<span class="nx">scavenged</span>   <span class="kt">bool</span>       <span class="c1">// whether this span has had its pages released to the OS
</span><span class="c1"></span>	<span class="nx">elemsize</span>    <span class="kt">uintptr</span>    <span class="c1">// computed from sizeclass or from npages
</span><span class="c1"></span>	<span class="nx">unusedsince</span> <span class="kt">int64</span>      <span class="c1">// first time spotted by gc in mspanfree state
</span><span class="c1"></span>	<span class="nx">limit</span>       <span class="kt">uintptr</span>    <span class="c1">// end of data in span
</span><span class="c1"></span>	<span class="nx">speciallock</span> <span class="nx">mutex</span>      <span class="c1">// guards specials list
</span><span class="c1"></span>	<span class="nx">specials</span>    <span class="o">*</span><span class="nx">special</span>   <span class="c1">// linked list of special records sorted by offset.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="mcache">mcache</h4>
<p>mcache是每个P单独拥有的，所以不需要锁</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mcache</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// numSpanClasses = _NumSizeClasses &lt;&lt; 1, 也就是67*2=134
</span><span class="c1"></span>	<span class="nx">alloc</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span> 
<span class="p">}</span>
</code></pre></div><p>alloc的分布</p>
<p><img src="/posts/images/alloc_mspan.png" alt="alloc_mspan"></p>
<p>span class分为scan和noscan，如果对象含有指针则分为scan，否则分配到noscan，这样在GC的时候，如果对应的是noscan，则不用再去bitmap中找对应的对象</p>
<h4 id="mcentral">mcentral</h4>
<p>mcentral为每个mcache提供mspan， 每个mcentral保存未分配和已分批的span，当mcache没有合适或是空闲的mspan,就会从mcentral申请</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mcentral</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>      <span class="nx">mutex</span>
	<span class="nx">spanclass</span> <span class="nx">spanClass</span>
	<span class="nx">nonempty</span>  <span class="nx">mSpanList</span> <span class="c1">// 有空闲Object的mspan的链表
</span><span class="c1"></span>	<span class="nx">empty</span>     <span class="nx">mSpanList</span> <span class="c1">// 没有空闲Objectde mspan的链表， 或者被mcache取走的mspan链表
</span><span class="c1"></span>
	<span class="c1">// 累计分配object的数量
</span><span class="c1"></span>	<span class="nx">nmalloc</span> <span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></div><p>下面两个操作都需要加锁</p>
<ul>
<li>当mcache从mcentral申请mspan的时候，如果noempty中有空闲，那么会从noempty拿走，并加入到empty中</li>
<li>归还的话，从empty删除，并加入到noempty中</li>
</ul>
<h4 id="mheap">mheap</h4>
<p>mheap是一个全局的内存管理</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mheap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>      <span class="nx">mutex</span>
	<span class="c1">// mTreap 是个二叉排序树，按照span的page数量排序
</span><span class="c1"></span>	<span class="nx">free</span>      <span class="nx">mTreap</span> <span class="c1">// 保存span是空闲并且非垃圾回收的span
</span><span class="c1"></span>	<span class="nx">scav</span>      <span class="nx">mTreap</span> <span class="c1">// 保存span是空闲并且垃圾回收的span
</span><span class="c1"></span>	<span class="c1">// 指向spans区域，
</span><span class="c1"></span>	<span class="nx">allspans</span> <span class="p">[]</span><span class="o">*</span><span class="nx">mspan</span> <span class="c1">// all spans out there
</span><span class="c1"></span>
	<span class="c1">// arenas 是一个map，指向了每个heap arena对应的metadata
</span><span class="c1"></span>	<span class="c1">// Linux平台上arenaL1Bits是0， arenaL2Bits=heapAddrBits-logHeapArenaBytes(48-26)=22
</span><span class="c1"></span>	<span class="nx">arenas</span> <span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL1Bits</span><span class="p">]</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL2Bits</span><span class="p">]</span><span class="o">*</span><span class="nx">heapArena</span>

	<span class="c1">// 32位平台上预留空闲
</span><span class="c1"></span>	<span class="nx">arena</span> <span class="nx">linearAlloc</span>

	<span class="c1">// 记录arena的增长地址
</span><span class="c1"></span>	<span class="nx">arenaHints</span> <span class="o">*</span><span class="nx">arenaHint</span>

	<span class="c1">// 如果sweepgen == mheap.sweepgen - 2, span需要扫描
</span><span class="c1"></span>	<span class="c1">// 如果sweepgen == mheap.sweepgen - 1, span正在被扫描
</span><span class="c1"></span>	<span class="c1">// 如果sweepgen == mheap.sweepgen, span已经扫描完成，等待被使用
</span><span class="c1"></span>	<span class="c1">// 如果sweepgen == mheap.sweepgen + 1, span已经被缓存，现在仍然缓存中，则需要扫描
</span><span class="c1"></span>	<span class="c1">// 如果sweepgen == mheap.sweepgen + 3, span已经扫描过了，还处在缓存中
</span><span class="c1"></span>	<span class="nx">sweepgen</span>    <span class="kt">uint32</span>

	<span class="c1">// central 是一个针对小对象(32KB)的列表，用spanClass索引
</span><span class="c1"></span>	<span class="nx">central</span> <span class="p">[</span><span class="nx">numSpanClasses</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">mcentral</span> <span class="nx">mcentral</span>
		<span class="nx">pad</span>      <span class="p">[</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">mcentral</span><span class="p">{})</span><span class="o">%</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span><span class="p">]</span><span class="kt">byte</span>
	<span class="p">}</span>

	<span class="nx">spanalloc</span>             <span class="nx">fixalloc</span> <span class="c1">// allocator for span*
</span><span class="c1"></span>	<span class="nx">cachealloc</span>            <span class="nx">fixalloc</span> <span class="c1">// allocator for mcache*
</span><span class="c1"></span>	<span class="nx">treapalloc</span>            <span class="nx">fixalloc</span> <span class="c1">// allocator for treapNodes*
</span><span class="c1"></span>	<span class="nx">specialfinalizeralloc</span> <span class="nx">fixalloc</span> <span class="c1">// allocator for specialfinalizer*
</span><span class="c1"></span>	<span class="nx">specialprofilealloc</span>   <span class="nx">fixalloc</span> <span class="c1">// allocator for specialprofile*
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h5 id="heaparena">heapArena</h5>
<p>heapArena 保存heap arena的元数据</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">heapArena</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// bitmap表示arena哪些地址保存了对象， heapArenaBitmapBytes是2048K
</span><span class="c1"></span>	<span class="nx">bitmap</span> <span class="p">[</span><span class="nx">heapArenaBitmapBytes</span><span class="p">]</span><span class="kt">byte</span>

	<span class="c1">// spans 保存了page和mspan的对应关系， pagesPerArena是8KB
</span><span class="c1"></span>	<span class="nx">spans</span> <span class="p">[</span><span class="nx">pagesPerArena</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>

	<span class="c1">// pageInUse is a bitmap that indicates which spans are in
</span><span class="c1"></span>	<span class="c1">// state mSpanInUse. This bitmap is indexed by page number,
</span><span class="c1"></span>	<span class="c1">// but only the bit corresponding to the first page in each
</span><span class="c1"></span>	<span class="c1">// span is used.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Writes are protected by mheap_.lock.
</span><span class="c1"></span>	<span class="nx">pageInUse</span> <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>

	<span class="c1">// pageMarks is a bitmap that indicates which spans have any
</span><span class="c1"></span>	<span class="c1">// marked objects on them. Like pageInUse, only the bit
</span><span class="c1"></span>	<span class="c1">// corresponding to the first page in each span is used.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Writes are done atomically during marking. Reads are
</span><span class="c1"></span>	<span class="c1">// non-atomic and lock-free since they only occur during
</span><span class="c1"></span>	<span class="c1">// sweeping (and hence never race with writes).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This is used to quickly find whole spans that can be freed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// TODO(austin): It would be nice if this was uint64 for
</span><span class="c1"></span>	<span class="c1">// faster scanning, but we don&#39;t have 64-bit atomic bit
</span><span class="c1"></span>	<span class="c1">// operations.
</span><span class="c1"></span>	<span class="nx">pageMarks</span> <span class="p">[</span><span class="nx">pagesPerArena</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
<span class="p">}</span>
</code></pre></div><h3 id="分配过程">分配过程</h3>
<h4 id="newobject">newobject</h4>
<p>从堆上分配对象会从newobject</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newobject</span><span class="p">(</span><span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">typ</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">typ</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="mallocgc">mallocgc</h4>
<p>mallocgc 代码非常长，这里我们一种一种情况说</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="c1">// 省略...
</span><span class="c1"></span>	<span class="c1">// 判断是否需要辅助GC工作
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">assistG</span> <span class="o">*</span><span class="nx">g</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Charge the current user G for this allocation.
</span><span class="c1"></span>		<span class="nx">assistG</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">assistG</span> <span class="p">=</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
		<span class="p">}</span>
		<span class="c1">// Charge the allocation against the G. We&#39;ll account
</span><span class="c1"></span>		<span class="c1">// for internal fragmentation at the end of mallocgc.
</span><span class="c1"></span>		<span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// This G is in debt. Assist the GC to correct
</span><span class="c1"></span>			<span class="c1">// this before allocating. This must happen
</span><span class="c1"></span>			<span class="c1">// before disabling preemption.
</span><span class="c1"></span>			<span class="nf">gcAssistAlloc</span><span class="p">(</span><span class="nx">assistG</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 设置m的mallocing，防止被抢占
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;malloc deadlock&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;malloc during signal&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="nx">shouldhelpgc</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="nx">dataSize</span> <span class="o">:=</span> <span class="nx">size</span>
	<span class="c1">// 获取mcache
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">gomcache</span><span class="p">()</span>

	<span class="c1">// 省略...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h5 id="小对象32kb">小对象(&lt;=32KB)</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="c1">// 如果是极小对象(&lt;16B)并且对象不包含指针，则进行特殊处理
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">noscan</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
			<span class="c1">// 因为span最小是8byte，如果是过小的对象，也会被浪费掉，非常小的对象可以整合在class 2 noscan(大小为16 byte)
</span><span class="c1"></span>			<span class="nx">off</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span>
			<span class="c1">// Align tiny pointer for required (conservative) alignment.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">7</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">round</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">round</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">off</span> <span class="p">=</span> <span class="nf">round</span><span class="p">(</span><span class="nx">off</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">off</span><span class="o">+</span><span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxTinySize</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// The object fits into existing tiny block.
</span><span class="c1"></span>				<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">+</span> <span class="nx">off</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">off</span> <span class="o">+</span> <span class="nx">size</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">local_tinyallocs</span><span class="o">++</span>
				<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
				<span class="k">return</span> <span class="nx">x</span>
			<span class="p">}</span>
			<span class="c1">// tinySpanClass = 5, 按照span class排列，正好的16byte noscan span class
</span><span class="c1"></span>			<span class="nx">span</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">tinySpanClass</span><span class="p">]</span>
			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">v</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">tinySpanClass</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
			<span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="c1">// See if we need to replace the existing tiny block with the new one
</span><span class="c1"></span>			<span class="c1">// based on amount of remaining free space.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">tinyoffset</span> <span class="p">=</span> <span class="nx">size</span>
			<span class="p">}</span>
			<span class="nx">size</span> <span class="p">=</span> <span class="nx">maxTinySize</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 其他按小对象分配
</span><span class="c1"></span>			<span class="kd">var</span> <span class="nx">sizeclass</span> <span class="kt">uint8</span>
			<span class="c1">// 按size大小判断应该落在哪个span类型上
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">smallSizeMax</span><span class="o">-</span><span class="mi">8</span> <span class="p">{</span>
				<span class="nx">sizeclass</span> <span class="p">=</span> <span class="nx">size_to_class8</span><span class="p">[(</span><span class="nx">size</span><span class="o">+</span><span class="nx">smallSizeDiv</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nx">smallSizeDiv</span><span class="p">]</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">sizeclass</span> <span class="p">=</span> <span class="nx">size_to_class128</span><span class="p">[(</span><span class="nx">size</span><span class="o">-</span><span class="nx">smallSizeMax</span><span class="o">+</span><span class="nx">largeSizeDiv</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nx">largeSizeDiv</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="nx">size</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">])</span>
			<span class="c1">// 等于sizeclass * 2
</span><span class="c1"></span>			<span class="nx">spc</span> <span class="o">:=</span> <span class="nf">makeSpanClass</span><span class="p">(</span><span class="nx">sizeclass</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
			<span class="nx">span</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
			<span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// 如果分配失败，需要从mcentral或者mheap中获取
</span><span class="c1"></span>				<span class="c1">// 如果分配到了shouldhelpgc会返回true，接下来会判断是否触发GC
</span><span class="c1"></span>				<span class="nx">v</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">needzero</span> <span class="o">&amp;&amp;</span> <span class="nx">span</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
</code></pre></div><h5 id="对象32kb">对象(&gt;32KB)</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">		<span class="c1">// 大对象直接从mheap分配， 这个class是0
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
		<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">s</span> <span class="p">=</span> <span class="nf">largeAlloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">needzero</span><span class="p">,</span> <span class="nx">noscan</span><span class="p">)</span>
		<span class="p">})</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
</code></pre></div><h5 id="后续">后续</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="c1">// 如果是指针对象，需要设置对应的bitmap，记录哪些位置包含了指针
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">noscan</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">typ</span> <span class="o">==</span> <span class="nx">deferType</span> <span class="p">{</span>
			<span class="nx">dataSize</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">_defer</span><span class="p">{})</span>
		<span class="p">}</span>
		<span class="nf">heapBitsSetType</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">dataSize</span><span class="p">,</span> <span class="nx">typ</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">dataSize</span> <span class="p">&gt;</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
			<span class="c1">// Array allocation. If there are any
</span><span class="c1"></span>			<span class="c1">// pointers, GC has to scan to the last
</span><span class="c1"></span>			<span class="c1">// element.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">scanSize</span> <span class="p">=</span> <span class="nx">dataSize</span> <span class="o">-</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">size</span> <span class="o">+</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">scanSize</span> <span class="p">=</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_scan</span> <span class="o">+=</span> <span class="nx">scanSize</span>
	<span class="p">}</span>
	<span class="c1">// ...
</span><span class="c1"></span>	<span class="c1">// GC中发生了分配，则将对象标记为“黑色”，防止回收
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">gcmarknewobject</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">scanSize</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 允许抢占
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">mallocing</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>

	<span class="c1">// Profile记录
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">rate</span> <span class="o">:=</span> <span class="nx">MemProfileRate</span><span class="p">;</span> <span class="nx">rate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">rate</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">next_sample</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">next_sample</span> <span class="o">-=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
			<span class="nf">profilealloc</span><span class="p">(</span><span class="nx">mp</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">assistG</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Account for internal fragmentation in the assist
</span><span class="c1"></span>		<span class="c1">// debt now that we know it.
</span><span class="c1"></span>		<span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">size</span> <span class="o">-</span> <span class="nx">dataSize</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 如果之前获取了新的span，需要启动下gc
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">shouldhelpgc</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">gcTriggerHeap</span><span class="p">});</span> <span class="nx">t</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">gcStart</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div><h5 id="nextfreefast">nextFreeFast</h5>
<p>快速分配</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="nx">gclinkptr</span> <span class="p">{</span>
	<span class="c1">// 获取第一个非0的bit是第几bit（从右边排），用来判断是否未分配
</span><span class="c1"></span>	<span class="nx">theBit</span> <span class="o">:=</span> <span class="nx">sys</span><span class="p">.</span><span class="nf">Ctz64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span><span class="p">)</span>
	<span class="c1">// 如果有未分配的,
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">theBit</span> <span class="p">&lt;</span> <span class="mi">64</span> <span class="p">{</span>
		<span class="nx">result</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">theBit</span><span class="p">)</span>
		<span class="c1">// 索引值小于当前元素数量
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">result</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
			<span class="c1">// 下一个freeidx
</span><span class="c1"></span>			<span class="nx">freeidx</span> <span class="o">:=</span> <span class="nx">result</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="c1">// 如果是64的倍数，需要特殊处理
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">freeidx</span><span class="o">%</span><span class="mi">64</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">freeidx</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
				<span class="k">return</span> <span class="mi">0</span>
			<span class="p">}</span>
			<span class="c1">// 更新freeindex和allocCache
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="o">&gt;&gt;=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">theBit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">freeidx</span>
			<span class="c1">// 更新计数器
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="o">++</span>
			<span class="k">return</span> <span class="nf">gclinkptr</span><span class="p">(</span><span class="nx">result</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div><h5 id="nextfree">nextFree</h5>
<p>如果nextFreeFast没有分配到元素，则需要调用nextFree</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">gclinkptr</span><span class="p">,</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 获取目标span
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>
	<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="c1">// 获取下一个freeIndex
</span><span class="c1"></span>	<span class="nx">freeIndex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
	<span class="c1">// span已经满了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: s.allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34;s.nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 申请新的span
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">refill</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
		<span class="c1">// 标记检查gc
</span><span class="c1"></span>		<span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>

		<span class="nx">freeIndex</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">&gt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;freeIndex is not valid&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 返回元素所在的地址
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="nf">gclinkptr</span><span class="p">(</span><span class="nx">freeIndex</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
	<span class="c1">// 分配计数++
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="o">++</span>
	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;s.allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34;s.nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;s.allocCount &gt; s.nelems&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><h5 id="refill">refill</h5>
<p>当mache中没有空闲的span时候，需要调用refill申请新的span
注： refill过程中，已经标记G不能被抢占</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">)</span> <span class="nf">refill</span><span class="p">(</span><span class="nx">spc</span> <span class="nx">spanClass</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Return the current cached span to the central lists.
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span>

	<span class="c1">// 确保元素已经分配完
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;refill of span with free space remaining&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 设置sweepgen属性，
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">emptymspan</span> <span class="p">{</span>
		<span class="c1">// 将这个span标记为不在缓存
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">!=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">+</span><span class="mi">3</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad sweepgen in refill&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 从mcenral 申请一个新的span
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">cacheSpan</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;span has no free space&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 将此标记为已扫描
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">+</span> <span class="mi">3</span>
	<span class="c1">// 将当前span加入到mcache中
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">alloc</span><span class="p">[</span><span class="nx">spc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><h5 id="cachespan">cacheSpan</h5>
<p>从mcentral获取span</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">cacheSpan</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// 需要分配span的字节大小
</span><span class="c1"></span>	<span class="nx">spanBytes</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_allocnpages</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span> <span class="o">*</span> <span class="nx">_PageSize</span>
	<span class="nf">deductSweepCredit</span><span class="p">(</span><span class="nx">spanBytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="c1">// 加锁
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">traceDone</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSweepStart</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
<span class="nx">retry</span><span class="p">:</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="c1">// 从nonempty中获取mspan
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
		<span class="c1">// sweepgen ==  mheap_.sweepgen, 表示span已经sweep
</span><span class="c1"></span>		<span class="c1">// sweepgen ==  mheap_.sweepgen - 1，表示span正在sweep
</span><span class="c1"></span>		<span class="c1">// sweepgen ==  mheap_.sweepgen - 2, 表示span还没sweep
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 如果获取到了，将nonempty移除，并加入到empty，
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
			<span class="k">goto</span> <span class="nx">havespan</span>
		<span class="p">}</span>
		<span class="c1">// 如果span正在被其他线程sweep，跳过
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="c1">// sweep已经sweep，noempty至少有1个未分配的span，直接分配
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">nonempty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">havespan</span>
	<span class="p">}</span>
	
	<span class="c1">// 从empty中获取mspan
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
		<span class="c1">// span正在等待sweep
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 从empty中移除，并加入到链表末尾
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="c1">// TODO: 尝试sweep
</span><span class="c1"></span>			<span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
			<span class="c1">// 检查下是否有未分配的对象，有则分配
</span><span class="c1"></span>			<span class="nx">freeIndex</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">freeIndex</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="nx">freeIndex</span>
				<span class="k">goto</span> <span class="nx">havespan</span>
			<span class="p">}</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="c1">// the span is still empty after sweep
</span><span class="c1"></span>			<span class="c1">// it is already in the empty list, so just retry
</span><span class="c1"></span>			<span class="k">goto</span> <span class="nx">retry</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="c1">// the span is being swept by background sweeper, skip
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 找不到未分配对象的span
</span><span class="c1"></span>		<span class="k">break</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSweepDone</span><span class="p">()</span>
		<span class="nx">traceDone</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Replenish central list if empty.
</span><span class="c1"></span>	<span class="c1">// 如果依然没找到，则从mheap分配，分配后直接加入到empty
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">grow</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">empty</span><span class="p">.</span><span class="nf">insertBack</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// At this point s is a non-empty span, queued at the end of the empty list,
</span><span class="c1"></span>	<span class="c1">// c is unlocked.
</span><span class="c1"></span><span class="nx">havespan</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">traceDone</span> <span class="p">{</span>
		<span class="nf">traceGCSweepDone</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="o">||</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;span has no free objects&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Assume all objects from this span will be allocated in the
</span><span class="c1"></span>	<span class="c1">// mcache. If it gets uncached, we&#39;ll adjust this.
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">nmalloc</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="nx">usedBytes</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">)</span> <span class="o">*</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">spanBytes</span><span class="p">)</span><span class="o">-</span><span class="nb">int64</span><span class="p">(</span><span class="nx">usedBytes</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="c1">// heap_live changed.
</span><span class="c1"></span>		<span class="nf">traceHeapAlloc</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// heap_live changed.
</span><span class="c1"></span>		<span class="nx">gcController</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">freeByteBase</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">whichByte</span> <span class="o">:=</span> <span class="nx">freeByteBase</span> <span class="o">/</span> <span class="mi">8</span>
	<span class="c1">// Init alloc bits cache.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="nx">whichByte</span><span class="p">)</span>

	<span class="c1">// Adjust the allocCache so that s.freeindex corresponds to the low bit in
</span><span class="c1"></span>	<span class="c1">// s.allocCache.
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCache</span> <span class="o">&gt;&gt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">%</span> <span class="mi">64</span>

	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><h5 id="grow">grow</h5>
<p>向mheap申请一个新的span</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcentral</span><span class="p">)</span> <span class="nf">grow</span><span class="p">()</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// 根据mcentral的类型计算需要申请span的大小
</span><span class="c1"></span>	<span class="nx">npages</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_allocnpages</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()])</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span> <span class="o">/</span> <span class="nx">size</span>

	<span class="c1">// 向mheap申请一个新的span
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">npages</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// 返回mspan.startAddr
</span><span class="c1"></span>	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="nx">p</span> <span class="o">+</span> <span class="nx">size</span><span class="o">*</span><span class="nx">n</span>
	<span class="c1">// 分配并初始化span
</span><span class="c1"></span>	<span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()).</span><span class="nf">initSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

</code></pre></div><h5 id="alloc">alloc</h5>
<p>调用alloc，分配span</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">alloc</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">large</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="c1">// Don&#39;t do any operations that lock the heap on the G stack.
</span><span class="c1"></span>	<span class="c1">// It might trigger stack growth, and the stack growth code needs
</span><span class="c1"></span>	<span class="c1">// to be able to allocate heap.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">alloc_m</span><span class="p">(</span><span class="nx">npage</span><span class="p">,</span> <span class="nx">spanclass</span><span class="p">,</span> <span class="nx">large</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">needzero</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><h5 id="alloc_m">alloc_m</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">alloc_m</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">spanclass</span> <span class="nx">spanClass</span><span class="p">,</span> <span class="nx">large</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// 为了过度分配，我们这里需要分配npage前，sweep和回收至少npage
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">sweepdone</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">reclaim</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 对mheap上锁
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 更新全局计数
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nx">local_scan</span><span class="p">)</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nx">local_scan</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">tinyallocs</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nx">local_tinyallocs</span><span class="p">)</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nx">local_tinyallocs</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 分配span
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">allocSpanLocked</span><span class="p">(</span><span class="nx">npage</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_inuse</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 设置span的sweepsgen = mheap sweepgen
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>
		<span class="c1">// sweepSpans[h.sweepgen/2%2] 保存当前正在使用的span列表
</span><span class="c1"></span>		<span class="c1">// sweepSpans[1-sweepgen/2%2] 保存等待sweep的span列表
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">h</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">mSpanInUse</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span> <span class="p">=</span> <span class="nx">spanclass</span>
		<span class="k">if</span> <span class="nx">sizeclass</span> <span class="o">:=</span> <span class="nx">spanclass</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">();</span> <span class="nx">sizeclass</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">baseMask</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">])</span>
			<span class="nx">m</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">class_to_divmagic</span><span class="p">[</span><span class="nx">sizeclass</span><span class="p">]</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">shift</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divMul</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">mul</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">divShift2</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">shift2</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">baseMask</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">baseMask</span>
		<span class="p">}</span>

		<span class="c1">// Mark in-use span in arena page bitmap.
</span><span class="c1"></span>		<span class="nx">arena</span><span class="p">,</span> <span class="nx">pageIdx</span><span class="p">,</span> <span class="nx">pageMask</span> <span class="o">:=</span> <span class="nf">pageIndexOf</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="nx">arena</span><span class="p">.</span><span class="nx">pageInUse</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">]</span> <span class="o">|=</span> <span class="nx">pageMask</span>

		<span class="c1">// update stats, sweep lists
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">.</span><span class="nx">pagesInUse</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">large</span> <span class="p">{</span>
			<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_objects</span><span class="o">++</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">largealloc</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nx">nlargealloc</span><span class="o">++</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">npage</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// heap_scan and heap_live were updated.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gcController</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceHeapAlloc</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// h.spans is accessed concurrently without synchronization
</span><span class="c1"></span>	<span class="c1">// from other threads. Hence, there must be a store/store
</span><span class="c1"></span>	<span class="c1">// barrier here to ensure the writes to h.spans above happen
</span><span class="c1"></span>	<span class="c1">// before the caller can publish a pointer p to an object
</span><span class="c1"></span>	<span class="c1">// allocated from s. As soon as this happens, the garbage
</span><span class="c1"></span>	<span class="c1">// collector running on another processor could read p and
</span><span class="c1"></span>	<span class="c1">// look up s in h.spans. The unlock acts as the barrier to
</span><span class="c1"></span>	<span class="c1">// order these writes. On the read side, the data dependency
</span><span class="c1"></span>	<span class="c1">// between p and the index in h.spans orders the reads.
</span><span class="c1"></span>	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><h5 id="allocspanlocked">allocSpanLocked</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">allocSpanLocked</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">stat</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">)</span> <span class="o">*</span><span class="nx">mspan</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>

	<span class="c1">// 从free和scav中查找符合条件的最小span
</span><span class="c1"></span>	<span class="c1">// 1. 如果free中存在，并且find scav为nil或者free找的span的pages小于等于scav，则返回free找到的span并且删除对应节点
</span><span class="c1"></span>	<span class="c1">// 2. 如果scav中存在，并且find free为nil或者free找的span pages 大于scav的，则返回scav的span并删除对应的节点
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">pickFreeSpan</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="nx">HaveSpan</span>
	<span class="p">}</span>

	<span class="c1">// 如果寻找失败，则尝试再次增加heap大小
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">h</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// 再次重试
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">pickFreeSpan</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="nx">HaveSpan</span>
	<span class="p">}</span>
	<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;grew heap, but no adequate free span found&#34;</span><span class="p">)</span>

<span class="nx">HaveSpan</span><span class="p">:</span>
	<span class="c1">// 检查得到的span
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanFree</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;candidate mspan for allocation is not free&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="p">&lt;</span> <span class="nx">npage</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;candidate mspan for allocation is too small&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 减掉我们释放回操作系统的内存
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_released</span> <span class="o">-=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">released</span><span class="p">())</span>

	<span class="c1">// 如果获取到的pages超过我们的要求的pages
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="p">&gt;</span> <span class="nx">npage</span> <span class="p">{</span>
		<span class="c1">// 分割剩余的pages，将其再放回到heap中
</span><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">mspan</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">+</span><span class="nx">npage</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">-</span><span class="nx">npage</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="p">=</span> <span class="nx">npage</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">setSpan</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">setSpan</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">base</span><span class="p">(),</span> <span class="nx">t</span><span class="p">)</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">setSpan</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">+</span><span class="nx">t</span><span class="p">.</span><span class="nx">npages</span><span class="o">*</span><span class="nx">pageSize</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span>
		<span class="c1">// If s was scavenged, then t may be scavenged.
</span><span class="c1"></span>		<span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">physPageBounds</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">scavenged</span> <span class="o">&amp;&amp;</span> <span class="nx">start</span> <span class="p">&lt;</span> <span class="nx">end</span> <span class="p">{</span>
			<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_released</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">end</span> <span class="o">-</span> <span class="nx">start</span><span class="p">)</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">scavenged</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">mSpanManual</span> <span class="c1">// prevent coalescing with s
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">mSpanManual</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">freeSpanLocked</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">unusedsince</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">mSpanFree</span>
	<span class="p">}</span>
	<span class="c1">// &#34;Unscavenge&#34; s only AFTER splitting so that
</span><span class="c1"></span>	<span class="c1">// we only sysUsed whatever we actually need.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">scavenged</span> <span class="p">{</span>
		<span class="c1">// sysUsed all the pages that are actually available
</span><span class="c1"></span>		<span class="c1">// in the span. Note that we don&#39;t need to decrement
</span><span class="c1"></span>		<span class="c1">// heap_released since we already did so earlier.
</span><span class="c1"></span>		<span class="nf">sysUsed</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="o">&lt;&lt;</span><span class="nx">_PageShift</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">scavenged</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">unusedsince</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 设置spans，哪些地址对应哪个span
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nf">setSpans</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">(),</span> <span class="nx">npage</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>

	<span class="o">*</span><span class="nx">stat</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">npage</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_idle</span> <span class="o">-=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">npage</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span><span class="p">)</span>

	<span class="c1">//println(&#34;spanalloc&#34;, hex(s.start&lt;&lt;_PageShift))
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">inList</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;still in list&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><h5 id="grow-1">grow</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">grow</span><span class="p">(</span><span class="nx">npage</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">ask</span> <span class="o">:=</span> <span class="nx">npage</span> <span class="o">&lt;&lt;</span> <span class="nx">_PageShift</span>
	<span class="c1">// 申请
</span><span class="c1"></span>	<span class="nx">v</span><span class="p">,</span> <span class="nx">size</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">ask</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: out of memory: cannot allocate &#34;</span><span class="p">,</span> <span class="nx">ask</span><span class="p">,</span> <span class="s">&#34;-byte block (&#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">,</span> <span class="s">&#34; in use)\n&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// Scavenge some pages out of the free treap to make up for
</span><span class="c1"></span>	<span class="c1">// the virtual memory space we just allocated. We prefer to
</span><span class="c1"></span>	<span class="c1">// scavenge the largest spans first since the cost of scavenging
</span><span class="c1"></span>	<span class="c1">// is proportional to the number of sysUnused() calls rather than
</span><span class="c1"></span>	<span class="c1">// the number of pages released, so we make fewer of those calls
</span><span class="c1"></span>	<span class="c1">// with larger spans.
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">.</span><span class="nf">scavengeLargest</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>

	<span class="c1">// 创建一个InUse的span，然后释放掉，保证能正常的合并
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">mspan</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">spanalloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
	<span class="nx">s</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="nx">size</span><span class="o">/</span><span class="nx">pageSize</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">setSpans</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">(),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">mSpanInUse</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">pagesInUse</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">)</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">freeSpanLocked</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><h5 id="sysalloc">sysAlloc</h5>
<p>sysAlloc会分配至少n字节的</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">mheap</span><span class="p">)</span> <span class="nf">sysAlloc</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="p">=</span> <span class="nf">round</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">heapArenaBytes</span><span class="p">)</span>

	<span class="c1">// 首先，尝试从arena分配
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arena</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">heapArenaBytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">size</span> <span class="p">=</span> <span class="nx">n</span>
		<span class="k">goto</span> <span class="nx">mapped</span>
	<span class="p">}</span>

	<span class="c1">// 尝试增长heap
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">hint</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arenaHints</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span>
		<span class="k">if</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">down</span> <span class="p">{</span>
			<span class="nx">p</span> <span class="o">-=</span> <span class="nx">n</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">p</span><span class="o">+</span><span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">p</span> <span class="p">{</span>
			<span class="c1">// We can&#39;t use this, so don&#39;t ask.
</span><span class="c1"></span>			<span class="nx">v</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nx">p</span><span class="o">+</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">arenaBits</span> <span class="p">{</span>
			<span class="c1">// Outside addressable heap. Can&#39;t use.
</span><span class="c1"></span>			<span class="nx">v</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 调用系统的mmap函数
</span><span class="c1"></span>			<span class="nx">v</span> <span class="p">=</span> <span class="nf">sysReserve</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nx">n</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 获取成功，更新hint
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">hint</span><span class="p">.</span><span class="nx">down</span> <span class="p">{</span>
				<span class="nx">p</span> <span class="o">+=</span> <span class="nx">n</span>
			<span class="p">}</span>
			<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">p</span>
			<span class="nx">size</span> <span class="p">=</span> <span class="nx">n</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c1">// 获取失败，放弃这个hint，尝试下一个
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">sysFree</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">next</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">hint</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="c1">// The race detector assumes the heap lives in
</span><span class="c1"></span>			<span class="c1">// [0x00c000000000, 0x00e000000000), but we
</span><span class="c1"></span>			<span class="c1">// just ran out of hints in this region. Give
</span><span class="c1"></span>			<span class="c1">// a nice failure.
</span><span class="c1"></span>			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;too many address space collisions for -race mode&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// 所有的hints都失败了
</span><span class="c1"></span>		<span class="nx">v</span><span class="p">,</span> <span class="nx">size</span> <span class="p">=</span> <span class="nf">sysReserveAligned</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">heapArenaBytes</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span>
		<span class="p">}</span>

		<span class="c1">// 创建新的hints
</span><span class="c1"></span>		<span class="nx">hint</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">arenaHint</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">hint</span><span class="p">.</span><span class="nx">down</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="kc">true</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span><span class="p">,</span> <span class="nx">hint</span>
		<span class="nx">hint</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">arenaHint</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">arenaHintAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">())</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">addr</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">+</span> <span class="nx">size</span>
		<span class="nx">hint</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">arenaHints</span><span class="p">,</span> <span class="nx">hint</span>
	<span class="p">}</span>

	<span class="c1">// 检查指针
</span><span class="c1"></span>	<span class="p">{</span>
		<span class="kd">var</span> <span class="nx">bad</span> <span class="kt">string</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">p</span><span class="o">+</span><span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">p</span> <span class="p">{</span>
			<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;region exceeds uintptr range&#34;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">arenaBits</span> <span class="p">{</span>
			<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;base outside usable address space&#34;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nx">p</span><span class="o">+</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">arenaBits</span> <span class="p">{</span>
			<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;end outside usable address space&#34;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">bad</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="c1">// This should be impossible on most architectures,
</span><span class="c1"></span>			<span class="c1">// but it would be really confusing to debug.
</span><span class="c1"></span>			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: memory allocated by OS [&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">p</span><span class="o">+</span><span class="nx">size</span><span class="p">),</span> <span class="s">&#34;) not in usable address space: &#34;</span><span class="p">,</span> <span class="nx">bad</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;memory reservation exceeds address space limit&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">heapArenaBytes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;misrounded allocation in sysAlloc&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Back the reservation.
</span><span class="c1"></span>	<span class="nf">sysMap</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_sys</span><span class="p">)</span>

<span class="nx">mapped</span><span class="p">:</span>
	<span class="c1">// 创建heapArena
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">ri</span> <span class="o">:=</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">));</span> <span class="nx">ri</span> <span class="o">&lt;=</span> <span class="nf">arenaIndex</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">+</span><span class="nx">size</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="nx">ri</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">l2</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">arenas</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l1</span><span class="p">()]</span>
		<span class="k">if</span> <span class="nx">l2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Allocate an L2 arena map.
</span><span class="c1"></span>			<span class="nx">l2</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">arenaL2Bits</span><span class="p">]</span><span class="o">*</span><span class="nx">heapArena</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">l2</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">l2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory allocating heap arena map&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorepNoWB</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">arenas</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l1</span><span class="p">()]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">l2</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">l2</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l2</span><span class="p">()]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;arena already initialized&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="kd">var</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">heapArena</span>
		<span class="nx">r</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">heapArena</span><span class="p">)(</span><span class="nx">h</span><span class="p">.</span><span class="nx">heapArenaAlloc</span><span class="p">.</span><span class="nf">alloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">r</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">heapArena</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">r</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">r</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory allocating heap arena metadata&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Add the arena to the arenas list.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span> <span class="o">==</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">size</span> <span class="o">:=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">))</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
			<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">size</span> <span class="p">=</span> <span class="nx">physPageSize</span>
			<span class="p">}</span>
			<span class="nx">newArray</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">notInHeap</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_sys</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">newArray</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory allocating allArenas&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">oldSlice</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span>
			<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">notInHeapSlice</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">))</span> <span class="p">=</span> <span class="nx">notInHeapSlice</span><span class="p">{</span><span class="nx">newArray</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">size</span> <span class="o">/</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)}</span>
			<span class="nb">copy</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">,</span> <span class="nx">oldSlice</span><span class="p">)</span>
			<span class="c1">// Do not free the old backing array because
</span><span class="c1"></span>			<span class="c1">// there may be concurrent readers. Since we
</span><span class="c1"></span>			<span class="c1">// double the array each time, this can lead
</span><span class="c1"></span>			<span class="c1">// to at most 2x waste.
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">allArenas</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ri</span>

		<span class="c1">// Store atomically just in case an object from the
</span><span class="c1"></span>		<span class="c1">// new heap arena becomes visible before the heap lock
</span><span class="c1"></span>		<span class="c1">// is released (which shouldn&#39;t happen, but there&#39;s
</span><span class="c1"></span>		<span class="c1">// little downside to this).
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorepNoWB</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l2</span><span class="p">[</span><span class="nx">ri</span><span class="p">.</span><span class="nf">l2</span><span class="p">()]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// Tell the race detector about the new heap memory.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racemapshadow</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>

</code></pre></div><h4 id="分配图">分配图</h4>
<p>从别的地方转载的一张图
<img src="/posts/images/malloc.png" alt="malloc"></p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://segmentfault.com/a/1190000020086739">深入理解Go-内存分配</a></li>
<li><a href="https://www.jianshu.com/p/2904efc7f1a8">图解Golang的内存分配</a></li>
<li><a href="https://www.cnblogs.com/zkweb/p/7880099.html">Golang源码探索(三) GC的实现原理</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go-深入理解sync.Map</title>
			<link>https://leonzyang.github.io/posts/syncmap/</link>
			<pubDate>Sun, 27 Jun 2021 09:31:25 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/syncmap/</guid>
			<description>深入理解sync.Map 数据结构 Map type Map struct { mu Mutex // 锁  read atomic.Value // 优先读取map  dirty map[interface{}]*entry // dirty当前最新的map，提供读写  misses int // 在read中读取不到读取dirty map的次数，当misses=len(dirty)，则将dirty拷贝到read } readOnly type readOnly struct { m map[interface{}]*entry amended bool // dirty中存在但是不在m，则为真 } entry type entry struct { // 如果p为nil， entry已被删除并且m.dirty=nil  // 如果p==expunged， 表示entry已被删除，并且dirty不为nil，并且entry不存在dirty中  // 其他entry是个正常值 	p unsafe.Pointer // *interface{} } expunged expunged是个空指针表示dirty中已删除
var expunged = unsafe.Pointer(new(interface{})) 使用 Load func (m *Map) Load(key interface{}) (value interface{}, ok bool) { // 第一次从read中获取数据 	read, _ := m.</description>
			<content type="html"><![CDATA[<h2 id="深入理解syncmap">深入理解sync.Map</h2>
<h3 id="数据结构">数据结构</h3>
<h4 id="map">Map</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Map</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span> <span class="nx">Mutex</span>  <span class="c1">// 锁
</span><span class="c1"></span>
	<span class="nx">read</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span> <span class="c1">// 优先读取map
</span><span class="c1"></span>
	<span class="nx">dirty</span> <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="o">*</span><span class="nx">entry</span>  <span class="c1">// dirty当前最新的map，提供读写
</span><span class="c1"></span>
	<span class="nx">misses</span> <span class="kt">int</span> <span class="c1">// 在read中读取不到读取dirty map的次数，当misses=len(dirty)，则将dirty拷贝到read
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="readonly">readOnly</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">readOnly</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">m</span>       <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="o">*</span><span class="nx">entry</span>
	<span class="nx">amended</span> <span class="kt">bool</span> <span class="c1">// dirty中存在但是不在m，则为真
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="entry">entry</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">entry</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 如果p为nil， entry已被删除并且m.dirty=nil
</span><span class="c1"></span>    <span class="c1">// 如果p==expunged， 表示entry已被删除，并且dirty不为nil，并且entry不存在dirty中
</span><span class="c1"></span>    <span class="c1">// 其他entry是个正常值
</span><span class="c1"></span>	<span class="nx">p</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// *interface{}
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="expunged">expunged</h4>
<p>expunged是个空指针表示dirty中已删除</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">expunged</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="kd">interface</span><span class="p">{}))</span>
</code></pre></div><h3 id="使用">使用</h3>
<h4 id="load">Load</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Load</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 第一次从read中获取数据
</span><span class="c1"></span>	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
		<span class="c1">// 数据不存在并且dirty不为空
</span><span class="c1"></span>		<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="c1">// 避免因为加锁过程中（阻塞），dirty被提升为read
</span><span class="c1"></span>		<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
		<span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
			<span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
			<span class="c1">// 不管在dirty中有没有找到，都记录为miss
</span><span class="c1"></span>			<span class="nx">m</span><span class="p">.</span><span class="nf">missLocked</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nf">load</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h5 id="misslocked">missLocked</h5>
<p>当misses大于等于m.dirty的长度，则将dirty提升为read</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">missLocked</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">misses</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">misses</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
    <span class="p">}</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">readOnly</span><span class="p">{</span><span class="nx">m</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">})</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">misses</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div><h5 id="load-1">load</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nf">load</span><span class="p">()</span> <span class="p">(</span><span class="nx">value</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
	<span class="c1">// 如果p已经删除
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">p</span> <span class="o">==</span> <span class="nx">expunged</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><h4 id="store">Store</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Store</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="c1">// 第一次获取readOnly
</span><span class="c1"></span>	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">e</span><span class="p">.</span><span class="nf">tryStore</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// key存在并且没有被删除
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="c1">// 再次获取下readOnly
</span><span class="c1"></span>	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// 确保未被标记成删除
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nf">unexpungeLocked</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 该条目之前被删除了，这意味着有非nil的dirty map，并且entry不在dirty map中
</span><span class="c1"></span>			<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
		<span class="p">}</span>
		<span class="nx">e</span><span class="p">.</span><span class="nf">storeLocked</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// dirty map中存在
</span><span class="c1"></span>		<span class="nx">e</span><span class="p">.</span><span class="nf">storeLocked</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
			<span class="c1">// dirty map为空，增加到dirty map中
</span><span class="c1"></span>			<span class="nx">m</span><span class="p">.</span><span class="nf">dirtyLocked</span><span class="p">()</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">readOnly</span><span class="p">{</span><span class="nx">m</span><span class="p">:</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="nx">amended</span><span class="p">:</span> <span class="kc">true</span><span class="p">})</span>
		<span class="p">}</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nf">newEntry</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>storeLocked原子存储数据（必须确定entry没有删除）</p>
<h5 id="dirtylocked">dirtyLocked</h5>
<p>dirty为nil，将read中的数据拷贝到dirty中</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">dirtyLocked</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="o">*</span><span class="nx">entry</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span> <span class="p">{</span>
		<span class="c1">// nil和expunged不拷贝到dirty
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">e</span><span class="p">.</span><span class="nf">tryExpungeLocked</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nf">tryExpungeLocked</span><span class="p">()</span> <span class="p">(</span><span class="nx">isExpunged</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">expunged</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">p</span> <span class="o">==</span> <span class="nx">expunged</span>
<span class="p">}</span>

</code></pre></div><h4 id="loadorstore">LoadOrStore</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">LoadOrStore</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">actual</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">loaded</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 不加锁读取read
</span><span class="c1"></span>	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// 如果entry成员在，尝试获取值
</span><span class="c1"></span>		<span class="nx">actual</span><span class="p">,</span> <span class="nx">loaded</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">tryLoadOrStore</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// entry存在或者赋值成功，ok为true
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">actual</span><span class="p">,</span> <span class="nx">loaded</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="c1">// 第二次获取read
</span><span class="c1"></span>	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// 如果之前标记为expunged，写入到dirty
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nf">unexpungeLocked</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
		<span class="p">}</span>
		<span class="nx">actual</span><span class="p">,</span> <span class="nx">loaded</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">tryLoadOrStore</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">actual</span><span class="p">,</span> <span class="nx">loaded</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">tryLoadOrStore</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
		<span class="nx">m</span><span class="p">.</span><span class="nf">missLocked</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">.</span><span class="nf">dirtyLocked</span><span class="p">()</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">readOnly</span><span class="p">{</span><span class="nx">m</span><span class="p">:</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="nx">amended</span><span class="p">:</span> <span class="kc">true</span><span class="p">})</span>
		<span class="p">}</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nf">newEntry</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
		<span class="nx">actual</span><span class="p">,</span> <span class="nx">loaded</span> <span class="p">=</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">return</span> <span class="nx">actual</span><span class="p">,</span> <span class="nx">loaded</span>
<span class="p">}</span>
</code></pre></div><h5 id="tryloadorstore">tryLoadOrStore</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nf">tryLoadOrStore</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">actual</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">loaded</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
	<span class="c1">// 已经删除
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="nx">expunged</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// entry存在
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nx">ic</span> <span class="o">:=</span> <span class="nx">i</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// entry为空，则赋值
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ic</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="nx">expunged</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">p</span><span class="p">),</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="delete">Delete</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="c1">// 第一次获取
</span><span class="c1"></span>	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="c1">// 第二次获取
</span><span class="c1"></span>		<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
		<span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
			<span class="c1">// read中不存在，并且dirty不为nil，不管dirty中存不存在，都执行删除
</span><span class="c1"></span>			<span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">e</span><span class="p">.</span><span class="nb">delete</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span><span class="p">)</span> <span class="nb">delete</span><span class="p">()</span> <span class="p">(</span><span class="nx">hadValue</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">)</span>
		<span class="c1">// 如果已经删除了
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">p</span> <span class="o">==</span> <span class="nx">expunged</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="c1">// 删除很简单，直接将entry设置为nil，这样的好处是能根据此判断是否删除
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">e</span><span class="p">.</span><span class="nx">p</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="range">Range</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Range</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 迭代的获取所有元素
</span><span class="c1"></span>	<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
		<span class="c1">// dirty不为nil，dirty有些keys 不在read
</span><span class="c1"></span>		<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="c1">// 第二次检测
</span><span class="c1"></span>		<span class="nx">read</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Load</span><span class="p">().(</span><span class="nx">readOnly</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">read</span><span class="p">.</span><span class="nx">amended</span> <span class="p">{</span>
			<span class="c1">// 如果dirty依然不为nil，则直接将diry提升为read
</span><span class="c1"></span>			<span class="nx">read</span> <span class="p">=</span> <span class="nx">readOnly</span><span class="p">{</span><span class="nx">m</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span><span class="p">}</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">read</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">read</span><span class="p">)</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">dirty</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">misses</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">read</span><span class="p">.</span><span class="nx">m</span> <span class="p">{</span>
		<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">load</span><span class="p">()</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">!</span><span class="nf">f</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>sync.Map 没有实现Len方法，可以用Range配合计数实现，这里就不多说了</p>
<h3 id="总结">总结</h3>
<p>sync.Map 通过read和dirty两个map控制，将读取任务主要集中在read中，在源码中dirty和read需要互相拷贝，如果数据量比较大并且有很大的读写，sync.Map就不是很适合了。</p>
]]></content>
		</item>
		
		<item>
			<title>Go-深入理解WaitGroup</title>
			<link>https://leonzyang.github.io/posts/waitgroup/</link>
			<pubDate>Sun, 27 Jun 2021 09:30:47 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/waitgroup/</guid>
			<description>深入理解WaitGroup waitgroup主要是用来等待一些goroutine完成
数据结构 type WaitGroup struct { noCopy noCopy // 不允许拷贝，用go vet检测  // 高32位存储counter数量，低32位存储waiter数量，最后4个字节存储sema 	state1 [3]uint32 } 主要方法 Add func (wg *WaitGroup) Add(delta int) { // 获取statep和sema 	statep, semap := wg.state() if race.Enabled { _ = *statep // trigger nil deref early 	if delta &amp;lt; 0 { // Synchronize decrements with Wait. 	race.ReleaseMerge(unsafe.Pointer(wg)) } race.Disable() defer race.Enable() } // goroutine+delta，delta可能是负数 	state := atomic.AddUint64(statep, uint64(delta)&amp;lt;&amp;lt;32) v := int32(state &amp;gt;&amp;gt; 32) // 获取waiters 	w := uint32(state) if race.</description>
			<content type="html"><![CDATA[<h2 id="深入理解waitgroup">深入理解WaitGroup</h2>
<p>waitgroup主要是用来等待一些goroutine完成</p>
<h3 id="数据结构">数据结构</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">WaitGroup</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">noCopy</span> <span class="nx">noCopy</span>   <span class="c1">// 不允许拷贝，用go vet检测
</span><span class="c1"></span>
	<span class="c1">// 高32位存储counter数量，低32位存储waiter数量，最后4个字节存储sema
</span><span class="c1"></span>	<span class="nx">state1</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">uint32</span>
<span class="p">}</span>
</code></pre></div><h3 id="主要方法">主要方法</h3>
<h4 id="add">Add</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">delta</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 获取statep和sema
</span><span class="c1"></span>	<span class="nx">statep</span><span class="p">,</span> <span class="nx">semap</span> <span class="o">:=</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">state</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="o">*</span><span class="nx">statep</span> <span class="c1">// trigger nil deref early
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">delta</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Synchronize decrements with Wait.
</span><span class="c1"></span>			<span class="nx">race</span><span class="p">.</span><span class="nf">ReleaseMerge</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">wg</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
		<span class="k">defer</span> <span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// goroutine+delta，delta可能是负数
</span><span class="c1"></span>	<span class="nx">state</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint64</span><span class="p">(</span><span class="nx">statep</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">state</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span>
	<span class="c1">// 获取waiters
</span><span class="c1"></span>	<span class="nx">w</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="o">&amp;&amp;</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">==</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// The first increment must be synchronized with Wait.
</span><span class="c1"></span>		<span class="c1">// Need to model this as a read, because there can be
</span><span class="c1"></span>		<span class="c1">// several concurrent wg.counter transitions from 0.
</span><span class="c1"></span>		<span class="nx">race</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">semap</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// add后的counter不能为负数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: negative WaitGroup counter&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 此时wait已经执行(waiter&gt;0)，不能再执行Add
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span> <span class="o">==</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 没有waiter 直接return
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">v</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 到这里v=0， 并w&gt;0，这里状态又不一致，说明又有别的add改变了状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="o">*</span><span class="nx">statep</span> <span class="o">!=</span> <span class="nx">state</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup misuse: Add called concurrently with Wait&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 重置waiters为0
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">statep</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 开始批量释放信号量
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">;</span> <span class="nx">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">w</span><span class="o">--</span> <span class="p">{</span>
		<span class="nf">runtime_Semrelease</span><span class="p">(</span><span class="nx">semap</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="done">Done</h4>
<p>Done就很简单，相当于Add(-1)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="wait">Wait</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">statep</span><span class="p">,</span> <span class="nx">semap</span> <span class="o">:=</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">state</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="o">*</span><span class="nx">statep</span> <span class="c1">// trigger nil deref early
</span><span class="c1"></span>		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">state</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="nx">statep</span><span class="p">)</span>
		<span class="c1">// 获取counter和waiter的值
</span><span class="c1"></span>		<span class="nx">v</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">state</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="nx">w</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// counter为0，不需要等待
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">wg</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 增加waiter的count
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUint64</span><span class="p">(</span><span class="nx">statep</span><span class="p">,</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">state</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">semap</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="c1">// 阻塞的获取sema
</span><span class="c1"></span>			<span class="nf">runtime_Semacquire</span><span class="p">(</span><span class="nx">semap</span><span class="p">)</span>
			<span class="c1">// Add都结束了，但是又有Add执行了
</span><span class="c1"></span>			<span class="k">if</span> <span class="o">*</span><span class="nx">statep</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;sync: WaitGroup is reused before previous Wait has returned&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
				<span class="nx">race</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">wg</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go-深入理解Reflect</title>
			<link>https://leonzyang.github.io/posts/reflect/</link>
			<pubDate>Sun, 27 Jun 2021 09:28:31 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/reflect/</guid>
			<description>深入理解Reflect Go是一门静态语言，我们可以使用反射对不同类型的对象进行操作。
Type 我们可以通过TypeOf将一个对象转换成Type
t := reflect.TypeOf(1) fmt.Println(t) // int 首先我们看下Type的组成(下图中我们省略了一些字段)
type Type interface { // 返回第i个方法，超过范围，则panic 	Method(int) Method // 通过名称获取方法 	MethodByName(string) (Method, bool) // 方法数量 	NumMethod() int // 类型名 	Name() string // 返回包路径（完全路径） 	PkgPath() string // 类似unsafe.Sizeof 	Size() uintptr // 字符串表示，可能包含短包名 	String() string // 类型 	Kind() Kind // 如果该类型实现了u的接口，则返回true 	Implements(u Type) bool // 返回元素类型，如果kind不是slice,channel,map,pointer, 则painc 	Elem() Type // 第几个字段 	Field(i int) StructField FieldByIndex(index []int) StructField // 根据name返回字段细腻系 	FieldByName(name string) (StructField, bool) FieldByNameFunc(match func(string) bool) (StructField, bool) // 返回第i个参数类型 	In(i int) Type // 返回array类型的长度，如果不是，则panic 	Len() int // 返回field的数量 	NumField() int // 返回参数的数量 	NumIn() int } 可以看到Type是interface，接下来我们看下TypeOf</description>
			<content type="html"><![CDATA[<h2 id="深入理解reflect">深入理解Reflect</h2>
<p>Go是一门静态语言，我们可以使用反射对不同类型的对象进行操作。</p>
<h3 id="type">Type</h3>
<p>我们可以通过TypeOf将一个对象转换成Type</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// int
</span></code></pre></div><p>首先我们看下Type的组成(下图中我们省略了一些字段)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Type</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// 返回第i个方法，超过范围，则panic
</span><span class="c1"></span>	<span class="nf">Method</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="nx">Method</span>

	<span class="c1">// 通过名称获取方法
</span><span class="c1"></span>	<span class="nf">MethodByName</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">Method</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>

	<span class="c1">// 方法数量
</span><span class="c1"></span>	<span class="nf">NumMethod</span><span class="p">()</span> <span class="kt">int</span>

	<span class="c1">// 类型名
</span><span class="c1"></span>	<span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span>

	<span class="c1">// 返回包路径（完全路径）
</span><span class="c1"></span>	<span class="nf">PkgPath</span><span class="p">()</span> <span class="kt">string</span>

	<span class="c1">// 类似unsafe.Sizeof
</span><span class="c1"></span>	<span class="nf">Size</span><span class="p">()</span> <span class="kt">uintptr</span>

	<span class="c1">// 字符串表示，可能包含短包名
</span><span class="c1"></span>	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>

	<span class="c1">// 类型
</span><span class="c1"></span>	<span class="nf">Kind</span><span class="p">()</span> <span class="nx">Kind</span>

	<span class="c1">// 如果该类型实现了u的接口，则返回true
</span><span class="c1"></span>	<span class="nf">Implements</span><span class="p">(</span><span class="nx">u</span> <span class="nx">Type</span><span class="p">)</span> <span class="kt">bool</span>

	<span class="c1">// 返回元素类型，如果kind不是slice,channel,map,pointer, 则painc
</span><span class="c1"></span>	<span class="nf">Elem</span><span class="p">()</span> <span class="nx">Type</span>

	<span class="c1">// 第几个字段
</span><span class="c1"></span>	<span class="nf">Field</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">StructField</span>

	<span class="nf">FieldByIndex</span><span class="p">(</span><span class="nx">index</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="nx">StructField</span>

	<span class="c1">// 根据name返回字段细腻系
</span><span class="c1"></span>	<span class="nf">FieldByName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">StructField</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>

	<span class="nf">FieldByNameFunc</span><span class="p">(</span><span class="nx">match</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">StructField</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>

	<span class="c1">// 返回第i个参数类型
</span><span class="c1"></span>	<span class="nf">In</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Type</span>

	<span class="c1">// 返回array类型的长度，如果不是，则panic
</span><span class="c1"></span>	<span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span>

	<span class="c1">// 返回field的数量
</span><span class="c1"></span>	<span class="nf">NumField</span><span class="p">()</span> <span class="kt">int</span>

	<span class="c1">// 返回参数的数量
</span><span class="c1"></span>	<span class="nf">NumIn</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p>可以看到Type是interface，接下来我们看下TypeOf</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TypeOf</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Type</span> <span class="p">{</span>
	<span class="nx">eface</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">emptyInterface</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">))</span>
	<span class="k">return</span> <span class="nf">toType</span><span class="p">(</span><span class="nx">eface</span><span class="p">.</span><span class="nx">typ</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">toType</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">rtype</span><span class="p">)</span> <span class="nx">Type</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>
</code></pre></div><p>golang里面接口类型都是通过emptyInterface来表示的，其中rtype表示变量的类型，word指向数据的地址</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">emptyInterface</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">typ</span>  <span class="o">*</span><span class="nx">rtype</span>
	<span class="nx">word</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>
</code></pre></div><h3 id="value">Value</h3>
<p>我们可以通过ValueOf将一个类型转换成Value类型</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// 1
</span></code></pre></div><p>Value是一个结构体</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Value</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// value的type类型
</span><span class="c1"></span>	<span class="nx">typ</span> <span class="o">*</span><span class="nx">rtype</span>

    <span class="c1">// 指针指向数据
</span><span class="c1"></span>	<span class="nx">ptr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>

	<span class="nx">flag</span>
<span class="p">}</span>
</code></pre></div><h4 id="valueof">ValueOf</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ValueOf</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Value</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">Value</span><span class="p">{}</span>
	<span class="p">}</span>

    <span class="c1">// 从栈逃逸到堆上面
</span><span class="c1"></span>	<span class="nf">escapes</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>

	<span class="k">return</span> <span class="nf">unpackEface</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">unpackEface</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Value</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyInterface</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">))</span>
	<span class="c1">// NOTE: don&#39;t read e.word until we know whether it is really a pointer or not.
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">typ</span>
	<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">Value</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="nx">f</span> <span class="o">:=</span> <span class="nf">flag</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Kind</span><span class="p">())</span>
	<span class="k">if</span> <span class="nf">ifaceIndir</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">f</span> <span class="o">|=</span> <span class="nx">flagIndir</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">Value</span><span class="p">{</span><span class="nx">t</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">word</span><span class="p">,</span> <span class="nx">f</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>可以看到ValueOf实际上也是先转成emptyInterface，然后再生成Value</p>
<h3 id="用法">用法</h3>
<p>下面我们通过reflect的用法来具体分析下</p>
<h4 id="类型转换">类型转换</h4>
<p>下面的转换是int =&gt; interface{} =&gt; emptyInterface =&gt; Value =&gt; Interface =&gt; int</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">vv</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Interface</span><span class="p">().(</span><span class="kt">int</span><span class="p">)</span>
</code></pre></div><h4 id="修改数据">修改数据</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">vv</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">)</span>
    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">vv</span><span class="p">.</span><span class="nf">Elem</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nf">CanSet</span><span class="p">())</span>   <span class="c1">// true
</span><span class="c1"></span>	<span class="nx">p</span><span class="p">.</span><span class="nf">SetInt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>   <span class="c1">// 2
</span></code></pre></div><h5 id="elem">Elem</h5>
<p>Elem返回v指针指向的实际变量，如果不是接口或者指针类型，会Panic</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">Elem</span><span class="p">()</span> <span class="nx">Value</span> <span class="p">{</span>
	<span class="nx">k</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">kind</span><span class="p">()</span>
	<span class="k">switch</span> <span class="nx">k</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">Interface</span><span class="p">:</span>
		<span class="kd">var</span> <span class="nx">eface</span> <span class="kd">interface</span><span class="p">{}</span>
		<span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">typ</span><span class="p">.</span><span class="nf">NumMethod</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">eface</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span><span class="p">{})(</span><span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">eface</span> <span class="p">=</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{})(</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kd">interface</span> <span class="p">{</span>
				<span class="nf">M</span><span class="p">()</span>
			<span class="p">})(</span><span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="nx">x</span> <span class="o">:=</span> <span class="nf">unpackEface</span><span class="p">(</span><span class="nx">eface</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">flag</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">x</span><span class="p">.</span><span class="nx">flag</span> <span class="o">|=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">flag</span><span class="p">.</span><span class="nf">ro</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">x</span>
	<span class="k">case</span> <span class="nx">Ptr</span><span class="p">:</span>
		<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span>
		<span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">flag</span><span class="o">&amp;</span><span class="nx">flagIndir</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">ptr</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">ptr</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// The returned value&#39;s address is v&#39;s value.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ptr</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">Value</span><span class="p">{}</span>
		<span class="p">}</span>
		<span class="nx">tt</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">ptrType</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">typ</span><span class="p">))</span>
		<span class="nx">typ</span> <span class="o">:=</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">elem</span>
		<span class="nx">fl</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">flag</span><span class="o">&amp;</span><span class="nx">flagRO</span> <span class="p">|</span> <span class="nx">flagIndir</span> <span class="p">|</span> <span class="nx">flagAddr</span>
		<span class="nx">fl</span> <span class="o">|=</span> <span class="nf">flag</span><span class="p">(</span><span class="nx">typ</span><span class="p">.</span><span class="nf">Kind</span><span class="p">())</span>
		<span class="k">return</span> <span class="nx">Value</span><span class="p">{</span><span class="nx">typ</span><span class="p">,</span> <span class="nx">ptr</span><span class="p">,</span> <span class="nx">fl</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="nb">panic</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ValueError</span><span class="p">{</span><span class="s">&#34;reflect.Value.Elem&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">kind</span><span class="p">()})</span>
<span class="p">}</span>
</code></pre></div><h4 id="implements">Implements</h4>
<p>我们可以通过Implements方法判断某些类型是否实现了全部的方法</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Demo</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Demo</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;demo error&#34;</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">((</span><span class="o">*</span><span class="kt">error</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)).</span><span class="nf">Elem</span><span class="p">()</span>  <span class="c1">// 获取接口的类型
</span><span class="c1"></span>	<span class="nx">dPtr</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Demo</span><span class="p">{})</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">Demo</span><span class="p">{})</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dPtr</span><span class="p">.</span><span class="nf">Implements</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span>   <span class="c1">// true
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nf">Implements</span><span class="p">(</span><span class="nx">r</span><span class="p">))</span>      <span class="c1">// false
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h5 id="具体方法">具体方法</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">rtype</span><span class="p">)</span> <span class="nf">Implements</span><span class="p">(</span><span class="nx">u</span> <span class="nx">Type</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// 如果是nil，则会panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">u</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: nil type passed to Type.Implements&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果不是指针类型，会panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">u</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">Interface</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: non-interface type passed to Type.Implements&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">implements</span><span class="p">(</span><span class="nx">u</span><span class="p">.(</span><span class="o">*</span><span class="nx">rtype</span><span class="p">),</span> <span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">implements</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">V</span> <span class="o">*</span><span class="nx">rtype</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">T</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">Interface</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">interfaceType</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">T</span><span class="p">))</span>
	<span class="c1">// 如果u的方法数量为0，则返回true
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">methods</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// 两种方式都一样，通过遍历V和T中的方法来判断是否满足条件，methods是有序的
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">V</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">==</span> <span class="nx">Interface</span> <span class="p">{</span>
		<span class="nx">v</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">interfaceType</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">V</span><span class="p">))</span>
		<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">methods</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">tm</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">methods</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="nx">tmName</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">nameOff</span><span class="p">(</span><span class="nx">tm</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
			<span class="nx">vm</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">v</span><span class="p">.</span><span class="nx">methods</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
			<span class="nx">vmName</span> <span class="o">:=</span> <span class="nx">V</span><span class="p">.</span><span class="nf">nameOff</span><span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">vmName</span><span class="p">.</span><span class="nf">name</span><span class="p">()</span> <span class="o">==</span> <span class="nx">tmName</span><span class="p">.</span><span class="nf">name</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">V</span><span class="p">.</span><span class="nf">typeOff</span><span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nx">typ</span><span class="p">)</span> <span class="o">==</span> <span class="nx">t</span><span class="p">.</span><span class="nf">typeOff</span><span class="p">(</span><span class="nx">tm</span><span class="p">.</span><span class="nx">typ</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">tmName</span><span class="p">.</span><span class="nf">isExported</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">tmPkgPath</span> <span class="o">:=</span> <span class="nx">tmName</span><span class="p">.</span><span class="nf">pkgPath</span><span class="p">()</span>
					<span class="k">if</span> <span class="nx">tmPkgPath</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
						<span class="nx">tmPkgPath</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">pkgPath</span><span class="p">.</span><span class="nf">name</span><span class="p">()</span>
					<span class="p">}</span>
					<span class="nx">vmPkgPath</span> <span class="o">:=</span> <span class="nx">vmName</span><span class="p">.</span><span class="nf">pkgPath</span><span class="p">()</span>
					<span class="k">if</span> <span class="nx">vmPkgPath</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
						<span class="nx">vmPkgPath</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">pkgPath</span><span class="p">.</span><span class="nf">name</span><span class="p">()</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="nx">tmPkgPath</span> <span class="o">!=</span> <span class="nx">vmPkgPath</span> <span class="p">{</span>
						<span class="k">continue</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">i</span><span class="o">++</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">methods</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">return</span> <span class="kc">true</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">V</span><span class="p">.</span><span class="nf">uncommon</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">vmethods</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">methods</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">mcount</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">tm</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">methods</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">tmName</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">nameOff</span><span class="p">(</span><span class="nx">tm</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
		<span class="nx">vm</span> <span class="o">:=</span> <span class="nx">vmethods</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
		<span class="nx">vmName</span> <span class="o">:=</span> <span class="nx">V</span><span class="p">.</span><span class="nf">nameOff</span><span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">vmName</span><span class="p">.</span><span class="nf">name</span><span class="p">()</span> <span class="o">==</span> <span class="nx">tmName</span><span class="p">.</span><span class="nf">name</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">V</span><span class="p">.</span><span class="nf">typeOff</span><span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nx">mtyp</span><span class="p">)</span> <span class="o">==</span> <span class="nx">t</span><span class="p">.</span><span class="nf">typeOff</span><span class="p">(</span><span class="nx">tm</span><span class="p">.</span><span class="nx">typ</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">tmName</span><span class="p">.</span><span class="nf">isExported</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">tmPkgPath</span> <span class="o">:=</span> <span class="nx">tmName</span><span class="p">.</span><span class="nf">pkgPath</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">tmPkgPath</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
					<span class="nx">tmPkgPath</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">pkgPath</span><span class="p">.</span><span class="nf">name</span><span class="p">()</span>
				<span class="p">}</span>
				<span class="nx">vmPkgPath</span> <span class="o">:=</span> <span class="nx">vmName</span><span class="p">.</span><span class="nf">pkgPath</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">vmPkgPath</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
					<span class="nx">vmPkgPath</span> <span class="p">=</span> <span class="nx">V</span><span class="p">.</span><span class="nf">nameOff</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">pkgPath</span><span class="p">).</span><span class="nf">name</span><span class="p">()</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">tmPkgPath</span> <span class="o">!=</span> <span class="nx">vmPkgPath</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">i</span><span class="o">++</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">methods</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></div><h4 id="方法调用">方法调用</h4>
<p>我们如何通过反射去调用方法</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">Sum</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Kind</span><span class="p">())</span> <span class="c1">// func
</span><span class="c1"></span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Type</span><span class="p">().</span><span class="nf">NumIn</span><span class="p">())</span> <span class="c1">// 参数数量2
</span><span class="c1"></span>	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Call</span><span class="p">([]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">{</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="mi">2</span><span class="p">)})</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">Int</span><span class="p">())</span> <span class="c1">// 3
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h5 id="call">Call</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">Call</span><span class="p">(</span><span class="nx">in</span> <span class="p">[]</span><span class="nx">Value</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Value</span> <span class="p">{</span>
	<span class="nx">v</span><span class="p">.</span><span class="nf">mustBe</span><span class="p">(</span><span class="nx">Func</span><span class="p">)</span>   <span class="c1">//  必须是盘数
</span><span class="c1"></span>	<span class="nx">v</span><span class="p">.</span><span class="nf">mustBeExported</span><span class="p">()</span>  <span class="c1">// 必须是可导出的
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s">&#34;Call&#34;</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">call</span><span class="p">(</span><span class="nx">op</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">in</span> <span class="p">[]</span><span class="nx">Value</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Value</span> <span class="p">{</span>
	<span class="c1">// 获取type的值
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">funcType</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">typ</span><span class="p">))</span>
	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">fn</span>       <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
		<span class="nx">rcvr</span>     <span class="nx">Value</span>
		<span class="nx">rcvrtype</span> <span class="o">*</span><span class="nx">rtype</span>
	<span class="p">)</span>
	<span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">flag</span><span class="o">&amp;</span><span class="nx">flagMethod</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rcvr</span> <span class="p">=</span> <span class="nx">v</span>
		<span class="nx">rcvrtype</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">fn</span> <span class="p">=</span> <span class="nf">methodReceiver</span><span class="p">(</span><span class="nx">op</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">flag</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="nx">flagMethodShift</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">flag</span><span class="o">&amp;</span><span class="nx">flagIndir</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">fn</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">fn</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span>
	<span class="p">}</span>

	<span class="c1">// 检查是否nil
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect.Value.Call: call of nil function&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 判断是否是CallSlice，比如len(arr), in是arr[0], arr[1], arr[2]...
</span><span class="c1"></span>	<span class="nx">isSlice</span> <span class="o">:=</span> <span class="nx">op</span> <span class="o">==</span> <span class="s">&#34;CallSlice&#34;</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">NumIn</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">isSlice</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nf">IsVariadic</span><span class="p">()</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: CallSlice of non-variadic function&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: CallSlice with too few input arguments&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: CallSlice with too many input arguments&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">IsVariadic</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">n</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: Call with too few input arguments&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">t</span><span class="p">.</span><span class="nf">IsVariadic</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: Call with too many input arguments&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">==</span> <span class="nx">Invalid</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: &#34;</span> <span class="o">+</span> <span class="nx">op</span> <span class="o">+</span> <span class="s">&#34; using zero Value argument&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">xt</span><span class="p">,</span> <span class="nx">targ</span> <span class="o">:=</span> <span class="nx">in</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">Type</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nf">In</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="p">!</span><span class="nx">xt</span><span class="p">.</span><span class="nf">AssignableTo</span><span class="p">(</span><span class="nx">targ</span><span class="p">)</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: &#34;</span> <span class="o">+</span> <span class="nx">op</span> <span class="o">+</span> <span class="s">&#34; using &#34;</span> <span class="o">+</span> <span class="nx">xt</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; as type &#34;</span> <span class="o">+</span> <span class="nx">targ</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">isSlice</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nf">IsVariadic</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// prepare slice for remaining values
</span><span class="c1"></span>		<span class="nx">m</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span> <span class="o">-</span> <span class="nx">n</span>
		<span class="nx">slice</span> <span class="o">:=</span> <span class="nf">MakeSlice</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">In</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
		<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">In</span><span class="p">(</span><span class="nx">n</span><span class="p">).</span><span class="nf">Elem</span><span class="p">()</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">x</span> <span class="o">:=</span> <span class="nx">in</span><span class="p">[</span><span class="nx">n</span><span class="o">+</span><span class="nx">i</span><span class="p">]</span>
			<span class="k">if</span> <span class="nx">xt</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.</span><span class="nf">Type</span><span class="p">();</span> <span class="p">!</span><span class="nx">xt</span><span class="p">.</span><span class="nf">AssignableTo</span><span class="p">(</span><span class="nx">elem</span><span class="p">)</span> <span class="p">{</span>
				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect: cannot use &#34;</span> <span class="o">+</span> <span class="nx">xt</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; as type &#34;</span> <span class="o">+</span> <span class="nx">elem</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; in &#34;</span> <span class="o">+</span> <span class="nx">op</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">slice</span><span class="p">.</span><span class="nf">Index</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nf">Set</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">origIn</span> <span class="o">:=</span> <span class="nx">in</span>
		<span class="nx">in</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">in</span><span class="p">[:</span><span class="nx">n</span><span class="p">],</span> <span class="nx">origIn</span><span class="p">)</span>
		<span class="nx">in</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">slice</span>
	<span class="p">}</span>

	<span class="nx">nin</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">)</span>
	<span class="c1">// 检查参数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">nin</span> <span class="o">!=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">NumIn</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;reflect.Value.Call: wrong argument count&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 开始进入准备阶段
</span><span class="c1"></span>	<span class="nx">nout</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">NumOut</span><span class="p">()</span>

	<span class="c1">// 计算参数和返回值锁需要占的空间大小
</span><span class="c1"></span>	<span class="nx">frametype</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">retOffset</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">framePool</span> <span class="o">:=</span> <span class="nf">funcLayout</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">rcvrtype</span><span class="p">)</span>

	<span class="c1">// Allocate a chunk of memory for frame.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">args</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="k">if</span> <span class="nx">nout</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">args</span> <span class="p">=</span> <span class="nx">framePool</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 如果有返回参数就不能使用pool，需要单独分配args
</span><span class="c1"></span>		<span class="nx">args</span> <span class="p">=</span> <span class="nf">unsafe_New</span><span class="p">(</span><span class="nx">frametype</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">off</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="c1">// 拷贝输入到args
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">rcvrtype</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">storeRcvr</span><span class="p">(</span><span class="nx">rcvr</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
		<span class="nx">off</span> <span class="p">=</span> <span class="nx">ptrSize</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
		<span class="nx">v</span><span class="p">.</span><span class="nf">mustBeExported</span><span class="p">()</span>
		<span class="nx">targ</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">In</span><span class="p">(</span><span class="nx">i</span><span class="p">).(</span><span class="o">*</span><span class="nx">rtype</span><span class="p">)</span>
		<span class="nx">a</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">targ</span><span class="p">.</span><span class="nx">align</span><span class="p">)</span>
		<span class="nx">off</span> <span class="p">=</span> <span class="p">(</span><span class="nx">off</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">targ</span><span class="p">.</span><span class="nx">size</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Not safe to compute args+off pointing at 0 bytes,
</span><span class="c1"></span>			<span class="c1">// because that might point beyond the end of the frame,
</span><span class="c1"></span>			<span class="c1">// but we still need to call assignTo to check assignability.
</span><span class="c1"></span>			<span class="nx">v</span><span class="p">.</span><span class="nf">assignTo</span><span class="p">(</span><span class="s">&#34;reflect.Value.Call&#34;</span><span class="p">,</span> <span class="nx">targ</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">addr</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="s">&#34;n &gt; 0&#34;</span><span class="p">)</span>
		<span class="nx">v</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">assignTo</span><span class="p">(</span><span class="s">&#34;reflect.Value.Call&#34;</span><span class="p">,</span> <span class="nx">targ</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">flag</span><span class="o">&amp;</span><span class="nx">flagIndir</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">targ</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">ptr</span>
		<span class="p">}</span>
		<span class="nx">off</span> <span class="o">+=</span> <span class="nx">n</span>
	<span class="p">}</span>

	<span class="c1">// 开始调用
</span><span class="c1"></span>	<span class="nf">call</span><span class="p">(</span><span class="nx">frametype</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">frametype</span><span class="p">.</span><span class="nx">size</span><span class="p">),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">retOffset</span><span class="p">))</span>

	<span class="c1">// For testing; see TestCallMethodJump.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">callGC</span> <span class="p">{</span>
		<span class="nx">runtime</span><span class="p">.</span><span class="nf">GC</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">ret</span> <span class="p">[]</span><span class="nx">Value</span>
	<span class="k">if</span> <span class="nx">nout</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 清除args，将args放回到pool中
</span><span class="c1"></span>		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">frametype</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
		<span class="nx">framePool</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Zero the now unused input area of args,
</span><span class="c1"></span>		<span class="c1">// because the Values returned by this function contain pointers to the args object,
</span><span class="c1"></span>		<span class="c1">// and will thus keep the args object alive indefinitely.
</span><span class="c1"></span>		<span class="nf">typedmemclrpartial</span><span class="p">(</span><span class="nx">frametype</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">retOffset</span><span class="p">)</span>

		<span class="c1">// 将返回值写入到ret中
</span><span class="c1"></span>		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">nout</span><span class="p">)</span>
		<span class="nx">off</span> <span class="p">=</span> <span class="nx">retOffset</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nout</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">tv</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Out</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">a</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">tv</span><span class="p">.</span><span class="nf">Align</span><span class="p">())</span>
			<span class="nx">off</span> <span class="p">=</span> <span class="p">(</span><span class="nx">off</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="nx">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">tv</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">fl</span> <span class="o">:=</span> <span class="nx">flagIndir</span> <span class="p">|</span> <span class="nf">flag</span><span class="p">(</span><span class="nx">tv</span><span class="p">.</span><span class="nf">Kind</span><span class="p">())</span>
				<span class="nx">ret</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">Value</span><span class="p">{</span><span class="nx">tv</span><span class="p">.</span><span class="nf">common</span><span class="p">(),</span> <span class="nf">add</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="s">&#34;tv.Size() != 0&#34;</span><span class="p">),</span> <span class="nx">fl</span><span class="p">}</span>
				<span class="c1">// Note: this does introduce false sharing between results -
</span><span class="c1"></span>				<span class="c1">// if any result is live, they are all live.
</span><span class="c1"></span>				<span class="c1">// (And the space for the args is live as well, but as we&#39;ve
</span><span class="c1"></span>				<span class="c1">// cleared that space it isn&#39;t as big a deal.)
</span><span class="c1"></span>			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="c1">// For zero-sized return value, args+off may point to the next object.
</span><span class="c1"></span>				<span class="c1">// In this case, return the zero value instead.
</span><span class="c1"></span>				<span class="nx">ret</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">Zero</span><span class="p">(</span><span class="nx">tv</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">off</span> <span class="o">+=</span> <span class="nx">tv</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></div><h4 id="访问结构体私有属性">访问结构体私有属性</h4>
<p>引入其他包中结构体是无法直接访问其私有属性的，我们可以通过reflect进行访问</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 这个结构体在demo/demo.go中
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Demo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">name</span>    <span class="kt">string</span>
    <span class="nx">age</span>    <span class="kt">int8</span>
<span class="p">}</span>


<span class="c1">// main.go
</span><span class="c1"></span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;demo&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;reflect&#34;</span>
	<span class="s">&#34;unsafe&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">d</span> <span class="nx">demo</span><span class="p">.</span><span class="nx">Demo</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">)</span>
	<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Elem</span><span class="p">()</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nf">Field</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">elem</span><span class="p">.</span><span class="nf">Field</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1">// &#34;&#34;, 0
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h5 id="如果我们想修改私有变量的值怎么变">如果我们想修改私有变量的值怎么变</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">change</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">demo</span><span class="p">.</span><span class="nx">Demo</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">dd</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 第一个字段，offset为0
</span><span class="c1"></span>	<span class="nx">p</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">dd</span><span class="p">)</span> <span class="o">+</span> <span class="nx">v</span><span class="p">))</span>  
	<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="s">&#34;a&#34;</span>   <span class="c1">// 这时name就变成a了
</span><span class="c1"></span>
	<span class="c1">// uintptr(16) 是因为name是string类型，需要占两个字节
</span><span class="c1"></span>	<span class="nx">age</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">dd</span><span class="p">)</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">16</span><span class="p">)))</span>

	<span class="o">*</span><span class="nx">age</span> <span class="p">=</span> <span class="mi">11</span> <span class="c1">// age就变成 11了
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go-深入理解pool</title>
			<link>https://leonzyang.github.io/posts/pool/</link>
			<pubDate>Sun, 27 Jun 2021 09:28:25 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/pool/</guid>
			<description>深入理解pool sync.Pool 是用来保存和获取临时对象的
结构 type Pool struct { noCopy noCopy // 无法拷贝，保证唯一  local unsafe.Pointer // 本地pool，实际类型是[P]poolLocal 	localSize uintptr // 本地pool的大小  // get为空的时候，使用new去创建一个object 	New func() interface{} } type poolLocal struct { poolLocalInternal // Prevents false sharing on widespread platforms with 	// 128 mod (cache line size) = 0 . 	pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte } type poolLocalInternal struct { private interface{} // 私有数据，不会被其他P获取到 	shared []interface{} // 共享数据，会被其他P获取 	Mutex // 锁 } 使用 put func (p *Pool) Put(x interface{}) { if x == nil { return } if race.</description>
			<content type="html"><![CDATA[<h2 id="深入理解pool">深入理解pool</h2>
<p>sync.Pool 是用来保存和获取临时对象的</p>
<h3 id="结构">结构</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Pool</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">noCopy</span> <span class="nx">noCopy</span>  <span class="c1">// 无法拷贝，保证唯一
</span><span class="c1"></span>
	<span class="nx">local</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 本地pool，实际类型是[P]poolLocal
</span><span class="c1"></span>	<span class="nx">localSize</span> <span class="kt">uintptr</span>        <span class="c1">// 本地pool的大小
</span><span class="c1"></span>
    <span class="c1">// get为空的时候，使用new去创建一个object
</span><span class="c1"></span>	<span class="nx">New</span> <span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">poolLocal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">poolLocalInternal</span>

	<span class="c1">// Prevents false sharing on widespread platforms with
</span><span class="c1"></span>	<span class="c1">// 128 mod (cache line size) = 0 .
</span><span class="c1"></span>	<span class="nx">pad</span> <span class="p">[</span><span class="mi">128</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">poolLocalInternal</span><span class="p">{})</span><span class="o">%</span><span class="mi">128</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">poolLocalInternal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">private</span> <span class="kd">interface</span><span class="p">{}</span>   <span class="c1">// 私有数据，不会被其他P获取到
</span><span class="c1"></span>	<span class="nx">shared</span>  <span class="p">[]</span><span class="kd">interface</span><span class="p">{}</span> <span class="c1">// 共享数据，会被其他P获取
</span><span class="c1"></span>	<span class="nx">Mutex</span>                 <span class="c1">// 锁
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><h3 id="使用">使用</h3>
<h4 id="put">put</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nf">fastrand</span><span class="p">()</span><span class="o">%</span><span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Randomly drop x on floor.
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">ReleaseMerge</span><span class="p">(</span><span class="nf">poolRaceAddr</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Disable</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">// 获取poolLocal
</span><span class="c1"></span>    <span class="nx">l</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pin</span><span class="p">()</span>
    <span class="c1">// 如果私有数据没有，则将x复制给private
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="nx">x</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="c1">// 解除抢占
</span><span class="c1"></span>	<span class="nf">runtime_procUnpin</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 说明private不为nil，将x直接追加到shared里面
</span><span class="c1"></span>        <span class="nx">l</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">shared</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
		<span class="nx">l</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">race</span><span class="p">.</span><span class="nx">Enabled</span> <span class="p">{</span>
		<span class="nx">race</span><span class="p">.</span><span class="nf">Enable</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="pin">pin</h4>
<p>pin的功能是绑定goroutine到固定P上，并且不允许抢占, 这里利用m.locks 标记</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">pin</span><span class="p">()</span> <span class="o">*</span><span class="nx">poolLocal</span> <span class="p">{</span>
	<span class="c1">// 返回绑定后P的id, 不允许抢占， 相关函数在runtime/proc.go中sync_runtime_procPin
</span><span class="c1"></span>	<span class="nx">pid</span> <span class="o">:=</span> <span class="nf">runtime_procPin</span><span class="p">()</span>
	<span class="c1">// 本地pool的大小
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span><span class="p">)</span>
	<span class="c1">// 本地的pool
</span><span class="c1"></span>	<span class="nx">l</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>
	<span class="c1">// 当前的P有pool，直接返回poolLocal        
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">pid</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 需要重新分配，因为GOMAXPROCS在GC的时候改变了
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pinSlow</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h4 id="pinslow">pinSlow</h4>
<p>再次判断获取下poolLocal</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">pinSlow</span><span class="p">()</span> <span class="o">*</span><span class="nx">poolLocal</span> <span class="p">{</span>
	<span class="c1">// 解除抢占
</span><span class="c1"></span>	<span class="nf">runtime_procUnpin</span><span class="p">()</span>
	<span class="nx">allPoolsMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">allPoolsMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">pid</span> <span class="o">:=</span> <span class="nf">runtime_procPin</span><span class="p">()</span>
	<span class="c1">// 当我们在绑定的时候，poolCleanup不会被调用
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>
	<span class="c1">// 再次判断下
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">pid</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 走到这里，分两种情况：
</span><span class="c1"></span>	<span class="c1">// 1. Pool首次调用
</span><span class="c1"></span>	<span class="c1">// 2. GOMAXPROCS 发生改变了
</span><span class="c1"></span>
	<span class="c1">// p.local为空，说明是新增的Pool，append到allPools
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">allPools</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">allPools</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 如果GOMAXPROCS在GC的时候改变了，我们会重新分配, GOMAXPROCS(0)会返回当前的Procs
</span><span class="c1"></span>	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">local</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">poolLocal</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="c1">// 存储local和localsize
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">local</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">local</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>     
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">local</span><span class="p">[</span><span class="nx">pid</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><h4 id="poolcleanup">poolCleanup</h4>
<p>清除pool，这里比较暴力，直接全部清除</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">poolCleanup</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// poolCleanup执行的时候会在GC开始的时候STW
</span><span class="c1"></span>    <span class="c1">// 将所有内容清空主要有两个原因：
</span><span class="c1"></span>    <span class="c1">// 1. 防止错误的保留整个Pools
</span><span class="c1"></span>    <span class="c1">// 2. 如果GC和l.shared Put/Get同时发生，那么就会保留整个Pool，下个内存的消耗将增加一倍
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allPools</span> <span class="p">{</span>
		<span class="nx">allPools</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="c1">// 遍历所有local pool
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">l</span> <span class="o">:=</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">local</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">l</span><span class="p">.</span><span class="nx">shared</span> <span class="p">{</span>
				<span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="p">}</span>
			<span class="nx">l</span><span class="p">.</span><span class="nx">shared</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">local</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">allPools</span> <span class="p">=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Pool</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><h3 id="总结">总结</h3>
<p>sync.Pool还是挺简单的，Pool内存清除是发生在GC的时候</p>
]]></content>
		</item>
		
		<item>
			<title>Go-深入理解Panic</title>
			<link>https://leonzyang.github.io/posts/panic/</link>
			<pubDate>Sun, 27 Jun 2021 09:28:12 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/panic/</guid>
			<description>深入理解Panic 数据结构 //go:notinheap type _panic struct { argp unsafe.Pointer // 对应panic函数的指针 	arg interface{} // panic的参数 	link *_panic // 链接上一个panic，用链表存储 	recovered bool // 是否已被recovery 	aborted bool // 是否已中止 } panic具体调用的函数，我们可以用个例子写出
package main func main(){ panic(&amp;#34;error&amp;#34;) } # go tool compile -S main.go ... 0x0028 00040 (panic_demo.go:4)	LEAQ	&amp;#34;&amp;#34;.statictmp_0(SB), AX 0x002f 00047 (panic_demo.go:4)	PCDATA	$2, $0 0x002f 00047 (panic_demo.go:4)	MOVQ	AX, 8(SP) 0x0034 00052 (panic_demo.go:4)	CALL	runtime.gopanic(SB) ... 可以看到是调用的gopanic函数，那我们看下gopanic函数做了什么</description>
			<content type="html"><![CDATA[<h2 id="深入理解panic">深入理解Panic</h2>
<h3 id="数据结构">数据结构</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">_panic</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">argp</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 对应panic函数的指针
</span><span class="c1"></span>	<span class="nx">arg</span>       <span class="kd">interface</span><span class="p">{}</span>    <span class="c1">// panic的参数
</span><span class="c1"></span>	<span class="nx">link</span>      <span class="o">*</span><span class="nx">_panic</span>        <span class="c1">// 链接上一个panic，用链表存储
</span><span class="c1"></span>	<span class="nx">recovered</span> <span class="kt">bool</span>           <span class="c1">// 是否已被recovery
</span><span class="c1"></span>	<span class="nx">aborted</span>   <span class="kt">bool</span>           <span class="c1">// 是否已中止
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>panic具体调用的函数，我们可以用个例子写出</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;error&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># go tool compile -S main.go</span>

    ...
    0x0028 <span class="m">00040</span> <span class="o">(</span>panic_demo.go:4<span class="o">)</span>	LEAQ	<span class="s2">&#34;&#34;</span>.statictmp_0<span class="o">(</span>SB<span class="o">)</span>, AX
    0x002f <span class="m">00047</span> <span class="o">(</span>panic_demo.go:4<span class="o">)</span>	PCDATA	<span class="nv">$2</span>, <span class="nv">$0</span>
    0x002f <span class="m">00047</span> <span class="o">(</span>panic_demo.go:4<span class="o">)</span>	MOVQ	AX, 8<span class="o">(</span>SP<span class="o">)</span>
    0x0034 <span class="m">00052</span> <span class="o">(</span>panic_demo.go:4<span class="o">)</span>	CALL	runtime.gopanic<span class="o">(</span>SB<span class="o">)</span>
    ...
</code></pre></div><p>可以看到是调用的gopanic函数，那我们看下gopanic函数做了什么</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gopanic</span><span class="p">(</span><span class="nx">e</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>     <span class="c1">// 获取当前goroutine的指针
</span><span class="c1"></span>	<span class="c1">//...
</span><span class="c1"></span>
	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">_panic</span>           <span class="c1">// 定义了个_panic的结构体
</span><span class="c1"></span>	<span class="nx">p</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">e</span>      
	<span class="nx">p</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span>  
	<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">_panic</span><span class="p">)(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)))</span>

	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

	<span class="c1">// 处理所有的defer 
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>       <span class="c1">// 获取defer，如果没有则退出
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c1">// 如果defer 被上一个panic或者goexit 触发，那么这里会触发一个新的panic
</span><span class="c1"></span>		<span class="c1">// 之前的painc的会标记为中止
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">started</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">aborted</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span>
			<span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
			<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="c1">// 将defer标记为start
</span><span class="c1"></span>		<span class="nx">d</span><span class="p">.</span><span class="nx">started</span> <span class="p">=</span> <span class="kc">true</span>

		<span class="c1">// 将defer的_panic标记为本次panic，如果后面出现新的panic（对应上面那个if函数 d.started），那么会找到本次panic，并且将其标记为中止
</span><span class="c1"></span>		<span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">_panic</span><span class="p">)(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)))</span>

		<span class="nx">p</span><span class="p">.</span><span class="nx">argp</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">getargp</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
		
		<span class="c1">// 调用defer函数
</span><span class="c1"></span>		<span class="nf">reflectcall</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">fn</span><span class="p">),</span> <span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">))</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">argp</span> <span class="p">=</span> <span class="kc">nil</span>

		<span class="c1">// reflectcall did not panic. Remove d.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="o">!=</span> <span class="nx">d</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad defer entry in panic&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>

		<span class="c1">// trigger shrinkage to test stack copy. See stack_test.go:TestStackPanic
</span><span class="c1"></span>		<span class="c1">//GC()
</span><span class="c1"></span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">pc</span>
		<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">sp</span><span class="p">)</span> <span class="c1">// must be pointer so it gets adjusted during stack copy
</span><span class="c1"></span>		<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">recovered</span> <span class="p">{</span>
			<span class="c1">// 处理recovery
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

			<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">link</span>
			<span class="c1">// 如果panic 被中止掉，那么从链表中将其删除
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">aborted</span> <span class="p">{</span>
				<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">link</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// must be done with signal
</span><span class="c1"></span>				<span class="nx">gp</span><span class="p">.</span><span class="nx">sig</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">}</span>

			<span class="c1">// 将堆栈信息传输给recovery
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">sigcode0</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sp</span><span class="p">)</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">sigcode1</span> <span class="p">=</span> <span class="nx">pc</span>
			<span class="nf">mcall</span><span class="p">(</span><span class="nx">recovery</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;recovery failed&#34;</span><span class="p">)</span> <span class="c1">// mcall should not return
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// ran out of deferred calls - old-school panic now
</span><span class="c1"></span>	<span class="c1">// Because it is unsafe to call arbitrary user code after freezing
</span><span class="c1"></span>	<span class="c1">// the world, we call preprintpanics to invoke all necessary Error
</span><span class="c1"></span>	<span class="c1">// and String methods to prepare the panic strings before startpanic.
</span><span class="c1"></span>	<span class="nf">preprintpanics</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">)</span>

	<span class="nf">fatalpanic</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">)</span> <span class="c1">// 不可恢复的panic，最后exit 返回2
</span><span class="c1"></span>	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span>      <span class="c1">// not reached
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="fatalpanic">fatalpanic</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:nosplit  跳过堆栈溢出检测
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">fatalpanic</span><span class="p">(</span><span class="nx">msgs</span> <span class="o">*</span><span class="nx">_panic</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">docrash</span> <span class="kt">bool</span>
	<span class="c1">// Switch to the system stack to avoid any stack growth, which
</span><span class="c1"></span>	<span class="c1">// may make things worse if the runtime is in a bad state.
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nf">startpanic_m</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">msgs</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// There were panic messages and startpanic_m
</span><span class="c1"></span>			<span class="c1">// says it&#39;s okay to try to print them.
</span><span class="c1"></span>
			<span class="c1">// startpanic_m set panicking, which will
</span><span class="c1"></span>			<span class="c1">// block main from exiting, so now OK to
</span><span class="c1"></span>			<span class="c1">// decrement runningPanicDefers.
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

			<span class="nf">printpanics</span><span class="p">(</span><span class="nx">msgs</span><span class="p">)</span>  <span class="c1">// 递归打印panic信息
</span><span class="c1"></span>		<span class="p">}</span>

		<span class="nx">docrash</span> <span class="p">=</span> <span class="nf">dopanic_m</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">docrash</span> <span class="p">{</span>
		<span class="c1">// By crashing outside the above systemstack call, debuggers
</span><span class="c1"></span>		<span class="c1">// will not be confused when generating a backtrace.
</span><span class="c1"></span>		<span class="c1">// Function crash is marked nosplit to avoid stack growth.
</span><span class="c1"></span>		<span class="nf">crash</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// not reached
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go-深入理解HTTP</title>
			<link>https://leonzyang.github.io/posts/gohttp/</link>
			<pubDate>Sun, 27 Jun 2021 09:26:06 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/gohttp/</guid>
			<description>深入理解HTTP HTTP服务是我们经常用的一个服务，这里就带大家看下Go里面的HTTP源码
Demo 启动HTTP服务很简单
package main import ( &amp;#34;io&amp;#34; &amp;#34;net/http&amp;#34; ) func HanldeHello(w http.ResponseWriter, r *http.Request) { io.WriteString(w, &amp;#34;ok\n&amp;#34;) } func main() { http.HandleFunc(&amp;#34;/&amp;#34;, HanldeHello, http.MethodPost) http.ListenAndServe(&amp;#34;0.0.0.0:8080&amp;#34;, nil) } Server端 ServeMux ServeMux是一个HTTP请求多路复用
type ServeMux struct { mu sync.RWMutex m map[string]muxEntry // 存储Path=&amp;gt;muxEntry 	es []muxEntry // 按照muxEntry的path从最长到最短排序slice 	hosts bool // whether any patterns contain hostnames } type muxEntry struct { // type Handler interface { 	// ServeHTTP(ResponseWriter, *Request)  // } 	h Handler // handler 	pattern string // 路由路径 } Sever HTTP服务端结构器</description>
			<content type="html"><![CDATA[<h2 id="深入理解http">深入理解HTTP</h2>
<p>HTTP服务是我们经常用的一个服务，这里就带大家看下Go里面的HTTP源码</p>
<h3 id="demo">Demo</h3>
<p>启动HTTP服务很简单</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">HanldeHello</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;ok\n&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">HanldeHello</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">MethodPost</span><span class="p">)</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;0.0.0.0:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="server端">Server端</h3>
<h4 id="servemux">ServeMux</h4>
<p>ServeMux是一个HTTP请求多路复用</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ServeMux</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
	<span class="nx">m</span>     <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">muxEntry</span>  <span class="c1">// 存储Path=&gt;muxEntry
</span><span class="c1"></span>	<span class="nx">es</span>    <span class="p">[]</span><span class="nx">muxEntry</span> <span class="c1">// 按照muxEntry的path从最长到最短排序slice
</span><span class="c1"></span>	<span class="nx">hosts</span> <span class="kt">bool</span>       <span class="c1">// whether any patterns contain hostnames
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">muxEntry</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// type Handler interface {
</span><span class="c1"></span>	<span class="c1">//     ServeHTTP(ResponseWriter, *Request)
</span><span class="c1"></span>    <span class="c1">// }
</span><span class="c1"></span>	<span class="nx">h</span>       <span class="nx">Handler</span>  <span class="c1">// handler  
</span><span class="c1"></span>	<span class="nx">pattern</span> <span class="kt">string</span>   <span class="c1">// 路由路径
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="sever">Sever</h4>
<p>HTTP服务端结构器</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Server</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Addr</span>    <span class="kt">string</span>  <span class="c1">// TCP address to listen on, &#34;:http&#34; if empty
</span><span class="c1"></span>	<span class="nx">Handler</span> <span class="nx">Handler</span> <span class="c1">// handler to invoke, http.DefaultServeMux if nil
</span><span class="c1"></span>
	<span class="c1">// TLSConfig optionally provides a TLS configuration for use
</span><span class="c1"></span>	<span class="c1">// by ServeTLS and ListenAndServeTLS. Note that this value is
</span><span class="c1"></span>	<span class="c1">// cloned by ServeTLS and ListenAndServeTLS, so it&#39;s not
</span><span class="c1"></span>	<span class="c1">// possible to modify the configuration with methods like
</span><span class="c1"></span>	<span class="c1">// tls.Config.SetSessionTicketKeys. To use
</span><span class="c1"></span>	<span class="c1">// SetSessionTicketKeys, use Server.Serve with a TLS Listener
</span><span class="c1"></span>	<span class="c1">// instead.
</span><span class="c1"></span>	<span class="nx">TLSConfig</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span>

	<span class="c1">// ReadTimeout is the maximum duration for reading the entire
</span><span class="c1"></span>	<span class="c1">// request, including the body.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Because ReadTimeout does not let Handlers make per-request
</span><span class="c1"></span>	<span class="c1">// decisions on each request body&#39;s acceptable deadline or
</span><span class="c1"></span>	<span class="c1">// upload rate, most users will prefer to use
</span><span class="c1"></span>	<span class="c1">// ReadHeaderTimeout. It is valid to use them both.
</span><span class="c1"></span>	<span class="nx">ReadTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// ReadHeaderTimeout is the amount of time allowed to read
</span><span class="c1"></span>	<span class="c1">// request headers. The connection&#39;s read deadline is reset
</span><span class="c1"></span>	<span class="c1">// after reading the headers and the Handler can decide what
</span><span class="c1"></span>	<span class="c1">// is considered too slow for the body.
</span><span class="c1"></span>	<span class="nx">ReadHeaderTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// WriteTimeout is the maximum duration before timing out
</span><span class="c1"></span>	<span class="c1">// writes of the response. It is reset whenever a new
</span><span class="c1"></span>	<span class="c1">// request&#39;s header is read. Like ReadTimeout, it does not
</span><span class="c1"></span>	<span class="c1">// let Handlers make decisions on a per-request basis.
</span><span class="c1"></span>	<span class="nx">WriteTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// IdleTimeout is the maximum amount of time to wait for the
</span><span class="c1"></span>	<span class="c1">// next request when keep-alives are enabled. If IdleTimeout
</span><span class="c1"></span>	<span class="c1">// is zero, the value of ReadTimeout is used. If both are
</span><span class="c1"></span>	<span class="c1">// zero, ReadHeaderTimeout is used.
</span><span class="c1"></span>	<span class="nx">IdleTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

	<span class="c1">// MaxHeaderBytes controls the maximum number of bytes the
</span><span class="c1"></span>	<span class="c1">// server will read parsing the request header&#39;s keys and
</span><span class="c1"></span>	<span class="c1">// values, including the request line. It does not limit the
</span><span class="c1"></span>	<span class="c1">// size of the request body.
</span><span class="c1"></span>	<span class="c1">// If zero, DefaultMaxHeaderBytes is used.
</span><span class="c1"></span>	<span class="nx">MaxHeaderBytes</span> <span class="kt">int</span>

	<span class="c1">// TLSNextProto optionally specifies a function to take over
</span><span class="c1"></span>	<span class="c1">// ownership of the provided TLS connection when an NPN/ALPN
</span><span class="c1"></span>	<span class="c1">// protocol upgrade has occurred. The map key is the protocol
</span><span class="c1"></span>	<span class="c1">// name negotiated. The Handler argument should be used to
</span><span class="c1"></span>	<span class="c1">// handle HTTP requests and will initialize the Request&#39;s TLS
</span><span class="c1"></span>	<span class="c1">// and RemoteAddr if not already set. The connection is
</span><span class="c1"></span>	<span class="c1">// automatically closed when the function returns.
</span><span class="c1"></span>	<span class="c1">// If TLSNextProto is not nil, HTTP/2 support is not enabled
</span><span class="c1"></span>	<span class="c1">// automatically.
</span><span class="c1"></span>	<span class="nx">TLSNextProto</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Server</span><span class="p">,</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">Handler</span><span class="p">)</span>

	<span class="c1">// ConnState specifies an optional callback function that is
</span><span class="c1"></span>	<span class="c1">// called when a client connection changes state. See the
</span><span class="c1"></span>	<span class="c1">// ConnState type and associated constants for details.
</span><span class="c1"></span>	<span class="nx">ConnState</span> <span class="kd">func</span><span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">,</span> <span class="nx">ConnState</span><span class="p">)</span>

	<span class="c1">// ErrorLog specifies an optional logger for errors accepting
</span><span class="c1"></span>	<span class="c1">// connections, unexpected behavior from handlers, and
</span><span class="c1"></span>	<span class="c1">// underlying FileSystem errors.
</span><span class="c1"></span>	<span class="c1">// If nil, logging is done via the log package&#39;s standard logger.
</span><span class="c1"></span>	<span class="nx">ErrorLog</span> <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span>

	<span class="nx">disableKeepAlives</span> <span class="kt">int32</span>     <span class="c1">// accessed atomically.
</span><span class="c1"></span>	<span class="nx">inShutdown</span>        <span class="kt">int32</span>     <span class="c1">// accessed atomically (non-zero means we&#39;re in Shutdown)
</span><span class="c1"></span>	<span class="nx">nextProtoOnce</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span> <span class="c1">// guards setupHTTP2_* init
</span><span class="c1"></span>	<span class="nx">nextProtoErr</span>      <span class="kt">error</span>     <span class="c1">// result of http2.ConfigureServer if used
</span><span class="c1"></span>
	<span class="nx">mu</span>         <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">listeners</span>  <span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}</span>
	<span class="nx">activeConn</span> <span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">conn</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}</span>   <span class="c1">// 活动的连接
</span><span class="c1"></span>	<span class="nx">doneChan</span>   <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
	<span class="nx">onShutdown</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h4 id="handle">Handle</h4>
<p>我们可以使用Handle或者HandleFunc进行Handle注册，下面我们讲下Handle注册的过程</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">mux</span> <span class="o">*</span><span class="nx">ServeMux</span><span class="p">)</span> <span class="nf">Handle</span><span class="p">(</span><span class="nx">pattern</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handler</span> <span class="nx">Handler</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">mux</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">mux</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

    <span class="c1">// 检查参数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pattern</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;http: invalid pattern&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">handler</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;http: nil handler&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// 检查是否存在
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">exist</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">pattern</span><span class="p">];</span> <span class="nx">exist</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;http: multiple registrations for &#34;</span> <span class="o">+</span> <span class="nx">pattern</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">mux</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">mux</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">muxEntry</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">muxEntry</span><span class="p">{</span><span class="nx">h</span><span class="p">:</span> <span class="nx">handler</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">:</span> <span class="nx">pattern</span><span class="p">}</span>
    <span class="nx">mux</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">pattern</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
    <span class="c1">// 如果pattern的最后一位是/，将其加入mux.es
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pattern</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">pattern</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
		<span class="nx">mux</span><span class="p">.</span><span class="nx">es</span> <span class="p">=</span> <span class="nf">appendSorted</span><span class="p">(</span><span class="nx">mux</span><span class="p">.</span><span class="nx">es</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span> <span class="p">{</span>
		<span class="nx">mux</span><span class="p">.</span><span class="nx">hosts</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h5 id="appendsorted">appendSorted</h5>
<p>es是个按照pattern长度排序的Slice，然后利用二分查找寻找e相对的位置，并插入其中</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">appendSorted</span><span class="p">(</span><span class="nx">es</span> <span class="p">[]</span><span class="nx">muxEntry</span><span class="p">,</span> <span class="nx">e</span> <span class="nx">muxEntry</span><span class="p">)</span> <span class="p">[]</span><span class="nx">muxEntry</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">es</span><span class="p">)</span>
    <span class="c1">// 二分查找
</span><span class="c1"></span>	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">es</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">pattern</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">pattern</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">append</span><span class="p">(</span><span class="nx">es</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// we now know that i points at where we want to insert
</span><span class="c1"></span>	<span class="nx">es</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">es</span><span class="p">,</span> <span class="nx">muxEntry</span><span class="p">{})</span> <span class="c1">// try to grow the slice in place, any entry works.
</span><span class="c1"></span>	<span class="nb">copy</span><span class="p">(</span><span class="nx">es</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">es</span><span class="p">[</span><span class="nx">i</span><span class="p">:])</span>      <span class="c1">// Move shorter entries down
</span><span class="c1"></span>	<span class="nx">es</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">e</span>
	<span class="k">return</span> <span class="nx">es</span>
<span class="p">}</span>
</code></pre></div><p>上面就是Handle注册的过程，下面我们看下HTTP服务启动以及如何处理请求</p>
<h4 id="listenandserve">ListenAndServe</h4>
<p>ListenAndServe启动了一个HTTP服务</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">ListenAndServe</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// 判断状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">shuttingDown</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ErrServerClosed</span>
	<span class="p">}</span>
	<span class="nx">addr</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nx">Addr</span>
	<span class="k">if</span> <span class="nx">addr</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">addr</span> <span class="p">=</span> <span class="s">&#34;:http&#34;</span>
	<span class="p">}</span>
	<span class="nx">ln</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// tcpKeepAliveListener会在Accept连接后，设置KeepAlive，周期是3分钟
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">Serve</span><span class="p">(</span><span class="nx">tcpKeepAliveListener</span><span class="p">{</span><span class="nx">ln</span><span class="p">.(</span><span class="o">*</span><span class="nx">net</span><span class="p">.</span><span class="nx">TCPListener</span><span class="p">)})</span>
<span class="p">}</span>
</code></pre></div><h4 id="serve">Serve</h4>
<p>Serve 接收请求，并且为每一个请求启动一个Goroutine去处理</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">Serve</span><span class="p">(</span><span class="nx">l</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Listener</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">testHookServerServe</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">fn</span><span class="p">(</span><span class="nx">srv</span><span class="p">,</span> <span class="nx">l</span><span class="p">)</span> <span class="c1">// call hook with unwrapped listener
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nx">l</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">onceCloseListener</span><span class="p">{</span><span class="nx">Listener</span><span class="p">:</span> <span class="nx">l</span><span class="p">}</span>
	<span class="k">defer</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">setupHTTP2_Serve</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">srv</span><span class="p">.</span><span class="nf">trackListener</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ErrServerClosed</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">trackListener</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">l</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>

    <span class="c1">// accept失败后的休眠时间
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">tempDelay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>     <span class="c1">// how long to sleep on accept failure
</span><span class="c1"></span>	<span class="nx">baseCtx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span> <span class="c1">// base is always background, per Issue 16220
</span><span class="c1"></span>	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">baseCtx</span><span class="p">,</span> <span class="nx">ServerContextKey</span><span class="p">,</span> <span class="nx">srv</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">rw</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">srv</span><span class="p">.</span><span class="nf">getDoneChan</span><span class="p">():</span>
				<span class="k">return</span> <span class="nx">ErrServerClosed</span>
			<span class="k">default</span><span class="p">:</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">ne</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.(</span><span class="nx">net</span><span class="p">.</span><span class="nx">Error</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">ne</span><span class="p">.</span><span class="nf">Temporary</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// 失败后的休眠处理
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">tempDelay</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nx">tempDelay</span> <span class="p">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nx">tempDelay</span> <span class="o">*=</span> <span class="mi">2</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">max</span> <span class="o">:=</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">;</span> <span class="nx">tempDelay</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
					<span class="nx">tempDelay</span> <span class="p">=</span> <span class="nx">max</span>
				<span class="p">}</span>
				<span class="nx">srv</span><span class="p">.</span><span class="nf">logf</span><span class="p">(</span><span class="s">&#34;http: Accept error: %v; retrying in %v&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">tempDelay</span><span class="p">)</span>
				<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">tempDelay</span><span class="p">)</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">e</span>
        <span class="p">}</span>
        <span class="c1">// 重置休眠时间
</span><span class="c1"></span>        <span class="nx">tempDelay</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="c1">// 新建conn
</span><span class="c1"></span>		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">newConn</span><span class="p">(</span><span class="nx">rw</span><span class="p">)</span>
        <span class="nx">c</span><span class="p">.</span><span class="nf">setState</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="nx">StateNew</span><span class="p">)</span> <span class="c1">// before Serve can return
</span><span class="c1"></span>        <span class="c1">// 处理请求
</span><span class="c1"></span>		<span class="k">go</span> <span class="nx">c</span><span class="p">.</span><span class="nf">serve</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="newconn">newConn</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">newConn</span><span class="p">(</span><span class="nx">rwc</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="o">*</span><span class="nx">conn</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">conn</span><span class="p">{</span>
		<span class="nx">server</span><span class="p">:</span> <span class="nx">srv</span><span class="p">,</span>
		<span class="nx">rwc</span><span class="p">:</span>    <span class="nx">rwc</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">debugServerConnections</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span> <span class="p">=</span> <span class="nf">newLoggingConn</span><span class="p">(</span><span class="s">&#34;server&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</code></pre></div><h5 id="conn">conn</h5>
<p>conn是服务端的HTTP连接</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">conn</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// server is the server on which the connection arrived.
</span><span class="c1"></span>	<span class="c1">// Immutable; never nil.
</span><span class="c1"></span>	<span class="nx">server</span> <span class="o">*</span><span class="nx">Server</span>

	<span class="c1">// cancelCtx cancels the connection-level context.
</span><span class="c1"></span>	<span class="nx">cancelCtx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">CancelFunc</span>

	<span class="c1">// rwc is the underlying network connection.
</span><span class="c1"></span>	<span class="c1">// This is never wrapped by other types and is the value given out
</span><span class="c1"></span>	<span class="c1">// to CloseNotifier callers. It is usually of type *net.TCPConn or
</span><span class="c1"></span>	<span class="c1">// *tls.Conn.
</span><span class="c1"></span>	<span class="nx">rwc</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span>

	<span class="c1">// remoteAddr is rwc.RemoteAddr().String(). It is not populated synchronously
</span><span class="c1"></span>	<span class="c1">// inside the Listener&#39;s Accept goroutine, as some implementations block.
</span><span class="c1"></span>	<span class="c1">// It is populated immediately inside the (*conn).serve goroutine.
</span><span class="c1"></span>	<span class="c1">// This is the value of a Handler&#39;s (*Request).RemoteAddr.
</span><span class="c1"></span>	<span class="nx">remoteAddr</span> <span class="kt">string</span>

	<span class="c1">// tlsState is the TLS connection state when using TLS.
</span><span class="c1"></span>	<span class="c1">// nil means not TLS.
</span><span class="c1"></span>	<span class="nx">tlsState</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">ConnectionState</span>

	<span class="c1">// werr is set to the first write error to rwc.
</span><span class="c1"></span>	<span class="c1">// It is set via checkConnErrorWriter{w}, where bufw writes.
</span><span class="c1"></span>	<span class="nx">werr</span> <span class="kt">error</span>

	<span class="c1">// r is bufr&#39;s read source. It&#39;s a wrapper around rwc that provides
</span><span class="c1"></span>	<span class="c1">// io.LimitedReader-style limiting (while reading request headers)
</span><span class="c1"></span>	<span class="c1">// and functionality to support CloseNotifier. See *connReader docs.
</span><span class="c1"></span>	<span class="nx">r</span> <span class="o">*</span><span class="nx">connReader</span>

	<span class="c1">// bufr reads from r.
</span><span class="c1"></span>	<span class="nx">bufr</span> <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span>

	<span class="c1">// bufw writes to checkConnErrorWriter{c}, which populates werr on error.
</span><span class="c1"></span>	<span class="nx">bufw</span> <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Writer</span>

	<span class="c1">// lastMethod is the method of the most recent request
</span><span class="c1"></span>	<span class="c1">// on this connection, if any.
</span><span class="c1"></span>	<span class="nx">lastMethod</span> <span class="kt">string</span>

	<span class="nx">curReq</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span> <span class="c1">// of *response (which has a Request in it)
</span><span class="c1"></span>
	<span class="nx">curState</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">atomic</span> <span class="kt">uint64</span> <span class="p">}</span> <span class="c1">// packed (unixtime&lt;&lt;8|uint8(ConnState))
</span><span class="c1"></span>
	<span class="c1">// mu guards hijackedv
</span><span class="c1"></span>	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>

	<span class="c1">// hijackedv is whether this connection has been hijacked
</span><span class="c1"></span>	<span class="c1">// by a Handler with the Hijacker interface.
</span><span class="c1"></span>	<span class="c1">// It is guarded by mu.
</span><span class="c1"></span>	<span class="nx">hijackedv</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div><h4 id="serve-1">serve</h4>
<p>处理这个连接</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">serve</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 省略...
</span><span class="c1"></span>
	<span class="c1">// HTTP/1.x from here on.
</span><span class="c1"></span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancelCtx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span> <span class="p">=</span> <span class="nx">cancelCtx</span>
	<span class="k">defer</span> <span class="nf">cancelCtx</span><span class="p">()</span>

	<span class="nx">c</span><span class="p">.</span><span class="nx">r</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">connReader</span><span class="p">{</span><span class="nx">conn</span><span class="p">:</span> <span class="nx">c</span><span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">bufr</span> <span class="p">=</span> <span class="nf">newBufioReader</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">r</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">bufw</span> <span class="p">=</span> <span class="nf">newBufioWriterSize</span><span class="p">(</span><span class="nx">checkConnErrorWriter</span><span class="p">{</span><span class="nx">c</span><span class="p">},</span> <span class="mi">4</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">)</span>

	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 从连接里读取请求
</span><span class="c1"></span>		<span class="nx">w</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">readRequest</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">remain</span> <span class="o">!=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">initialReadLimitSize</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// If we read any bytes off the wire, we&#39;re active.
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nf">setState</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="nx">StateActive</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="kd">const</span> <span class="nx">errorHeaders</span> <span class="p">=</span> <span class="s">&#34;\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n&#34;</span>

			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">errTooLarge</span> <span class="p">{</span>
				<span class="c1">// Their HTTP client may or may not be
</span><span class="c1"></span>				<span class="c1">// able to read this if we&#39;re
</span><span class="c1"></span>				<span class="c1">// responding to them and hanging up
</span><span class="c1"></span>				<span class="c1">// while they&#39;re still writing their
</span><span class="c1"></span>				<span class="c1">// request. Undefined behavior.
</span><span class="c1"></span>				<span class="kd">const</span> <span class="nx">publicErr</span> <span class="p">=</span> <span class="s">&#34;431 Request Header Fields Too Large&#34;</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="s">&#34;HTTP/1.1 &#34;</span><span class="o">+</span><span class="nx">publicErr</span><span class="o">+</span><span class="nx">errorHeaders</span><span class="o">+</span><span class="nx">publicErr</span><span class="p">)</span>
				<span class="nx">c</span><span class="p">.</span><span class="nf">closeWriteAndWait</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nf">isCommonNetReadError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="c1">// don&#39;t reply
</span><span class="c1"></span>			<span class="p">}</span>

			<span class="nx">publicErr</span> <span class="o">:=</span> <span class="s">&#34;400 Bad Request&#34;</span>
			<span class="k">if</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">badRequestError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">publicErr</span> <span class="p">=</span> <span class="nx">publicErr</span> <span class="o">+</span> <span class="s">&#34;: &#34;</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
			<span class="p">}</span>

			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="s">&#34;HTTP/1.1 &#34;</span><span class="o">+</span><span class="nx">publicErr</span><span class="o">+</span><span class="nx">errorHeaders</span><span class="o">+</span><span class="nx">publicErr</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// Expect 100 Continue support
</span><span class="c1"></span>		<span class="nx">req</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">req</span>
		<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nf">expectsContinue</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nf">ProtoAtLeast</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// Wrap the Body reader with one that replies on the connection
</span><span class="c1"></span>				<span class="nx">req</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">expectContinueReader</span><span class="p">{</span><span class="nx">readCloser</span><span class="p">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">resp</span><span class="p">:</span> <span class="nx">w</span><span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s">&#34;Expect&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">w</span><span class="p">.</span><span class="nf">sendExpectationFailed</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="nx">c</span><span class="p">.</span><span class="nx">curReq</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>

		<span class="k">if</span> <span class="nf">requestBodyRemains</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">registerOnHitEOF</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">startBackgroundRead</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">w</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">startBackgroundRead</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="c1">// HTTP cannot have multiple simultaneous active requests.[*]
</span><span class="c1"></span>		<span class="c1">// Until the server replies to this request, it can&#39;t read another,
</span><span class="c1"></span>		<span class="c1">// so we might as well run the handler in this goroutine.
</span><span class="c1"></span>		<span class="c1">// [*] Not strictly true: HTTP pipelining. We could let them all process
</span><span class="c1"></span>		<span class="c1">// in parallel even if their responses need to be serialized.
</span><span class="c1"></span>		<span class="c1">// But we&#39;re not going to implement HTTP pipelining because it
</span><span class="c1"></span>        <span class="c1">// was never deployed in the wild and the answer is HTTP/2.
</span><span class="c1"></span>        <span class="c1">// 由于HTTP/1.x 一个连接只能处理一个请求，也就是说serverHandler只有在执行完回复，这个连接才能被复用
</span><span class="c1"></span>        <span class="c1">// serverHandler是否能用Goroutine来运行，这个也不完全可行，这里并不打算实现HTTP pipelining，所以如果有需求可以选择HTTP/2
</span><span class="c1"></span>
        <span class="c1">// 调用ServeHTTP去执行Handler
</span><span class="c1"></span>		<span class="nx">serverHandler</span><span class="p">{</span><span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">}.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">req</span><span class="p">)</span>
		<span class="nx">w</span><span class="p">.</span><span class="nf">cancelCtx</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">hijacked</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
        <span class="nx">w</span><span class="p">.</span><span class="nf">finishRequest</span><span class="p">()</span>
        <span class="c1">// 判断连接是重用
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">w</span><span class="p">.</span><span class="nf">shouldReuseConnection</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">requestBodyLimitHit</span> <span class="o">||</span> <span class="nx">w</span><span class="p">.</span><span class="nf">closedRequestBodyEarly</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nf">closeWriteAndWait</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">setState</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">,</span> <span class="nx">StateIdle</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">curReq</span><span class="p">.</span><span class="nf">Store</span><span class="p">((</span><span class="o">*</span><span class="nx">response</span><span class="p">)(</span><span class="kc">nil</span><span class="p">))</span>

		<span class="k">if</span> <span class="p">!</span><span class="nx">w</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">doKeepAlives</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// We&#39;re in shutdown mode. We might&#39;ve replied
</span><span class="c1"></span>			<span class="c1">// to the user without &#34;Connection: close&#34; and
</span><span class="c1"></span>			<span class="c1">// they might think they can send another
</span><span class="c1"></span>			<span class="c1">// request, but such is life with HTTP/1.1.
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">idleTimeout</span><span class="p">();</span> <span class="nx">d</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">bufr</span><span class="p">.</span><span class="nf">Peek</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">{})</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="readrequest">readRequest</h4>
<p>从连接中读取下一个请求</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">readRequest</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">response</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">hijacked</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrHijacked</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">wholeReqDeadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="c1">// or zero if none
</span><span class="c1"></span>		<span class="nx">hdrDeadline</span>      <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="c1">// or zero if none
</span><span class="c1"></span>    <span class="p">)</span>
    <span class="c1">// 设置读取超时时间
</span><span class="c1"></span>	<span class="nx">t0</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">readHeaderTimeout</span><span class="p">();</span> <span class="nx">d</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">hdrDeadline</span> <span class="p">=</span> <span class="nx">t0</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nx">ReadTimeout</span><span class="p">;</span> <span class="nx">d</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">wholeReqDeadline</span> <span class="p">=</span> <span class="nx">t0</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">hdrDeadline</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nx">WriteTimeout</span><span class="p">;</span> <span class="nx">d</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">SetWriteDeadline</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
		<span class="p">}()</span>
	<span class="p">}</span>

	<span class="nx">c</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">setReadLimit</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">.</span><span class="nf">initialReadLimitSize</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">lastMethod</span> <span class="o">==</span> <span class="s">&#34;POST&#34;</span> <span class="p">{</span>
		<span class="c1">// RFC 7230 section 3 tolerance for old buggy clients.
</span><span class="c1"></span>		<span class="nx">peek</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">bufr</span><span class="p">.</span><span class="nf">Peek</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// ReadRequest will get err below
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">bufr</span><span class="p">.</span><span class="nf">Discard</span><span class="p">(</span><span class="nf">numLeadingCRorLF</span><span class="p">(</span><span class="nx">peek</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">readRequest</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">bufr</span><span class="p">,</span> <span class="nx">keepHostHeader</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">hitReadLimit</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errTooLarge</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nf">http1ServerSupportsRequest</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">badRequestError</span><span class="p">(</span><span class="s">&#34;unsupported protocol version&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">c</span><span class="p">.</span><span class="nx">lastMethod</span> <span class="p">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Method</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">setInfiniteReadLimit</span><span class="p">()</span>

	<span class="nx">hosts</span><span class="p">,</span> <span class="nx">haveHost</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">[</span><span class="s">&#34;Host&#34;</span><span class="p">]</span>
	<span class="nx">isH2Upgrade</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">isH2Upgrade</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nf">ProtoAtLeast</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(!</span><span class="nx">haveHost</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">hosts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">isH2Upgrade</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Method</span> <span class="o">!=</span> <span class="s">&#34;CONNECT&#34;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">badRequestError</span><span class="p">(</span><span class="s">&#34;missing required Host header&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">hosts</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">badRequestError</span><span class="p">(</span><span class="s">&#34;too many Host headers&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">hosts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">httpguts</span><span class="p">.</span><span class="nf">ValidHostHeader</span><span class="p">(</span><span class="nx">hosts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">badRequestError</span><span class="p">(</span><span class="s">&#34;malformed Host header&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">vv</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">httpguts</span><span class="p">.</span><span class="nf">ValidHeaderFieldName</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">badRequestError</span><span class="p">(</span><span class="s">&#34;invalid header name&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vv</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">httpguts</span><span class="p">.</span><span class="nf">ValidHeaderFieldValue</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">badRequestError</span><span class="p">(</span><span class="s">&#34;invalid header value&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">,</span> <span class="s">&#34;Host&#34;</span><span class="p">)</span>

	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancelCtx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="nx">req</span><span class="p">.</span><span class="nx">ctx</span> <span class="p">=</span> <span class="nx">ctx</span>
	<span class="nx">req</span><span class="p">.</span><span class="nx">RemoteAddr</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">remoteAddr</span>
	<span class="nx">req</span><span class="p">.</span><span class="nx">TLS</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tlsState</span>
	<span class="k">if</span> <span class="nx">body</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">.(</span><span class="o">*</span><span class="nx">body</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">body</span><span class="p">.</span><span class="nx">doEarlyClose</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// Adjust the read deadline if necessary.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">hdrDeadline</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">wholeReqDeadline</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">rwc</span><span class="p">.</span><span class="nf">SetReadDeadline</span><span class="p">(</span><span class="nx">wholeReqDeadline</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">w</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">response</span><span class="p">{</span>
		<span class="nx">conn</span><span class="p">:</span>          <span class="nx">c</span><span class="p">,</span>
		<span class="nx">cancelCtx</span><span class="p">:</span>     <span class="nx">cancelCtx</span><span class="p">,</span>
		<span class="nx">req</span><span class="p">:</span>           <span class="nx">req</span><span class="p">,</span>
		<span class="nx">reqBody</span><span class="p">:</span>       <span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span>
		<span class="nx">handlerHeader</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="nx">Header</span><span class="p">),</span>
		<span class="nx">contentLength</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="nx">closeNotifyCh</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>

		<span class="c1">// We populate these ahead of time so we&#39;re not
</span><span class="c1"></span>		<span class="c1">// reading from req.Header after their Handler starts
</span><span class="c1"></span>		<span class="c1">// and maybe mutates it (Issue 14940)
</span><span class="c1"></span>		<span class="nx">wants10KeepAlive</span><span class="p">:</span> <span class="nx">req</span><span class="p">.</span><span class="nf">wantsHttp10KeepAlive</span><span class="p">(),</span>
		<span class="nx">wantsClose</span><span class="p">:</span>       <span class="nx">req</span><span class="p">.</span><span class="nf">wantsClose</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">isH2Upgrade</span> <span class="p">{</span>
		<span class="nx">w</span><span class="p">.</span><span class="nx">closeAfterReply</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="nx">w</span><span class="p">.</span><span class="nx">cw</span><span class="p">.</span><span class="nx">res</span> <span class="p">=</span> <span class="nx">w</span>
	<span class="nx">w</span><span class="p">.</span><span class="nx">w</span> <span class="p">=</span> <span class="nf">newBufioWriterSize</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">w</span><span class="p">.</span><span class="nx">cw</span><span class="p">,</span> <span class="nx">bufferBeforeChunkingSize</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">w</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><h4 id="readrequest-1">readRequest</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">readRequest</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">deleteHostHeader</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tp</span> <span class="o">:=</span> <span class="nf">newTextprotoReader</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nx">req</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Request</span><span class="p">)</span>

	<span class="c1">// First line: GET /index.html HTTP/1.0
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">tp</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">putTextprotoReader</span><span class="p">(</span><span class="nx">tp</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ErrUnexpectedEOF</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
	<span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">RequestURI</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Proto</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nf">parseRequestLine</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">badStringError</span><span class="p">{</span><span class="s">&#34;malformed HTTP request&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">validMethod</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">badStringError</span><span class="p">{</span><span class="s">&#34;invalid method&#34;</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">rawurl</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">RequestURI</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ProtoMajor</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ProtoMinor</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nf">ParseHTTPVersion</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Proto</span><span class="p">);</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">badStringError</span><span class="p">{</span><span class="s">&#34;malformed HTTP version&#34;</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Proto</span><span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// CONNECT requests are used two different ways, and neither uses a full URL:
</span><span class="c1"></span>	<span class="c1">// The standard use is to tunnel HTTPS through an HTTP proxy.
</span><span class="c1"></span>	<span class="c1">// It looks like &#34;CONNECT www.google.com:443 HTTP/1.1&#34;, and the parameter is
</span><span class="c1"></span>	<span class="c1">// just the authority section of a URL. This information should go in req.URL.Host.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The net/rpc package also uses CONNECT, but there the parameter is a path
</span><span class="c1"></span>	<span class="c1">// that starts with a slash. It can be parsed with the regular URL parser,
</span><span class="c1"></span>	<span class="c1">// and the path will end up in req.URL.Path, where it needs to be in order for
</span><span class="c1"></span>	<span class="c1">// RPC to work.
</span><span class="c1"></span>	<span class="nx">justAuthority</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="s">&#34;CONNECT&#34;</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">rawurl</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">justAuthority</span> <span class="p">{</span>
		<span class="nx">rawurl</span> <span class="p">=</span> <span class="s">&#34;http://&#34;</span> <span class="o">+</span> <span class="nx">rawurl</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">ParseRequestURI</span><span class="p">(</span><span class="nx">rawurl</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">justAuthority</span> <span class="p">{</span>
		<span class="c1">// Strip the bogus &#34;http://&#34; back off.
</span><span class="c1"></span>		<span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Scheme</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
	<span class="p">}</span>

	<span class="c1">// Subsequent lines: Key: value.
</span><span class="c1"></span>	<span class="nx">mimeHeader</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tp</span><span class="p">.</span><span class="nf">ReadMIMEHeader</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span> <span class="p">=</span> <span class="nf">Header</span><span class="p">(</span><span class="nx">mimeHeader</span><span class="p">)</span>

	<span class="c1">// RFC 7230, section 5.3: Must treat
</span><span class="c1"></span>	<span class="c1">//	GET /index.html HTTP/1.1
</span><span class="c1"></span>	<span class="c1">//	Host: www.google.com
</span><span class="c1"></span>	<span class="c1">// and
</span><span class="c1"></span>	<span class="c1">//	GET http://www.google.com/index.html HTTP/1.1
</span><span class="c1"></span>	<span class="c1">//	Host: doesntmatter
</span><span class="c1"></span>	<span class="c1">// the same. In the second case, any Host line is ignored.
</span><span class="c1"></span>	<span class="nx">req</span><span class="p">.</span><span class="nx">Host</span> <span class="p">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Host</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Host</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nx">Host</span> <span class="p">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s">&#34;Host&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">deleteHostHeader</span> <span class="p">{</span>
		<span class="nb">delete</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">,</span> <span class="s">&#34;Host&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">fixPragmaCacheControl</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">)</span>

    <span class="c1">// 根据Header和HTTP协议判断是否需要关闭
</span><span class="c1"></span>	<span class="nx">req</span><span class="p">.</span><span class="nx">Close</span> <span class="p">=</span> <span class="nf">shouldClose</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">ProtoMajor</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ProtoMinor</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>

    <span class="c1">// 读取header、body等其他信息
</span><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nf">readTransfer</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nf">isH2Upgrade</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// Because it&#39;s neither chunked, nor declared:
</span><span class="c1"></span>		<span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>

		<span class="c1">// We want to give handlers a chance to hijack the
</span><span class="c1"></span>		<span class="c1">// connection, but we need to prevent the Server from
</span><span class="c1"></span>		<span class="c1">// dealing with the connection further if it&#39;s not
</span><span class="c1"></span>		<span class="c1">// hijacked. Set Close to ensure that:
</span><span class="c1"></span>		<span class="nx">req</span><span class="p">.</span><span class="nx">Close</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">req</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="readtransfer">readTransfer</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">msg</span> <span class="nx">是</span><span class="o">*</span><span class="nx">Request或者</span><span class="o">*</span><span class="nx">Response</span><span class="p">.</span>
<span class="kd">func</span> <span class="nf">readTransfer</span><span class="p">(</span><span class="nx">msg</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">transferReader</span><span class="p">{</span><span class="nx">RequestMethod</span><span class="p">:</span> <span class="s">&#34;GET&#34;</span><span class="p">}</span>

	<span class="c1">// Unify input
</span><span class="c1"></span>	<span class="nx">isResponse</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">switch</span> <span class="nx">rr</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">Response</span><span class="p">:</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">Header</span> <span class="p">=</span> <span class="nx">rr</span><span class="p">.</span><span class="nx">Header</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="p">=</span> <span class="nx">rr</span><span class="p">.</span><span class="nx">StatusCode</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">ProtoMajor</span> <span class="p">=</span> <span class="nx">rr</span><span class="p">.</span><span class="nx">ProtoMajor</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">ProtoMinor</span> <span class="p">=</span> <span class="nx">rr</span><span class="p">.</span><span class="nx">ProtoMinor</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">Close</span> <span class="p">=</span> <span class="nf">shouldClose</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ProtoMajor</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ProtoMinor</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Header</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="nx">isResponse</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="k">if</span> <span class="nx">rr</span><span class="p">.</span><span class="nx">Request</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">RequestMethod</span> <span class="p">=</span> <span class="nx">rr</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Method</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">Request</span><span class="p">:</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">Header</span> <span class="p">=</span> <span class="nx">rr</span><span class="p">.</span><span class="nx">Header</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">RequestMethod</span> <span class="p">=</span> <span class="nx">rr</span><span class="p">.</span><span class="nx">Method</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">ProtoMajor</span> <span class="p">=</span> <span class="nx">rr</span><span class="p">.</span><span class="nx">ProtoMajor</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">ProtoMinor</span> <span class="p">=</span> <span class="nx">rr</span><span class="p">.</span><span class="nx">ProtoMinor</span>
		<span class="c1">// Transfer semantics for Requests are exactly like those for
</span><span class="c1"></span>		<span class="c1">// Responses with status code 200, responding to a GET method
</span><span class="c1"></span>		<span class="nx">t</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="p">=</span> <span class="mi">200</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">Close</span> <span class="p">=</span> <span class="nx">rr</span><span class="p">.</span><span class="nx">Close</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unexpected type&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Default to HTTP/1.1
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ProtoMajor</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ProtoMinor</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">ProtoMajor</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ProtoMinor</span> <span class="p">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="c1">// Transfer encoding, content length
</span><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">fixTransferEncoding</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">realLength</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">fixLength</span><span class="p">(</span><span class="nx">isResponse</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">RequestMethod</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Header</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">TransferEncoding</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">isResponse</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">RequestMethod</span> <span class="o">==</span> <span class="s">&#34;HEAD&#34;</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">parseContentLength</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s">&#34;Content-Length&#34;</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="nx">n</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="nx">realLength</span>
	<span class="p">}</span>

	<span class="c1">// Trailer
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nx">Trailer</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">fixTrailer</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">Header</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">TransferEncoding</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// If there is no Content-Length or chunked Transfer-Encoding on a *Response
</span><span class="c1"></span>	<span class="c1">// and the status is not 1xx, 204 or 304, then the body is unbounded.
</span><span class="c1"></span>	<span class="c1">// See RFC 7230, section 3.3.
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nx">msg</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">Response</span><span class="p">:</span>
		<span class="k">if</span> <span class="nx">realLength</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
			<span class="p">!</span><span class="nf">chunked</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">TransferEncoding</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="nf">bodyAllowedForStatus</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Unbounded body.
</span><span class="c1"></span>			<span class="nx">t</span><span class="p">.</span><span class="nx">Close</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Prepare body reader. ContentLength &lt; 0 means chunked encoding
</span><span class="c1"></span>	<span class="c1">// or close connection when finished, since multipart is not supported yet
</span><span class="c1"></span>	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nf">chunked</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">TransferEncoding</span><span class="p">):</span>
		<span class="k">if</span> <span class="nf">noResponseBodyExpected</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">RequestMethod</span><span class="p">)</span> <span class="o">||</span> <span class="p">!</span><span class="nf">bodyAllowedForStatus</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="nx">NoBody</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">body</span><span class="p">{</span><span class="nx">src</span><span class="p">:</span> <span class="nx">internal</span><span class="p">.</span><span class="nf">NewChunkedReader</span><span class="p">(</span><span class="nx">r</span><span class="p">),</span> <span class="nx">hdr</span><span class="p">:</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">r</span><span class="p">:</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">closing</span><span class="p">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Close</span><span class="p">}</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">realLength</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="nx">NoBody</span>
	<span class="k">case</span> <span class="nx">realLength</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">:</span>
		<span class="nx">t</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">body</span><span class="p">{</span><span class="nx">src</span><span class="p">:</span> <span class="nx">io</span><span class="p">.</span><span class="nf">LimitReader</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">realLength</span><span class="p">),</span> <span class="nx">closing</span><span class="p">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Close</span><span class="p">}</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// realLength &lt; 0, i.e. &#34;Content-Length&#34; not mentioned in header
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Close</span> <span class="p">{</span>
			<span class="c1">// Close semantics (i.e. HTTP/1.0)
</span><span class="c1"></span>			<span class="nx">t</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">body</span><span class="p">{</span><span class="nx">src</span><span class="p">:</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">closing</span><span class="p">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Close</span><span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// Persistent connection (i.e. HTTP/1.1)
</span><span class="c1"></span>			<span class="nx">t</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="nx">NoBody</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Unify output
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nx">rr</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">Request</span><span class="p">:</span>
		<span class="nx">rr</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Body</span>
		<span class="nx">rr</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ContentLength</span>
		<span class="nx">rr</span><span class="p">.</span><span class="nx">TransferEncoding</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">TransferEncoding</span>
		<span class="nx">rr</span><span class="p">.</span><span class="nx">Close</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Close</span>
		<span class="nx">rr</span><span class="p">.</span><span class="nx">Trailer</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Trailer</span>
	<span class="k">case</span> <span class="o">*</span><span class="nx">Response</span><span class="p">:</span>
		<span class="nx">rr</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Body</span>
		<span class="nx">rr</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ContentLength</span>
		<span class="nx">rr</span><span class="p">.</span><span class="nx">TransferEncoding</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">TransferEncoding</span>
		<span class="nx">rr</span><span class="p">.</span><span class="nx">Close</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Close</span>
		<span class="nx">rr</span><span class="p">.</span><span class="nx">Trailer</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Trailer</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="body">body</h4>
<p>Request和Reponse的Body</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">body</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">src</span>          <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span>
	<span class="nx">hdr</span>          <span class="kd">interface</span><span class="p">{}</span>   <span class="c1">// non-nil (Response or Request) value means read trailer
</span><span class="c1"></span>	<span class="nx">r</span>            <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span> <span class="c1">// underlying wire-format reader for the trailer
</span><span class="c1"></span>	<span class="nx">closing</span>      <span class="kt">bool</span>          <span class="c1">// is the connection to be closed after reading body?
</span><span class="c1"></span>	<span class="nx">doEarlyClose</span> <span class="kt">bool</span>          <span class="c1">// whether Close should stop early
</span><span class="c1"></span>
	<span class="nx">mu</span>         <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards following, and calls to Read and Close
</span><span class="c1"></span>	<span class="nx">sawEOF</span>     <span class="kt">bool</span>
	<span class="nx">closed</span>     <span class="kt">bool</span>
	<span class="nx">earlyClose</span> <span class="kt">bool</span>   <span class="c1">// Close called and we didn&#39;t read to the end of src
</span><span class="c1"></span>	<span class="nx">onHitEOF</span>   <span class="kd">func</span><span class="p">()</span> <span class="c1">// if non-nil, func to call when EOF is Read
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go-深入理解go程序运行和编译</title>
			<link>https://leonzyang.github.io/posts/gobuild/</link>
			<pubDate>Sun, 27 Jun 2021 09:25:55 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/gobuild/</guid>
			<description>深入理解go程序运行和编译 Go是一门需要编译才能运行语言。这篇文章主要讲解Go编译和运行原理。
编译 。 计算机程序编译一般分为4个部分：
 预处理： 编译：编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产响应的汇编代码文件 汇编：汇编器将汇编代码转变成机器可以执行的指令，每一个汇编语句对应一条机器指令 链接：  GCC编译过程分解 那么一个go程序是怎么编译的呢？这里我们写hello.go
package main import &amp;#34;fmt&amp;#34; func main(){ fmt.Println(&amp;#34;Hello World!&amp;#34;) } 当我们运行go build后，会生成一个hello的二进制文件，下图是生成的过程
这样一个go程序就完成编译了。
编译器 编译器一般分为前端和后端，前端主要负责生成机器无关的中间代码，后端负责代码优化和生成。Go编译器在逻辑上分为四个阶段：
 词法分析 语法分析 语义分析 中间码生成 机器代码生成  链接器 人们将每个源代码独立地编译，然后按照需要讲它们“组装”起来，这个组装模块的过程就是链接。
go run 原理 go run是用来运行源码文件的命令，go run只能接受一个main包的文件作为参数，那我们看下这个文件具体做了哪些？ ioutil.TempDir(os.Getenv(&amp;ldquo;GOTMPDIR&amp;rdquo;), &amp;ldquo;go-build&amp;rdquo;)，生成的文件/tmp/go-build043758764
执行go run 会生成4个临时文件，
/tmp/go-build992497858/b001/ ├── exe │ └── main // 可执行文件 ├── importcfg // import config ├── importcfg.link // 链接器 └── _pkg_.a // 归档文件 静态链接和动态链接 静态链接  占用磁盘和内存 部署、更新困难  动态链接 动态链接的好处：</description>
			<content type="html"><![CDATA[<h2 id="深入理解go程序运行和编译">深入理解go程序运行和编译</h2>
<p>Go是一门需要编译才能运行语言。这篇文章主要讲解Go编译和运行原理。</p>
<h3 id="编译">编译</h3>
<p>。
计算机程序编译一般分为4个部分：</p>
<ul>
<li>预处理：</li>
<li>编译：编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产响应的汇编代码文件</li>
<li>汇编：汇编器将汇编代码转变成机器可以执行的指令，每一个汇编语句对应一条机器指令</li>
<li>链接：</li>
</ul>
<p>GCC编译过程分解
<img src="/posts/images/gcc_build.png" alt="gcc"></p>
<p>那么一个go程序是怎么编译的呢？这里我们写hello.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>当我们运行<code>go build</code>后，会生成一个hello的二进制文件，下图是生成的过程</p>
<p><img src="/posts/images/building.png" alt="building"></p>
<p>这样一个go程序就完成编译了。</p>
<h4 id="编译器">编译器</h4>
<p>编译器一般分为前端和后端，前端主要负责生成机器无关的中间代码，后端负责代码优化和生成。Go编译器在逻辑上分为四个阶段：</p>
<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>中间码生成</li>
<li>机器代码生成</li>
</ul>
<p><img src="/posts/images/build.png" alt="build"></p>
<h4 id="链接器">链接器</h4>
<p>人们将每个源代码独立地编译，然后按照需要讲它们“组装”起来，这个组装模块的过程就是链接。</p>
<h3 id="go-run-原理">go run 原理</h3>
<p><code>go run</code>是用来运行源码文件的命令，<code>go run</code>只能接受一个<code>main</code>包的文件作为参数，那我们看下这个文件具体做了哪些？
ioutil.TempDir(os.Getenv(&ldquo;GOTMPDIR&rdquo;), &ldquo;go-build&rdquo;)，生成的文件/tmp/go-build043758764</p>
<p>执行go run 会生成4个临时文件，</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">/tmp/go-build992497858/b001/
├── exe
│   └── main    // 可执行文件
├── importcfg   // import config
├── importcfg.link  // 链接器
└── _pkg_.a       // 归档文件
</code></pre></div><h4 id="静态链接和动态链接">静态链接和动态链接</h4>
<h3 id="静态链接">静态链接</h3>
<ul>
<li>占用磁盘和内存</li>
<li>部署、更新困难</li>
</ul>
<h3 id="动态链接">动态链接</h3>
<p>动态链接的好处：</p>
<ul>
<li>增加程序的兼容性</li>
<li>减少物理页面的换入换出</li>
<li>增加CPU缓存的命中率</li>
</ul>
<p>动态链接的升级：只要将旧模块覆盖掉，无需将所有程序再重新链接一遍，当程序下一次运行的时候，新版本的目标文件就会自动装载到内存中并且链接起来，程序就完成了升级</p>
<h3 id="go程序启动">go程序启动</h3>
<p>go程序启动主要分为下面几个阶段：</p>
<h4 id="设置tls">设置TLS</h4>
<p>即Thread Local Storage，线程私有存储，每个CPU的寄存器内存少之又少，所以为了保证线程互不干扰，就有了TLS，设置TLS</p>
<h4 id="初始化参数runtimeargs">初始化参数runtime.args</h4>
<h4 id="osinit">osinit</h4>
<p>获取CPU的数量</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">osinit</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ncpu</span> <span class="p">=</span> <span class="nf">getproccount</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h4 id="schedinit">schedinit</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">schedinit</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// raceinit must be the first call to race detector.
</span><span class="c1"></span>	<span class="c1">// In particular, it must be done before mallocinit below calls racemapshadow.
</span><span class="c1"></span>	<span class="c1">// 获取当前g
</span><span class="c1"></span>  <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">racectx</span><span class="p">,</span> <span class="nx">raceprocctx0</span> <span class="p">=</span> <span class="nf">raceinit</span><span class="p">()</span>
	<span class="p">}</span>
  <span class="c1">// 最大线程数量
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">maxmcount</span> <span class="p">=</span> <span class="mi">10000</span>

	<span class="nf">tracebackinit</span><span class="p">()</span>
  <span class="nf">moduledataverify</span><span class="p">()</span>
  <span class="c1">// 栈初始化
</span><span class="c1"></span>	<span class="nf">stackinit</span><span class="p">()</span>
	<span class="nf">mallocinit</span><span class="p">()</span>
	<span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="nf">cpuinit</span><span class="p">()</span>       <span class="c1">// must run before alginit
</span><span class="c1"></span>	<span class="nf">alginit</span><span class="p">()</span>       <span class="c1">// maps must not be used before this call
</span><span class="c1"></span>	<span class="nf">modulesinit</span><span class="p">()</span>   <span class="c1">// provides activeModules
</span><span class="c1"></span>	<span class="nf">typelinksinit</span><span class="p">()</span> <span class="c1">// uses maps, activeModules
</span><span class="c1"></span>	<span class="nf">itabsinit</span><span class="p">()</span>     <span class="c1">// uses activeModules
</span><span class="c1"></span>
	<span class="nf">msigsave</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="nx">initSigmask</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">sigmask</span>

	<span class="nf">goargs</span><span class="p">()</span>
	<span class="nf">goenvs</span><span class="p">()</span>
	<span class="nf">parsedebugvars</span><span class="p">()</span>
	<span class="nf">gcinit</span><span class="p">()</span>

	<span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">nanotime</span><span class="p">())</span>
	<span class="nx">procs</span> <span class="o">:=</span> <span class="nx">ncpu</span>
	<span class="k">if</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">atoi32</span><span class="p">(</span><span class="nf">gogetenv</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">));</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">procs</span> <span class="p">=</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unknown runnable goroutine during bootstrap&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// For cgocheck &gt; 1, we turn on the write barrier at all times
</span><span class="c1"></span>	<span class="c1">// and check all pointer writes. We can&#39;t do this until after
</span><span class="c1"></span>	<span class="c1">// procresize because the write barrier needs a P.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">cgocheck</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">cgo</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">wbBuf</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">buildVersion</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="c1">// Condition should never trigger. This code just serves
</span><span class="c1"></span>		<span class="c1">// to ensure runtime·buildVersion is kept in the resulting binary.
</span><span class="c1"></span>		<span class="nx">buildVersion</span> <span class="p">=</span> <span class="s">&#34;unknown&#34;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="newprocmstart">newproc&amp;mstart</h4>
<p>newoproc和mstart的作用创建goroutine绑定到用户main方法，并且开始调度，具体可以看之前的文章<a href="goroutine.md">深入理解goroutine</a></p>
<h3 id="参考">参考</h3>
<ol>
<li>Golang启动流程 <a href="https://blog.iceinto.com/posts/go/start/">https://blog.iceinto.com/posts/go/start/</a></li>
<li><a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/">https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-machinecode/</a></li>
<li>初探Go的编译命令执行过程 <a href="https://halfrost.com/go_command/">https://halfrost.com/go_command/</a></li>
<li>也谈Go的可移植性https://tonybai.com/2017/06/27/an-intro-about-go-portability/</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>Go-深入理解GC</title>
			<link>https://leonzyang.github.io/posts/gc/</link>
			<pubDate>Sun, 27 Jun 2021 09:20:30 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/gc/</guid>
			<description>深入理解GC 垃圾回收其实就是内存回收，在一个对象不再被程序使用时，它所占用的空间就需要回收。
垃圾回收方法 我之前都用Python和Go，所以接触到的垃圾回收大致有这么几种：
引用计数法 引用计数是Python中使用的垃圾回收方法，通过对一个对象计数，当计数等于0，就代表没有其他对象引用，可以清除，但是这个方法有个缺陷，就是无法解决循环引用
优点：
 简单，实时  缺点：
 需要维护计数资源 循环使用  标记清除 通过标记垃圾对象，然后进行清除， Golang的三色标记法就是这一种
分代回收 根据对象的存活周期的不同而将内存分为3代：
 年轻代: 新创建的对象都会分配在年轻代，比如局部变量 中年代：年轻代不会回收的就会放到中年代 老年代：老年代的对象存活最久  Golang 各个版本GC改进    版本 发布时间 GC算法 STW时间 重大改变     1.1 2013.5 STW 秒级    1.3 2014.6 Mark和Sweep分离. Mark STW, Sweep并发 百ms级别    1.4 2014.12 runtime代码基本都由C和少量汇编改为Go和少量汇编, 包括GC部分, 以此实现了准确式GC,减少了堆大小, 同时对指针的写入引入了write barrier, 为1.5铺垫 百ms级别    1.5 2015.</description>
			<content type="html"><![CDATA[<h2 id="深入理解gc">深入理解GC</h2>
<p>垃圾回收其实就是内存回收，在一个对象不再被程序使用时，它所占用的空间就需要回收。</p>
<h3 id="垃圾回收方法">垃圾回收方法</h3>
<p>我之前都用Python和Go，所以接触到的垃圾回收大致有这么几种：</p>
<h4 id="引用计数法">引用计数法</h4>
<p>引用计数是Python中使用的垃圾回收方法，通过对一个对象计数，当计数等于0，就代表没有其他对象引用，可以清除，但是这个方法有个缺陷，就是无法解决循环引用</p>
<p>优点：</p>
<ol>
<li>简单，实时</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要维护计数资源</li>
<li>循环使用</li>
</ol>
<h4 id="标记清除">标记清除</h4>
<p>通过标记垃圾对象，然后进行清除， Golang的三色标记法就是这一种</p>
<h4 id="分代回收">分代回收</h4>
<p>根据对象的存活周期的不同而将内存分为3代：</p>
<ul>
<li>年轻代: 新创建的对象都会分配在年轻代，比如局部变量</li>
<li>中年代：年轻代不会回收的就会放到中年代</li>
<li>老年代：老年代的对象存活最久</li>
</ul>
<h3 id="golang-各个版本gc改进">Golang 各个版本GC改进</h3>
<table>
<thead>
<tr>
<th>版本</th>
<th>发布时间</th>
<th>GC算法</th>
<th>STW时间</th>
<th>重大改变</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1</td>
<td>2013.5</td>
<td>STW</td>
<td>秒级</td>
<td></td>
</tr>
<tr>
<td>1.3</td>
<td>2014.6</td>
<td>Mark和Sweep分离. Mark STW, Sweep并发</td>
<td>百ms级别</td>
<td></td>
</tr>
<tr>
<td>1.4</td>
<td>2014.12</td>
<td>runtime代码基本都由C和少量汇编改为Go和少量汇编, 包括GC部分, 以此实现了准确式GC,减少了堆大小, 同时对指针的写入引入了write barrier, 为1.5铺垫</td>
<td>百ms级别</td>
<td></td>
</tr>
<tr>
<td>1.5</td>
<td>2015.8</td>
<td>三色标记法, 并发Mark, 并发Sweep. 非分代, 非移动, 并发的收集器</td>
<td>10ms-40ms级别</td>
<td>重要更新版本,生产上GC基本不会成为问题</td>
</tr>
<tr>
<td>1.6</td>
<td>2016.2</td>
<td>1.5中一些与并发GC不协调的地方更改. 集中式的GC协调协程, 改为状态机实现</td>
<td>5-20ms</td>
<td></td>
</tr>
<tr>
<td>1.7</td>
<td>2016.8</td>
<td>GC时栈收缩改为并发, span中对象分配状态由freelist改为bitmap</td>
<td>1-3ms左右</td>
<td></td>
</tr>
<tr>
<td>1.8</td>
<td>2017.2</td>
<td>hybird write barrier, 消除了stw中的重新扫描栈</td>
<td>sub ms</td>
<td>Golang GC进入Sub ms时代，hybrid write barrier</td>
</tr>
</tbody>
</table>
<h3 id="stop-the-world">Stop The World</h3>
<p>各个版本的STW时间
<img src="/posts/images/stw.png" alt="stw"></p>
<h3 id="三色标记法">三色标记法</h3>
<p>Golang三色标记法通过标记，将对象全部归类到3个集合，分别是白色对象、灰色对象和黑色对象。标记结束后，白色对象会被回收掉。</p>
<p><img src="/posts/images/sweep.gif" alt="sweep"></p>
<ol>
<li>首先将所有节点都放到白色对象集合</li>
<li>从根节点开始遍历对象，遍历到的白色对象从白色集合放到灰色集合中</li>
<li>遍历灰色集合中的对象，把灰色对象引用的白色对象放入到灰色集合，通过把遍历过的灰色对象放到黑色集合中</li>
<li>循环步骤3，直到灰色集合中没有对象</li>
<li>完成扫描后，白色对象就是不可达的对象，进行回收</li>
</ol>
<h3 id="stop-the-world-1">Stop The World</h3>
<p>在扫描之前执行STW操作，就是Runtime把所有的线程全部冻结掉，所有的线程全部冻结掉意味着⽤户逻辑肯定都是暂停的，所有的⽤户对象都不会被修改了，这时候去扫描肯定是安全的</p>
<p>在执行STW过程中，用户的逻辑是暂停的，那么我们就需要保证这个时间尽量短，才能不影响我们的功能，那Golang是如何处理的：</p>
<ul>
<li>新生的对象，一律标记为灰色对象</li>
<li>如果灰色或者黑色对象引用了白色对象，就会触发写屏障，GC就会将白色对象标记为灰色对象</li>
</ul>
<h3 id="写屏障">写屏障</h3>
<p>在标记的阶段，对象是可以进行修改的，如果在标记的过程中，对象引用发生了变更，就可能会导致回收错误，所以需要加入写屏障。 写屏障会将写操作和之后写操作对比。</p>
<h3 id="流程图">流程图</h3>
<p><img src="/posts/images/gc_detail.png" alt="gc_detail"></p>
<h3 id="gc触发条件">GC触发条件</h3>
<p>gcTriggerAlways: 强制触发GC
gcTriggerHeap: 当堆内存大小到达一定值则触发GC
gcTriggerTime: 当具体上次GC时间超过2min，则触发GC
gcTriggerCycle: 启动新一轮GC，如果已启动则跳过，手动触发GC(runtime.GC)会使用这个条件</p>
<p>触发条件在gcTrigger.test方法，其中gcTriggerHeap会动态判断：
当heap_live大于gc_trigger，则触发gc</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="nf">test</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span> <span class="o">&gt;=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_trigger</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>gc_trigger是触发gc的值，在gcSetTriggerRatio中计算，初始值是7 / 8.0</p>
<p>gcpercent和Golang里的一个环境变量有关，GOGC，默认是100，意思是live heap size 自上次垃圾回收后，增长1倍GC触发运行，gcpercent 默认也是100
gcController.endCycle()</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="c1">// 触发比例
</span><span class="c1"></span>	<span class="kd">const</span> <span class="nx">triggerGain</span> <span class="p">=</span> <span class="mf">0.5</span>

	<span class="c1">// 目标heap增长率，默认是1.0
</span><span class="c1"></span>	<span class="nx">goalGrowthRatio</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gcpercent</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span>
	<span class="c1">// 实际heap增长率， 总大小 / (上一次GC标记的bytes) - 1
</span><span class="c1"></span>	<span class="nx">actualGrowthRatio</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span><span class="o">/</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="c1">// GC标记阶段时间
</span><span class="c1"></span>	<span class="nx">assistDuration</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">c</span><span class="p">.</span><span class="nx">markStartTime</span>

	<span class="c1">// GC标记阶段CPU使用率，0.25
</span><span class="c1"></span>	<span class="nx">utilization</span> <span class="o">:=</span> <span class="nx">gcBackgroundUtilization</span>
	<span class="c1">// Add assist utilization; avoid divide by zero.
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">assistDuration</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// assistTime 是G辅助GC标记对象所使用的时间总和
</span><span class="c1"></span>		<span class="c1">// utilization += 辅助gc标记总时间/ GC标记时间*CPU个数
</span><span class="c1"></span>		<span class="nx">utilization</span> <span class="o">+=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">assistTime</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">assistDuration</span><span class="o">*</span><span class="nb">int64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// 
</span><span class="c1"></span>	<span class="nx">triggerError</span> <span class="o">:=</span> <span class="nx">goalGrowthRatio</span> <span class="o">-</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span> <span class="o">-</span> <span class="nx">utilization</span><span class="o">/</span><span class="nx">gcGoalUtilization</span><span class="o">*</span><span class="p">(</span><span class="nx">actualGrowthRatio</span><span class="o">-</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span><span class="p">)</span>

	<span class="c1">// 渐进式调整，每次只调整一半的值
</span><span class="c1"></span>	<span class="nx">triggerRatio</span> <span class="o">:=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span> <span class="o">+</span> <span class="nx">triggerGain</span><span class="o">*</span><span class="nx">triggerError</span>
<span class="p">}</span>
</code></pre></div><h3 id="辅助gcmutator-assist">辅助GC(mutator assist)</h3>
<h3 id="gc过程">GC过程</h3>
<p>为了防止heap增速太快，在GC执行过程中如果同时运行G分配了内存，则这个G会被要求辅助GC做一部分工作</p>
<p>assistWorkPerByte计算公式在revise
assistBytesPerWork</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">revise</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">gcpercent</span> <span class="o">:=</span> <span class="nx">gcpercent</span>
	<span class="k">if</span> <span class="nx">gcpercent</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// If GC is disabled but we&#39;re running a forced GC,
</span><span class="c1"></span>		<span class="c1">// act like GOGC is huge for the below calculations.
</span><span class="c1"></span>		<span class="nx">gcpercent</span> <span class="p">=</span> <span class="mi">100000</span>
	<span class="p">}</span>
	<span class="nx">live</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">heapGoal</span><span class="p">,</span> <span class="nx">scanWorkExpected</span> <span class="kt">int64</span>
	<span class="c1">// 当前活动的heap大于下一次gc的heap_live
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">live</span> <span class="o">&lt;=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">{</span>
		<span class="c1">// 我们在软目标下
</span><span class="c1"></span>		<span class="nx">heapGoal</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="p">)</span>

		<span class="c1">// 计算预期剩余扫描工作，如果GOGC=100，只有扫描heap一半的被认为是live
</span><span class="c1"></span>		<span class="nx">scanWorkExpected</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="mi">100</span><span class="o">+</span><span class="nx">gcpercent</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 我们达到了硬限制，
</span><span class="c1"></span>		<span class="kd">const</span> <span class="nx">maxOvershoot</span> <span class="p">=</span> <span class="mf">1.1</span>
		<span class="nx">heapGoal</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="p">)</span> <span class="o">*</span> <span class="nx">maxOvershoot</span><span class="p">)</span>

		<span class="c1">// 计算扫描工作的上线
</span><span class="c1"></span>		<span class="nx">scanWorkExpected</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 计算剩余扫描工作
</span><span class="c1"></span>	<span class="nx">scanWorkRemaining</span> <span class="o">:=</span> <span class="nx">scanWorkExpected</span> <span class="o">-</span> <span class="nx">c</span><span class="p">.</span><span class="nx">scanWork</span>
	<span class="k">if</span> <span class="nx">scanWorkRemaining</span> <span class="p">&lt;</span> <span class="mi">1000</span> <span class="p">{</span>
		<span class="c1">// We set a somewhat arbitrary lower bound on
</span><span class="c1"></span>		<span class="c1">// remaining scan work since if we aim a little high,
</span><span class="c1"></span>		<span class="c1">// we can miss by a little.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// We *do* need to enforce that this is at least 1,
</span><span class="c1"></span>		<span class="c1">// since marking is racy and double-scanning objects
</span><span class="c1"></span>		<span class="c1">// may legitimately make the remaining scan work
</span><span class="c1"></span>		<span class="c1">// negative, even in the hard goal regime.
</span><span class="c1"></span>		<span class="nx">scanWorkRemaining</span> <span class="p">=</span> <span class="mi">1000</span>
	<span class="p">}</span>

	<span class="c1">// 计算剩余堆
</span><span class="c1"></span>	<span class="nx">heapRemaining</span> <span class="o">:=</span> <span class="nx">heapGoal</span> <span class="o">-</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">live</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">heapRemaining</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// This shouldn&#39;t happen, but if it does, avoid
</span><span class="c1"></span>		<span class="c1">// dividing by zero or setting the assist negative.
</span><span class="c1"></span>		<span class="nx">heapRemaining</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="c1">// 计算辅助助手
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">assistWorkPerByte</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">scanWorkRemaining</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">heapRemaining</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">assistBytesPerWork</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">heapRemaining</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">scanWorkRemaining</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h4 id="gcstart">gcStart</h4>
<p>gc触发函数</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcStart</span><span class="p">(</span><span class="nx">trigger</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 判断当前g是否可抢占， 不抢占不触发
</span><span class="c1"></span>	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="o">||</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">locks</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nx">mp</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// 触发gc并且开始并行扫描
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">trigger</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="c1">// 加锁
</span><span class="c1"></span>	<span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
	<span class="c1">// 检测是否触发gc
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">trigger</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 检查是否强制触发gc
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">userForced</span> <span class="p">=</span> <span class="nx">trigger</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">gcTriggerAlways</span> <span class="o">||</span> <span class="nx">trigger</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">gcTriggerCycle</span>

	<span class="c1">// 判断是否禁止了并行gc
</span><span class="c1"></span>	<span class="nx">mode</span> <span class="o">:=</span> <span class="nx">gcBackgroundMode</span>
	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcstoptheworld</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">mode</span> <span class="p">=</span> <span class="nx">gcForceMode</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcstoptheworld</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="nx">mode</span> <span class="p">=</span> <span class="nx">gcForceBlockMode</span>
	<span class="p">}</span>

	<span class="c1">// Ok, we&#39;re doing it! Stop everybody else
</span><span class="c1"></span>	<span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCStart</span><span class="p">()</span>
	<span class="p">}</span>

    <span class="c1">// 如果.mcache.flushGen不等于mheap_.sweepgen，说明有旧的数据
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">fg</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nx">flushGen</span><span class="p">);</span> <span class="nx">fg</span> <span class="o">!=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: p&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="s">&#34;flushGen&#34;</span><span class="p">,</span> <span class="nx">fg</span><span class="p">,</span> <span class="s">&#34;!= sweepgen&#34;</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;p mcache not flushed&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 启动后台扫描任务
</span><span class="c1"></span>	<span class="nf">gcBgMarkStartWorkers</span><span class="p">()</span>

	<span class="c1">// 重置标记状态
</span><span class="c1"></span>	<span class="nf">gcResetMarkState</span><span class="p">()</span>
	<span class="c1">// 重置参数
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">maxprocs</span> <span class="p">=</span> <span class="nx">gomaxprocs</span><span class="p">,</span> <span class="nx">gomaxprocs</span>
	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span> <span class="p">&gt;</span> <span class="nx">ncpu</span> <span class="p">{</span>
		<span class="c1">// This is used to compute CPU time of the STW phases,
</span><span class="c1"></span>		<span class="c1">// so it can&#39;t be more than ncpu, even if GOMAXPROCS is.
</span><span class="c1"></span>		<span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span> <span class="p">=</span> <span class="nx">ncpu</span>
	<span class="p">}</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">heap0</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">mode</span> <span class="p">=</span> <span class="nx">mode</span>
	<span class="c1">// 记录开始时间
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSTWStart</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// STOP THE WORLD
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">stopTheWorldWithSema</span><span class="p">)</span>

	<span class="c1">// 并发扫描前确认已经完成gc标记
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">finishsweep_m</span><span class="p">()</span>
	<span class="p">})</span>

	<span class="c1">// clear sched.sudogcache和sched.deferpool
</span><span class="c1"></span>	<span class="nf">clearpools</span><span class="p">()</span>

	<span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="o">++</span>

	<span class="c1">// 开启新一轮gc前重置gcController
</span><span class="c1"></span>	<span class="nx">gcController</span><span class="p">.</span><span class="nf">startCycle</span><span class="p">()</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">heapGoal</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span>

	<span class="c1">// In STW mode, disable scheduling of user Gs. This may also
</span><span class="c1"></span>	<span class="c1">// disable scheduling of this goroutine, so it may block as
</span><span class="c1"></span>	<span class="c1">// soon as we start the world again.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mode</span> <span class="o">!=</span> <span class="nx">gcBackgroundMode</span> <span class="p">{</span>
		<span class="nf">schedEnableUser</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 进入并发标记阶段，开启写屏障
</span><span class="c1"></span>	<span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCmark</span><span class="p">)</span>

	<span class="c1">// 重置后台标记任务的计数器(nproc, nwait)
</span><span class="c1"></span>	<span class="nf">gcBgMarkPrepare</span><span class="p">()</span>

	<span class="c1">// 计算扫描根对象的任务数量
</span><span class="c1"></span>	<span class="nf">gcMarkRootPrepare</span><span class="p">()</span>

	<span class="c1">// 标记所有活动的tiny 
</span><span class="c1"></span>	<span class="nf">gcMarkTinyAllocs</span><span class="p">()</span>

	<span class="c1">// 启动辅助gc
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

	<span class="c1">// 标记开始的时间
</span><span class="c1"></span>	<span class="nx">gcController</span><span class="p">.</span><span class="nx">markStartTime</span> <span class="p">=</span> <span class="nx">now</span>

	<span class="c1">// 并发标记
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// START THE WORLD
</span><span class="c1"></span>		<span class="c1">// 标记已经在进行
</span><span class="c1"></span>		<span class="nx">now</span> <span class="p">=</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span><span class="p">)</span>
		<span class="c1">// 记录停止了多久
</span><span class="c1"></span>		<span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="o">+=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span>
		<span class="nx">work</span><span class="p">.</span><span class="nx">tMark</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="p">})</span>

	<span class="c1">// STW模式下，block
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mode</span> <span class="o">!=</span> <span class="nx">gcBackgroundMode</span> <span class="p">{</span>
		<span class="nf">Gosched</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="gcbgmarkstartworkers">gcBgMarkStartWorkers</h4>
<p>后台标记任务</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcBgMarkStartWorkers</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Background marking is performed by per-P G&#39;s. Ensure that
</span><span class="c1"></span>	<span class="c1">// each P has a background GC G.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="c1">// 是否未启动
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">go</span> <span class="nf">gcBgMarkWorker</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
			<span class="c1">// 启动后等待该任务通知信号量bgMarkReady再继续
</span><span class="c1"></span>			<span class="nf">notetsleepg</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="gcbgmarkworker">gcBgMarkWorker</h4>
<p>后台标记任务</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcBgMarkWorker</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="kd">type</span> <span class="nx">parkInfo</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">m</span>      <span class="nx">muintptr</span> <span class="c1">// Release this m on park.
</span><span class="c1"></span>		<span class="nx">attach</span> <span class="nx">puintptr</span> <span class="c1">// If non-nil, attach to this p on park.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="c1">// We pass park to a gopark unlock function, so it can&#39;t be on
</span><span class="c1"></span>	<span class="c1">// the stack (see gopark). Prevent deadlock from recursively
</span><span class="c1"></span>	<span class="c1">// starting GC by disabling preemption.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;GC worker init&#34;</span>
	<span class="nx">park</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">parkInfo</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>

	<span class="c1">// M禁止抢占
</span><span class="c1"></span>	<span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>
	<span class="c1">// 绑定P
</span><span class="c1"></span>	<span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="c1">// 通知gcBgMarkStartWorkers已准备完毕，可以继续
</span><span class="c1"></span>	<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">)</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// Go to sleep until woken by gcController.findRunnable.
</span><span class="c1"></span>		<span class="c1">// We can&#39;t releasem yet since even the call to gopark
</span><span class="c1"></span>		<span class="c1">// may be preempted.
</span><span class="c1"></span>		<span class="c1">// 休眠直到被gcController.findRunnable唤醒
</span><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">parkp</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="nx">park</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">parkInfo</span><span class="p">)(</span><span class="nx">parkp</span><span class="p">)</span>

			<span class="c1">// The worker G is no longer running, so it&#39;s
</span><span class="c1"></span>			<span class="c1">// now safe to allow preemption.
</span><span class="c1"></span>			<span class="c1">// 扫描任务不在运行，允许抢占
</span><span class="c1"></span>			<span class="nf">releasem</span><span class="p">(</span><span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>

			<span class="c1">// 如果worker没有关联P，需要关联下
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">park</span><span class="p">.</span><span class="nx">attach</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">p</span> <span class="o">:=</span> <span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
				<span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
				<span class="c1">// 把当前G设置成gcBgMarkWorker的成员
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">g</span><span class="p">)))</span> <span class="p">{</span>
					<span class="c1">// 已经有任务，设置失败，退出休眠
</span><span class="c1"></span>					<span class="k">return</span> <span class="kc">false</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">},</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">park</span><span class="p">),</span> <span class="nx">waitReasonGCWorkerIdle</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

		<span class="c1">// 如果P的gcBgMarkWorker和当前G不一致，则退出
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">gp</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="c1">// 禁止抢占
</span><span class="c1"></span>		<span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>

		<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcBgMarkWorker: blackening not enabled&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// 开始时间
</span><span class="c1"></span>		<span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerStartTime</span> <span class="p">=</span> <span class="nx">startTime</span>

		<span class="nx">decnwait</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">decnwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: work.nwait=&#34;</span><span class="p">,</span> <span class="nx">decnwait</span><span class="p">,</span> <span class="s">&#34;work.nproc=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;work.nwait was &gt; work.nproc&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 标记G可抢占以便能够扫描栈（两个标记任务可以互相扫描对方），标记任务禁止栈收缩
</span><span class="c1"></span>			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
			<span class="k">switch</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">{</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcBgMarkWorker: unexpected gcMarkWorkerMode&#34;</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">gcMarkWorkerDedicatedMode</span><span class="p">:</span>
				<span class="c1">// 只执行标记
</span><span class="c1"></span>				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span>
					<span class="c1">// 抢占成功，踢出所有的runq，然后执行gp
</span><span class="c1"></span>					<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
					<span class="k">for</span> <span class="p">{</span>
						<span class="nx">gp</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
						<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
							<span class="k">break</span>
						<span class="p">}</span>
						<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
					<span class="p">}</span>
					<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="c1">// Go back to draining, this time
</span><span class="c1"></span>				<span class="c1">// without preemption.
</span><span class="c1"></span>				<span class="c1">// 继续标记，直到没有更多任务，并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
</span><span class="c1"></span>				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">gcMarkWorkerFractionalMode</span><span class="p">:</span>
				<span class="c1">// 执行标记，直到被抢占
</span><span class="c1"></span>				<span class="c1">// 需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
</span><span class="c1"></span>				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainFractional</span><span class="p">|</span><span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">gcMarkWorkerIdleMode</span><span class="p">:</span>
				<span class="c1">// 只有在P空闲的时候执行标记，直到被抢占或者达到一定量
</span><span class="c1"></span>				<span class="c1">// 需要计算后台的扫描量来减少辅助GC和唤醒等待中的G
</span><span class="c1"></span>				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainIdle</span><span class="p">|</span><span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 恢复G的状态到运行中
</span><span class="c1"></span>			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
		<span class="p">})</span>

		<span class="c1">// 计算时间
</span><span class="c1"></span>		<span class="nx">duration</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">startTime</span>
		<span class="k">switch</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">gcMarkWorkerDedicatedMode</span><span class="p">:</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">gcMarkWorkerFractionalMode</span><span class="p">:</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">fractionalMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">gcMarkWorkerIdleMode</span><span class="p">:</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">idleMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Was this the last worker and did we run out
</span><span class="c1"></span>		<span class="c1">// of work?
</span><span class="c1"></span>		<span class="nx">incnwait</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">incnwait</span> <span class="p">&gt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: p.gcMarkWorkerMode=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span><span class="p">,</span>
				<span class="s">&#34;work.nwait=&#34;</span><span class="p">,</span> <span class="nx">incnwait</span><span class="p">,</span> <span class="s">&#34;work.nproc=&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;work.nwait &gt; work.nproc&#34;</span><span class="p">)</span>
		<span class="p">}</span>


		<span class="c1">// 判断是否所有后台标记任务都完成了，并且没有多余的任务
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">incnwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 标记G可抢占，并且取消关联
</span><span class="c1"></span>			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>

			<span class="c1">// 准备进入完成标记阶段
</span><span class="c1"></span>			<span class="nf">gcMarkDone</span><span class="p">()</span>

			<span class="c1">// 禁止抢占准备重新关联P
</span><span class="c1"></span>			<span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>
			<span class="c1">// 重新关联之前的P
</span><span class="c1"></span>			<span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="startcycle">startCycle</h4>
<p>startCycle会为新一轮的GC重置状态和估计值</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">startCycle</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">bgScanCredit</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">assistTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">fractionalMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">idleMarkTime</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// If this is the first GC cycle or we&#39;re operating on a very
</span><span class="c1"></span>	<span class="c1">// small heap, fake heap_marked so it looks like gc_trigger is
</span><span class="c1"></span>	<span class="c1">// the appropriate growth from heap_marked, even though the
</span><span class="c1"></span>	<span class="c1">// real heap_marked may not have a meaningful value (on the
</span><span class="c1"></span>	<span class="c1">// first cycle) or may be much smaller (resulting in a large
</span><span class="c1"></span>	<span class="c1">// error response).
</span><span class="c1"></span>
	<span class="c1">// 如果是第一次GC或者当前的heap非常小，我们需要伪装一个heap_marked来防止后面triggerRatio过小
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_trigger</span> <span class="o">&lt;=</span> <span class="nx">heapminimum</span> <span class="p">{</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_trigger</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// 重新计算gc的heap的目标
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span> <span class="o">+</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span><span class="o">*</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">gcpercent</span><span class="p">)</span><span class="o">/</span><span class="mi">100</span>
	<span class="k">if</span> <span class="nx">gcpercent</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 确保本次heap的目标只要应该大于活动的对大小，至少应该高1MB
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">&lt;</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="o">+</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span> <span class="p">{</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span> <span class="o">+</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span>
	<span class="p">}</span>

	<span class="c1">// Compute the background mark utilization goal. In general,
</span><span class="c1"></span>	<span class="c1">// this may not come out exactly. We round the number of
</span><span class="c1"></span>	<span class="c1">// dedicated workers so that the utilization is closest to
</span><span class="c1"></span>	<span class="c1">// 25%. For small GOMAXPROCS, this would introduce too much
</span><span class="c1"></span>	<span class="c1">// error, so we add fractional workers in that case.
</span><span class="c1"></span>	<span class="c1">// 计算后台标记任务的使用率，一般情况下是25%
</span><span class="c1"></span>	<span class="c1">// totalUtilizationGoal = cpu * 0.25
</span><span class="c1"></span>	<span class="c1">// 专用的标记任务数 dedicatedMarkWorkersNeeded = cpu * 0.25 + 0.5
</span><span class="c1"></span>	<span class="nx">totalUtilizationGoal</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span> <span class="o">*</span> <span class="nx">gcBackgroundUtilization</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">totalUtilizationGoal</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
	<span class="c1">// 
</span><span class="c1"></span>	<span class="nx">utilError</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span><span class="o">/</span><span class="nx">totalUtilizationGoal</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="kd">const</span> <span class="nx">maxUtilError</span> <span class="p">=</span> <span class="mf">0.3</span>
	<span class="k">if</span> <span class="nx">utilError</span> <span class="p">&lt;</span> <span class="o">-</span><span class="nx">maxUtilError</span> <span class="o">||</span> <span class="nx">utilError</span> <span class="p">&gt;</span> <span class="nx">maxUtilError</span> <span class="p">{</span>
		<span class="c1">// Rounding put us more than 30% off our goal. With
</span><span class="c1"></span>		<span class="c1">// gcBackgroundUtilization of 25%, this happens for
</span><span class="c1"></span>		<span class="c1">// GOMAXPROCS&lt;=3 or GOMAXPROCS=6. Enable fractional
</span><span class="c1"></span>		<span class="c1">// workers to compensate.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">totalUtilizationGoal</span> <span class="p">{</span>
			<span class="c1">// 太多任务
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">=</span> <span class="p">(</span><span class="nx">totalUtilizationGoal</span> <span class="o">-</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// In STW mode, we just want dedicated workers.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcstoptheworld</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// 重置辅助gc的时间统计和gcFractionalMarkTime
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">gcAssistTime</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// Compute initial values for controls that are updated
</span><span class="c1"></span>	<span class="c1">// throughout the cycle.
</span><span class="c1"></span>	<span class="c1">// 计算辅助gc的参数
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcpacertrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;pacer: assist ratio=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">assistWorkPerByte</span><span class="p">,</span>
			<span class="s">&#34; (scan &#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34; MB in &#34;</span><span class="p">,</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">initialHeapLive</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;-&gt;&#34;</span><span class="p">,</span>
			<span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34; MB)&#34;</span><span class="p">,</span>
			<span class="s">&#34; workers=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">,</span>
			<span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="revise">revise</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">revise</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">gcpercent</span> <span class="o">:=</span> <span class="nx">gcpercent</span>
	<span class="k">if</span> <span class="nx">gcpercent</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// If GC is disabled but we&#39;re running a forced GC,
</span><span class="c1"></span>		<span class="c1">// act like GOGC is huge for the below calculations.
</span><span class="c1"></span>		<span class="nx">gcpercent</span> <span class="p">=</span> <span class="mi">100000</span>
	<span class="p">}</span>
	<span class="nx">live</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">heapGoal</span><span class="p">,</span> <span class="nx">scanWorkExpected</span> <span class="kt">int64</span>
	<span class="c1">// 当前活动的heap大于下一次gc的heap_live
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">live</span> <span class="o">&lt;=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">{</span>
		<span class="c1">// 我们在软目标下
</span><span class="c1"></span>		<span class="nx">heapGoal</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="p">)</span>

		<span class="c1">// 计算预期剩余扫描工作，如果GOGC=100，只有扫描heap一半的被认为是live
</span><span class="c1"></span>		<span class="nx">scanWorkExpected</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="mi">100</span><span class="o">+</span><span class="nx">gcpercent</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 我们达到了硬限制，
</span><span class="c1"></span>		<span class="kd">const</span> <span class="nx">maxOvershoot</span> <span class="p">=</span> <span class="mf">1.1</span>
		<span class="nx">heapGoal</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="p">)</span> <span class="o">*</span> <span class="nx">maxOvershoot</span><span class="p">)</span>

		<span class="c1">// 计算扫描工作的上线
</span><span class="c1"></span>		<span class="nx">scanWorkExpected</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_scan</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 计算剩余扫描工作
</span><span class="c1"></span>	<span class="nx">scanWorkRemaining</span> <span class="o">:=</span> <span class="nx">scanWorkExpected</span> <span class="o">-</span> <span class="nx">c</span><span class="p">.</span><span class="nx">scanWork</span>
	<span class="k">if</span> <span class="nx">scanWorkRemaining</span> <span class="p">&lt;</span> <span class="mi">1000</span> <span class="p">{</span>
		<span class="c1">// We set a somewhat arbitrary lower bound on
</span><span class="c1"></span>		<span class="c1">// remaining scan work since if we aim a little high,
</span><span class="c1"></span>		<span class="c1">// we can miss by a little.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// We *do* need to enforce that this is at least 1,
</span><span class="c1"></span>		<span class="c1">// since marking is racy and double-scanning objects
</span><span class="c1"></span>		<span class="c1">// may legitimately make the remaining scan work
</span><span class="c1"></span>		<span class="c1">// negative, even in the hard goal regime.
</span><span class="c1"></span>		<span class="nx">scanWorkRemaining</span> <span class="p">=</span> <span class="mi">1000</span>
	<span class="p">}</span>

	<span class="c1">// 计算剩余堆
</span><span class="c1"></span>	<span class="nx">heapRemaining</span> <span class="o">:=</span> <span class="nx">heapGoal</span> <span class="o">-</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">live</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">heapRemaining</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// This shouldn&#39;t happen, but if it does, avoid
</span><span class="c1"></span>		<span class="c1">// dividing by zero or setting the assist negative.
</span><span class="c1"></span>		<span class="nx">heapRemaining</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="c1">// Compute the mutator assist ratio so by the time the mutator
</span><span class="c1"></span>	<span class="c1">// allocates the remaining heap bytes up to next_gc, it will
</span><span class="c1"></span>	<span class="c1">// have done (or stolen) the remaining amount of scan work.
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">assistWorkPerByte</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">scanWorkRemaining</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">heapRemaining</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">assistBytesPerWork</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">heapRemaining</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">scanWorkRemaining</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="gcmarkrootprepare">gcMarkRootPrepare</h4>
<p>计算扫描根对象的任务数量</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkRootPrepare</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">nFlushCacheRoots</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// 计算有多少数据和BSS， rootBlockBytes是256KB
</span><span class="c1"></span>	<span class="nx">nBlocks</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">bytes</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="nx">bytes</span> <span class="o">+</span> <span class="nx">rootBlockBytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nx">rootBlockBytes</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// Scan globals.
</span><span class="c1"></span>	<span class="c1">// 计算扫描可读写的全局变量的任务数量
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">nDataRoots</span> <span class="o">:=</span> <span class="nf">nBlocks</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">edata</span> <span class="o">-</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">nDataRoots</span> <span class="p">&gt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span> <span class="p">{</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span> <span class="p">=</span> <span class="nx">nDataRoots</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 计算扫描只读的全局变量的任务数量
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">nBSSRoots</span> <span class="o">:=</span> <span class="nf">nBlocks</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">ebss</span> <span class="o">-</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">bss</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">nBSSRoots</span> <span class="p">&gt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span> <span class="p">{</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span> <span class="p">=</span> <span class="nx">nBSSRoots</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Scan span roots for finalizer specials.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We depend on addfinalizer to mark objects that get
</span><span class="c1"></span>	<span class="c1">// finalizers after root marking.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We&#39;re only interested in scanning the in-use spans,
</span><span class="c1"></span>	<span class="c1">// which will all be swept at this point. More spans
</span><span class="c1"></span>	<span class="c1">// may be added to this list during concurrent GC, but
</span><span class="c1"></span>	<span class="c1">// we only care about spans that were allocated before
</span><span class="c1"></span>	<span class="c1">// this mark phase.
</span><span class="c1"></span>	<span class="c1">// 计算扫描span中finalizer的数量
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">nSpanRoots</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">numBlocks</span><span class="p">()</span>

	<span class="c1">// Scan stacks.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Gs may be created after this point, but it&#39;s okay that we
</span><span class="c1"></span>	<span class="c1">// ignore them because they begin life without any roots, so
</span><span class="c1"></span>	<span class="c1">// there&#39;s nothing to scan, and any roots they create during
</span><span class="c1"></span>	<span class="c1">// the concurrent phase will be scanned during mark
</span><span class="c1"></span>	<span class="c1">// termination.
</span><span class="c1"></span>	<span class="c1">// 计算扫描栈的任务数量
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">nStackRoots</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allglen</span><span class="p">))</span>

	<span class="c1">// 计算总任务数量
</span><span class="c1"></span>	<span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">fixedRootCount</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nFlushCacheRoots</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nSpanRoots</span> <span class="o">+</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nStackRoots</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="gcmarktinyallocs">gcMarkTinyAllocs</h4>
<p>gcMarkTinyAllocs会标记所有的tiny</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkTinyAllocs</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">mcache</span>
		<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcw</span>
		<span class="nf">greyobject</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nx">objIndex</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="findrunnablegcworker">findRunnableGCWorker</h4>
<p>findRunnableGCWorker会获取后台的标记任务，决定是否运行</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">findRunnableGCWorker</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcControllerState.findRunnable: blackening not enabled&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// The mark worker associated with this P is blocked
</span><span class="c1"></span>		<span class="c1">// performing a mark transition. We can&#39;t run it
</span><span class="c1"></span>		<span class="c1">// because it may be on some other run or wait queue.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// No work to be done right now. This can happen at
</span><span class="c1"></span>		<span class="c1">// the end of the mark phase when there are still
</span><span class="c1"></span>		<span class="c1">// assists tapering off. Don&#39;t bother running a worker
</span><span class="c1"></span>		<span class="c1">// now because it&#39;ll just return immediately.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// 原子减少值，如果减少后大于等于0则返回true， 否则返回true
</span><span class="c1"></span>	<span class="nx">decIfPositive</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ptr</span> <span class="o">*</span><span class="kt">int64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="o">*</span><span class="nx">ptr</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">true</span>
			<span class="p">}</span>
			<span class="c1">// We lost a race
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// 减少dedicatedMarkWorkersNeeded，成功后是dedicated
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">decIfPositive</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// This P is now dedicated to marking until the end of
</span><span class="c1"></span>		<span class="c1">// the concurrent mark phase.
</span><span class="c1"></span>		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerDedicatedMode</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// No need for fractional workers.
</span><span class="c1"></span>		<span class="c1">// 不需要
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Is this P behind on the fractional utilization
</span><span class="c1"></span>		<span class="c1">// goal?
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// This should be kept in sync with pollFractionalWorkerExit.
</span><span class="c1"></span>		<span class="nx">delta</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">markStartTime</span>
		<span class="k">if</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span><span class="p">)</span><span class="o">/</span><span class="nb">float64</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">{</span>
			<span class="c1">// Nope. No need to run a fractional worker.
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="c1">// Run a fractional worker.
</span><span class="c1"></span>		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerFractionalMode</span>
	<span class="p">}</span>

	<span class="c1">// 运行后台标记任务
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>
</code></pre></div><h3 id="starttheworldwithsema">startTheWorldWithSema</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stopTheWorldWithSema</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// If we hold a lock, then we won&#39;t be able to stop another M
</span><span class="c1"></span>	<span class="c1">// that is blocked trying to acquire the lock.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopTheWorld: holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 需要停止P的数量
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="p">=</span> <span class="nx">gomaxprocs</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 抢占所有运行中的G
</span><span class="c1"></span>	<span class="nf">preemptall</span><span class="p">()</span>
	<span class="c1">// 停止当前的P
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span> <span class="c1">// Pgcstop is only diagnostic.
</span><span class="c1"></span>	<span class="c1">// 减少停止的P-当前的P
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
	<span class="c1">// try to retake all P&#39;s in Psyscall status
</span><span class="c1"></span>	<span class="c1">// 尝试抢占所有处在Psyscall状态的P
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span>
		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">_Pgcstop</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
				<span class="nf">traceGoSysBlock</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
				<span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">syscalltick</span><span class="o">++</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// stop idle P&#39;s
</span><span class="c1"></span>	<span class="c1">// 再次停止空闲的P，防止进入调度
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nf">pidleget</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="nx">wait</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="p">&gt;</span> <span class="mi">0</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// wait for remaining P&#39;s to stop voluntarily
</span><span class="c1"></span>	<span class="c1">// 等待剩余的P停止
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">wait</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="c1">// 等待100微秒，然后尝试重新抢占
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">notetsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nf">preemptall</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 再次检查
</span><span class="c1"></span>	<span class="nx">bad</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;stopTheWorld: not stopped (stopwait != 0)&#34;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Pgcstop</span> <span class="p">{</span>
				<span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;stopTheWorld: not stopped (status != _Pgcstop)&#34;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">freezing</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Some other thread is panicking. This can cause the
</span><span class="c1"></span>		<span class="c1">// sanity checks above to fail if the panic happens in
</span><span class="c1"></span>		<span class="c1">// the signal handler on a stopped thread. Either way,
</span><span class="c1"></span>		<span class="c1">// we should halt this thread.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">deadlock</span><span class="p">)</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">deadlock</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">bad</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="nx">bad</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="starttheworldwithsema-1">startTheWorldWithSema</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="nx">emitTraceEvent</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// 禁止g抢占
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 获取netpoll事件，并将其加入到待运行队列
</span><span class="c1"></span>		<span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// non-blocking
</span><span class="c1"></span>		<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 获取当前gomaxprocs
</span><span class="c1"></span>	<span class="nx">procs</span> <span class="o">:=</span> <span class="nx">gomaxprocs</span>
	<span class="k">if</span> <span class="nx">newprocs</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">procs</span> <span class="p">=</span> <span class="nx">newprocs</span>
		<span class="nx">newprocs</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">p1</span> <span class="o">:=</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span>
	<span class="c1">// 取消gc等待标记
</span><span class="c1"></span>	<span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="c1">// 如果sysmon在等待则唤醒它
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 唤醒所有可运行的P
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">p1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">p1</span>
		<span class="nx">p1</span> <span class="p">=</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">mp</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startTheWorld: inconsistent mp-&gt;nextp&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
			<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// Start M to run P.  Do not start another M below.
</span><span class="c1"></span>			<span class="nf">newm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Capture start-the-world time before doing clean-up tasks.
</span><span class="c1"></span>	<span class="c1">// 记录事件
</span><span class="c1"></span>	<span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">emitTraceEvent</span> <span class="p">{</span>
		<span class="nf">traceGCSTWDone</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Wakeup an additional proc in case we have excessive runnable goroutines
</span><span class="c1"></span>	<span class="c1">// in local queues or in the global queue. If we don&#39;t, the proc will park itself.
</span><span class="c1"></span>	<span class="c1">// If we have lots of excessive work, resetspinning will unpark additional procs as necessary.
</span><span class="c1"></span>	<span class="c1">// 如果这里还有的空闲pidle并且m还在自旋，则继续环境
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">wakep</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="c1">// 恢复抢占请求
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span> <span class="c1">// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">startTime</span>
<span class="p">}</span>

</code></pre></div><h4 id="gcdrain">gcDrain</h4>
<p>gcDrain 从根部和对象开始扫描，将灰色对象变黑直到没有任务需要处理</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcDrain</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">flags</span> <span class="nx">gcDrainFlags</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">needed</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcDrain phase incorrect&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
	<span class="c1">// 当前g在抢占中，直接返回
</span><span class="c1"></span>	<span class="nx">preemptible</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainUntilPreempt</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="c1">// 刷新gc扫描任务
</span><span class="c1"></span>	<span class="nx">flushBgCredit</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainFlushBgCredit</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="c1">// 是否空闲
</span><span class="c1"></span>	<span class="nx">idle</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainIdle</span> <span class="o">!=</span> <span class="mi">0</span>

	<span class="c1">// 记录初始已扫描的数量
</span><span class="c1"></span>	<span class="nx">initScanWork</span> <span class="o">:=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span>

	<span class="c1">// checkWork is the scan work before performing the next
</span><span class="c1"></span>	<span class="c1">// self-preempt check.
</span><span class="c1"></span>	<span class="c1">// checkWork 在扫描之前检查
</span><span class="c1"></span>	<span class="nx">checkWork</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">check</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span>
	<span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">gcDrainIdle</span><span class="p">|</span><span class="nx">gcDrainFractional</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">checkWork</span> <span class="p">=</span> <span class="nx">initScanWork</span> <span class="o">+</span> <span class="nx">drainCheckThreshold</span>
		<span class="k">if</span> <span class="nx">idle</span> <span class="p">{</span>
			<span class="nx">check</span> <span class="p">=</span> <span class="nx">pollWork</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainFractional</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">check</span> <span class="p">=</span> <span class="nx">pollFractionalWorkerExit</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 如果根对象未扫描完， 则先扫描根对象
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span> <span class="p">&lt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">!(</span><span class="nx">preemptible</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 从扫描队列中取出一个值
</span><span class="c1"></span>			<span class="nx">job</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">job</span> <span class="o">&gt;=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="c1">// 执行跟对象扫描
</span><span class="c1"></span>			<span class="nf">markroot</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">job</span><span class="p">)</span>
			<span class="c1">// 如果是idle模式并且有其他工作，则返回
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">check</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">done</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 消费标记队列
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">!(</span><span class="nx">preemptible</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 如果全局标记队列为空，把本地标记队列的一部分分过去
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">full</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nf">balance</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="nx">b</span> <span class="o">:=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGetFast</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGet</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// 刷新写屏障buffer，尝试再次获取标记队列
</span><span class="c1"></span>				<span class="nf">wbBufFlush</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
				<span class="nx">b</span> <span class="p">=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGet</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 为空，则退出
</span><span class="c1"></span>			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nf">scanobject</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>

		<span class="c1">// 如果扫描的对象已经超过gcCreditSlack=2000
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">&gt;=</span> <span class="nx">gcCreditSlack</span> <span class="p">{</span>
			<span class="c1">// 把扫描的对象加入到全局
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">)</span>
			<span class="c1">// 减少辅助GC的工作量和唤醒等待的G
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">flushBgCredit</span> <span class="p">{</span>
				<span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">-</span> <span class="nx">initScanWork</span><span class="p">)</span>
				<span class="nx">initScanWork</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">}</span>
			<span class="nx">checkWork</span> <span class="o">-=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>

			<span class="k">if</span> <span class="nx">checkWork</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">checkWork</span> <span class="o">+=</span> <span class="nx">drainCheckThreshold</span>
				<span class="k">if</span> <span class="nx">check</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nx">done</span><span class="p">:</span>
	<span class="c1">// 把扫描的对象数量添加到全局
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">)</span>
		<span class="c1">// 减少辅助GC的工作量和唤醒等待的G
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">flushBgCredit</span> <span class="p">{</span>
			<span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">-</span> <span class="nx">initScanWork</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="markroot">markroot</h4>
<p>根对象扫描工作</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">markroot</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 根据算出的数组去执行对应的任务
</span><span class="c1"></span>	<span class="nx">baseFlushCache</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">fixedRootCount</span><span class="p">)</span>
	<span class="nx">baseData</span> <span class="o">:=</span> <span class="nx">baseFlushCache</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nFlushCacheRoots</span><span class="p">)</span>
	<span class="nx">baseBSS</span> <span class="o">:=</span> <span class="nx">baseData</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span><span class="p">)</span>
	<span class="nx">baseSpans</span> <span class="o">:=</span> <span class="nx">baseBSS</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span><span class="p">)</span>
	<span class="nx">baseStacks</span> <span class="o">:=</span> <span class="nx">baseSpans</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nSpanRoots</span><span class="p">)</span>
	<span class="nx">end</span> <span class="o">:=</span> <span class="nx">baseStacks</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nStackRoots</span><span class="p">)</span>

	<span class="c1">// Note: if you add a case here, please also update heapdump.go:dumproots.
</span><span class="c1"></span>	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">baseFlushCache</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseData</span><span class="p">:</span>
		<span class="c1">// 释放mache中的span
</span><span class="c1"></span>		<span class="nf">flushmcache</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="nx">baseFlushCache</span><span class="p">))</span>

	<span class="k">case</span> <span class="nx">baseData</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseBSS</span><span class="p">:</span>
		<span class="c1">// 扫描可读写的全局变量
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">markrootBlock</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">edata</span><span class="o">-</span><span class="nx">datap</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">gcdatamask</span><span class="p">.</span><span class="nx">bytedata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseData</span><span class="p">))</span>
		<span class="p">}</span>

	<span class="k">case</span> <span class="nx">baseBSS</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseSpans</span><span class="p">:</span>
		<span class="c1">// 扫描只读的环境变量
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">markrootBlock</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">bss</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">ebss</span><span class="o">-</span><span class="nx">datap</span><span class="p">.</span><span class="nx">bss</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">gcbssmask</span><span class="p">.</span><span class="nx">bytedata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseBSS</span><span class="p">))</span>
		<span class="p">}</span>

	<span class="k">case</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">fixedRootFinalizers</span><span class="p">:</span>
		<span class="c1">// 扫描析构器队列
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">fb</span> <span class="o">:=</span> <span class="nx">allfin</span><span class="p">;</span> <span class="nx">fb</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">fb</span> <span class="p">=</span> <span class="nx">fb</span><span class="p">.</span><span class="nx">alllink</span> <span class="p">{</span>
			<span class="nx">cnt</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fb</span><span class="p">.</span><span class="nx">cnt</span><span class="p">))</span>
			<span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fb</span><span class="p">.</span><span class="nx">fin</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">cnt</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">fb</span><span class="p">.</span><span class="nx">fin</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">&amp;</span><span class="nx">finptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="p">}</span>

	<span class="k">case</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">fixedRootFreeGStacks</span><span class="p">:</span>
		<span class="c1">// 释放中止的栈（Gdead）
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="nx">markrootFreeGStacks</span><span class="p">)</span>

	<span class="k">case</span> <span class="nx">baseSpans</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseStacks</span><span class="p">:</span>
		<span class="c1">// 扫描各个span的特殊对象
</span><span class="c1"></span>		<span class="nf">markrootSpans</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseSpans</span><span class="p">))</span>

	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// 扫描各个栈
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span>
		<span class="c1">// 获取需要扫描的g
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">baseStacks</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">end</span> <span class="p">{</span>
			<span class="nx">gp</span> <span class="p">=</span> <span class="nx">allgs</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseStacks</span><span class="p">]</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;markroot: bad index&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// 记录开始的时间
</span><span class="c1"></span>		<span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// We are not in a scan state
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Gwaiting</span> <span class="o">||</span> <span class="nx">status</span> <span class="o">==</span> <span class="nx">_Gsyscall</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tstart</span>
		<span class="p">}</span>

		<span class="c1">// scang must be done on the system stack in case
</span><span class="c1"></span>		<span class="c1">// we&#39;re trying to scan our own stack.
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 判断当前扫描的栈是不是自己的
</span><span class="c1"></span>			<span class="nx">userG</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
			<span class="nx">selfScan</span> <span class="o">:=</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">userG</span> <span class="o">&amp;&amp;</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">userG</span><span class="p">)</span> <span class="o">==</span> <span class="nx">_Grunning</span>
			<span class="k">if</span> <span class="nx">selfScan</span> <span class="p">{</span>
				<span class="c1">// 如果扫描的栈则将状态改成Gwaiting，防止死锁
</span><span class="c1"></span>				<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">userG</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
				<span class="nx">userG</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">waitReasonGarbageCollectionScan</span>
			<span class="p">}</span>

			<span class="c1">// 阻塞式的扫描
</span><span class="c1"></span>			<span class="nf">scang</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>

			<span class="k">if</span> <span class="nx">selfScan</span> <span class="p">{</span>
				<span class="c1">// 切换状态
</span><span class="c1"></span>				<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">userG</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">})</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="scang">scang</h4>
<p>扫描g的栈</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">scang</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Invariant; we (the caller, markroot for a specific goroutine) own gp.gcscandone.
</span><span class="c1"></span>	<span class="c1">// Nothing is racing with us now, but gcscandone might be set to true left over
</span><span class="c1"></span>	<span class="c1">// from an earlier round of stack scanning (we scan twice per GC).
</span><span class="c1"></span>	<span class="c1">// We use gcscandone to record whether the scan has been done during this round.
</span><span class="c1"></span>	<span class="c1">// 标记扫描未完成
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="c1">// See https://golang.org/cl/21503 for justification of the yield delay.
</span><span class="c1"></span>	<span class="kd">const</span> <span class="nx">yieldDelay</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span>
	<span class="kd">var</span> <span class="nx">nextYield</span> <span class="kt">int64</span>

	<span class="c1">// Endeavor to get gcscandone set to true,
</span><span class="c1"></span>	<span class="c1">// either by doing the stack scan ourselves or by coercing gp to scan itself.
</span><span class="c1"></span>	<span class="c1">// gp.gcscandone can transition from false to true when we&#39;re not looking
</span><span class="c1"></span>	<span class="c1">// (if we asked for preemption), so any time we lock the status using
</span><span class="c1"></span>	<span class="c1">// castogscanstatus we have to double-check that the scan is still not done.
</span><span class="c1"></span><span class="nx">loop</span><span class="p">:</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">!</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">s</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">);</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nf">dumpgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;stopg: invalid status&#34;</span><span class="p">)</span>

		<span class="k">case</span> <span class="nx">_Gdead</span><span class="p">:</span>
			<span class="c1">// 处于dead，跳过
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="k">break</span> <span class="nx">loop</span>

		<span class="k">case</span> <span class="nx">_Gcopystack</span><span class="p">:</span>
		<span class="c1">// 切换堆栈中
</span><span class="c1"></span>
		<span class="k">case</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">:</span>
			<span class="c1">// 运行中，将状态置为待扫描，一旦抢占后立即扫描
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">castogscanstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">s</span><span class="p">|</span><span class="nx">_Gscan</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">{</span>
					<span class="nf">scanstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>
					<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="p">}</span>
				<span class="nf">restartg</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
				<span class="k">break</span> <span class="nx">loop</span>
			<span class="p">}</span>

		<span class="k">case</span> <span class="nx">_Gscanwaiting</span><span class="p">:</span>
		<span class="c1">// 扫描等待中
</span><span class="c1"></span>
		<span class="k">case</span> <span class="nx">_Grunning</span><span class="p">:</span>
			<span class="c1">// Goroutine运行中，尝试抢占
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptscan</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="o">==</span> <span class="nx">stackPreempt</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="c1">// 要求抢占，进行扫描
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">castogscanstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gscanrunning</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">{</span>
					<span class="nx">gp</span><span class="p">.</span><span class="nx">preemptscan</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
				<span class="p">}</span>
				<span class="nf">casfrom_Gscanstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gscanrunning</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// 第一次等10ms
</span><span class="c1"></span>			<span class="nx">nextYield</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">+</span> <span class="nx">yieldDelay</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">nextYield</span> <span class="p">{</span>
			<span class="nf">procyield</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">osyield</span><span class="p">()</span>
			<span class="c1">// 第二次5ms，后续每次递减
</span><span class="c1"></span>			<span class="nx">nextYield</span> <span class="p">=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">+</span> <span class="nx">yieldDelay</span><span class="o">/</span><span class="mi">2</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 扫描完成，取消抢占标记
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">preemptscan</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// cancel scan request if no longer needed
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="scanstack">scanstack</h4>
<p>扫描栈</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">scanstack</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcscanvalid</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span><span class="o">&amp;</span><span class="nx">_Gscan</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime:scanstack: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;atomicstatus=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;scanstack - bad status&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="nx">_Gscan</span> <span class="p">{</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;atomicstatus=&#34;</span><span class="p">,</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mark - bad status&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">_Gdead</span><span class="p">:</span>
		<span class="k">return</span>
	<span class="k">case</span> <span class="nx">_Grunning</span><span class="p">:</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: gp=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;atomicstatus=&#34;</span><span class="p">,</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;scanstack: goroutine not stopped&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Gsyscall</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">:</span>
		<span class="c1">// 只有这三种状态允许扫描
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;can&#39;t scan our own stack&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 如果不适用太多栈，则收缩栈
</span><span class="c1"></span>	<span class="nf">shrinkstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">state</span> <span class="nx">stackScanState</span>
	<span class="nx">state</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span>

	<span class="k">if</span> <span class="nx">stackTraceDebug</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;stack trace goroutine&#34;</span><span class="p">,</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">goid</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Scan the saved context register. This is effectively a live
</span><span class="c1"></span>	<span class="c1">// register that gets moved back and forth between the
</span><span class="c1"></span>	<span class="c1">// register and sched.ctxt without a write barrier.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span><span class="p">)),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oneptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 扫描栈
</span><span class="c1"></span>	<span class="nx">scanframe</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">frame</span> <span class="o">*</span><span class="nx">stkframe</span><span class="p">,</span> <span class="nx">unused</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="nf">scanframeworker</span><span class="p">(</span><span class="nx">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="c1">// 枚举所有的调用帧，分别调用scanframe
</span><span class="c1"></span>	<span class="nf">gentraceback</span><span class="p">(^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mh">0x7fffffff</span><span class="p">,</span> <span class="nx">scanframe</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="c1">// 扫描其他从堆指向对象指针， 通常是defers和panics
</span><span class="c1"></span>	<span class="nf">tracebackdefers</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">scanframe</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span><span class="p">;</span> <span class="nx">d</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">d</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">{</span>
		<span class="c1">// tracebackdefers above does not scan the func value, which could
</span><span class="c1"></span>		<span class="c1">// be a stack allocated closure. See issue 30453.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">fn</span><span class="p">)),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oneptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">state</span><span class="p">.</span><span class="nf">putPtr</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">)))</span>
	<span class="p">}</span>

	<span class="c1">// Find and scan all reachable stack objects.
</span><span class="c1"></span>	<span class="c1">// 查找和扫描所有可达的对象
</span><span class="c1"></span>	<span class="nx">state</span><span class="p">.</span><span class="nf">buildIndex</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">getPtr</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">obj</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">findObject</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">obj</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">t</span> <span class="o">:=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">typ</span>
		<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// We&#39;ve already scanned this object.
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">obj</span><span class="p">.</span><span class="nf">setType</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="c1">// Don&#39;t scan it again.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">stackTraceDebug</span> <span class="p">{</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;  live stkobj at&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">off</span><span class="p">)),</span> <span class="s">&#34;of type&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nb">string</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">gcdata</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">gcdata</span>
		<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindGCProg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// This path is pretty unlikely, an object large enough
</span><span class="c1"></span>			<span class="c1">// to have a GC program allocated on the stack.
</span><span class="c1"></span>			<span class="c1">// We need some space to unpack the program into a straight
</span><span class="c1"></span>			<span class="c1">// bitmask, which we allocate/free here.
</span><span class="c1"></span>			<span class="c1">// TODO: it would be nice if there were a way to run a GC
</span><span class="c1"></span>			<span class="c1">// program without having to store all its bits. We&#39;d have
</span><span class="c1"></span>			<span class="c1">// to change from a Lempel-Ziv style program to something else.
</span><span class="c1"></span>			<span class="c1">// Or we can forbid putting objects on stacks if they require
</span><span class="c1"></span>			<span class="c1">// a gc program (see issue 27447).
</span><span class="c1"></span>			<span class="nx">s</span> <span class="p">=</span> <span class="nf">materializeGCProg</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">,</span> <span class="nx">gcdata</span><span class="p">)</span>
			<span class="nx">gcdata</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">startAddr</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="nf">scanblock</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">off</span><span class="p">),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">,</span> <span class="nx">gcdata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">dematerializeGCProg</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Deallocate object buffers.
</span><span class="c1"></span>	<span class="c1">// (Pointer buffers were all deallocated in the loop above.)
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">state</span><span class="p">.</span><span class="nx">head</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">head</span>
		<span class="nx">state</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">next</span>
		<span class="k">if</span> <span class="nx">stackTraceDebug</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">obj</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">x</span><span class="p">.</span><span class="nx">obj</span><span class="p">[:</span><span class="nx">x</span><span class="p">.</span><span class="nx">nobj</span><span class="p">]</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">typ</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// reachable
</span><span class="c1"></span>					<span class="k">continue</span>
				<span class="p">}</span>
				<span class="nb">println</span><span class="p">(</span><span class="s">&#34;  dead stkobj at&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">off</span><span class="p">)),</span> <span class="s">&#34;of type&#34;</span><span class="p">,</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">typ</span><span class="p">.</span><span class="nb">string</span><span class="p">())</span>
				<span class="c1">// Note: not necessarily really dead - only reachable-from-ptr dead.
</span><span class="c1"></span>			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">x</span><span class="p">.</span><span class="nx">nobj</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">putempty</span><span class="p">((</span><span class="o">*</span><span class="nx">workbuf</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">state</span><span class="p">.</span><span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">state</span><span class="p">.</span><span class="nx">freeBuf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;remaining pointer buffers&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscanvalid</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><h4 id="scanblock">scanblock</h4>
<p>扫描函数，和scanobject不同的是bitmap需要手动传入</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">scanblock</span><span class="p">(</span><span class="nx">b0</span><span class="p">,</span> <span class="nx">n0</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">ptrmask</span> <span class="o">*</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">stk</span> <span class="o">*</span><span class="nx">stackScanState</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Use local copies of original parameters, so that a stack trace
</span><span class="c1"></span>	<span class="c1">// due to one of the throws below shows the original block
</span><span class="c1"></span>	<span class="c1">// base and extent.
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">b0</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">n0</span>

	<span class="c1">// 枚举扫描的地址
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="p">{</span>
		<span class="c1">// 找到bitmap对应的byte
</span><span class="c1"></span>		<span class="nx">bits</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="o">*</span><span class="nf">addb</span><span class="p">(</span><span class="nx">ptrmask</span><span class="p">,</span> <span class="nx">i</span><span class="o">/</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span><span class="p">)))</span>
		<span class="k">if</span> <span class="nx">bits</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">i</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">*</span> <span class="mi">8</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 枚举byte
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// 如果包含指针
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">bits</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// 和scanobject一样，
</span><span class="c1"></span>				<span class="nx">p</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span> <span class="o">+</span> <span class="nx">i</span><span class="p">))</span>
				<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="c1">// 找到这个对象的span和bitmap
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span> <span class="nx">obj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
						<span class="c1">// 标记该对象存活，并加入标记队列，并且变为会死
</span><span class="c1"></span>						<span class="nf">greyobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nx">objIndex</span><span class="p">)</span>
					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">stk</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span> <span class="o">&gt;=</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span> <span class="p">&lt;</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">{</span>
						<span class="c1">// stk.obj
</span><span class="c1"></span>						<span class="nx">stk</span><span class="p">.</span><span class="nf">putPtr</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="c1">// 指向下一位
</span><span class="c1"></span>			<span class="nx">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
			<span class="c1">// 指向下个指针
</span><span class="c1"></span>			<span class="nx">i</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="greyobject">greyobject</h4>
<p>标记一个对象存活，并将其放入到灰色标记队列</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">greyobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">off</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">span</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// obj should be start of allocation, and so must be at least pointer-aligned.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">obj</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;greyobject: obj not pointer-aligned&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mbits</span> <span class="o">:=</span> <span class="nx">span</span><span class="p">.</span><span class="nf">markBitsForIndex</span><span class="p">(</span><span class="nx">objIndex</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">useCheckmark</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">printlock</span><span class="p">()</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime:greyobject: checkmarks finds unexpected unmarked object obj=&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: found obj at *(&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">base</span><span class="p">),</span> <span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">off</span><span class="p">),</span> <span class="s">&#34;)\n&#34;</span><span class="p">)</span>

			<span class="c1">// Dump the source (base) object
</span><span class="c1"></span>			<span class="nf">gcDumpObject</span><span class="p">(</span><span class="s">&#34;base&#34;</span><span class="p">,</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">off</span><span class="p">)</span>

			<span class="c1">// Dump the object
</span><span class="c1"></span>			<span class="nf">gcDumpObject</span><span class="p">(</span><span class="s">&#34;obj&#34;</span><span class="p">,</span> <span class="nx">obj</span><span class="p">,</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

			<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;checkmark found unmarked object&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">hbits</span> <span class="o">:=</span> <span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">hbits</span><span class="p">.</span><span class="nf">isCheckmarked</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">hbits</span><span class="p">.</span><span class="nf">setCheckmarked</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">hbits</span><span class="p">.</span><span class="nf">isCheckmarked</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;setCheckmarked and isCheckmarked disagree&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gccheckmark</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">span</span><span class="p">.</span><span class="nf">isFree</span><span class="p">(</span><span class="nx">objIndex</span><span class="p">)</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: marking free object &#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span> <span class="s">&#34; found at *(&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">base</span><span class="p">),</span> <span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="nf">hex</span><span class="p">(</span><span class="nx">off</span><span class="p">),</span> <span class="s">&#34;)\n&#34;</span><span class="p">)</span>
			<span class="nf">gcDumpObject</span><span class="p">(</span><span class="s">&#34;base&#34;</span><span class="p">,</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">off</span><span class="p">)</span>
			<span class="nf">gcDumpObject</span><span class="p">(</span><span class="s">&#34;obj&#34;</span><span class="p">,</span> <span class="nx">obj</span><span class="p">,</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
			<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;marking free object&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// If marked we have nothing to do.
</span><span class="c1"></span>		<span class="c1">// 如果对象所在span的gcMarkBits对应的bit位已经标记为1，则返回
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 设置gcMarkBits对应的bit位为1
</span><span class="c1"></span>		<span class="nx">mbits</span><span class="p">.</span><span class="nf">setMarked</span><span class="p">()</span>

		<span class="c1">// 标记span
</span><span class="c1"></span>		<span class="nx">arena</span><span class="p">,</span> <span class="nx">pageIdx</span><span class="p">,</span> <span class="nx">pageMask</span> <span class="o">:=</span> <span class="nf">pageIndexOf</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">arena</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">pageMask</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arena</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">],</span> <span class="nx">pageMask</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// If this is a noscan object, fast-track it to black
</span><span class="c1"></span>		<span class="c1">// instead of greying it.
</span><span class="c1"></span>		<span class="c1">// 如果是个noscan对象，则直接将放入灰色对象标记队列
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">span</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">noscan</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 把对象放入标记队列，如果放入本地队列失败，则将其放入全局队列
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">putFast</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">gcw</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="scanobject">scanobject</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">scanobject</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Find the bits for b and the size of the object at b.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// b is either the beginning of an object, in which case this
</span><span class="c1"></span>	<span class="c1">// is the size of the object to scan, or it points to an
</span><span class="c1"></span>	<span class="c1">// oblet, in which case we compute the size to scan below.
</span><span class="c1"></span>	<span class="c1">// 获取对象的bitmap
</span><span class="c1"></span>	<span class="nx">hbits</span> <span class="o">:=</span> <span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="c1">// 获取对象的span
</span><span class="c1"></span>	<span class="nx">s</span> <span class="o">:=</span> <span class="nf">spanOfUnchecked</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="c1">// 获取对象的大小
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;scanobject n == 0&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 对象大于128KB需要切割扫描
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">maxObletBytes</span> <span class="p">{</span>
		<span class="c1">// Large object. Break into oblets for better
</span><span class="c1"></span>		<span class="c1">// parallelism and lower latency.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// It&#39;s possible this is a noscan object (not
</span><span class="c1"></span>			<span class="c1">// from greyobject, but from other code
</span><span class="c1"></span>			<span class="c1">// paths), in which case we must *not* enqueue
</span><span class="c1"></span>			<span class="c1">// oblets since their bitmaps will be
</span><span class="c1"></span>			<span class="c1">// uninitialized.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">noscan</span><span class="p">()</span> <span class="p">{</span>
				<span class="c1">// Bypass the whole scan.
</span><span class="c1"></span>				<span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="c1">// Enqueue the other oblets to scan later.
</span><span class="c1"></span>			<span class="c1">// Some oblets may be in b&#39;s scalar tail, but
</span><span class="c1"></span>			<span class="c1">// these will be marked as &#34;no more pointers&#34;,
</span><span class="c1"></span>			<span class="c1">// so we&#39;ll drop out immediately when we go to
</span><span class="c1"></span>			<span class="c1">// scan those.
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">oblet</span> <span class="o">:=</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">maxObletBytes</span><span class="p">;</span> <span class="nx">oblet</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">+</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">;</span> <span class="nx">oblet</span> <span class="o">+=</span> <span class="nx">maxObletBytes</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">putFast</span><span class="p">(</span><span class="nx">oblet</span><span class="p">)</span> <span class="p">{</span>
					<span class="nx">gcw</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="nx">oblet</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Compute the size of the oblet. Since this object
</span><span class="c1"></span>		<span class="c1">// must be a large object, s.base() is the beginning
</span><span class="c1"></span>		<span class="c1">// of the object.
</span><span class="c1"></span>		<span class="nx">n</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">-</span> <span class="nx">b</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">maxObletBytes</span> <span class="p">{</span>
			<span class="nx">n</span> <span class="p">=</span> <span class="nx">maxObletBytes</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 扫描对象的指针
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">i</span> <span class="kt">uintptr</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="p">{</span>
		<span class="c1">// Find bits for this word.
</span><span class="c1"></span>		<span class="c1">// 获取对应的bit
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Avoid needless hbits.next() on last iteration.
</span><span class="c1"></span>			<span class="nx">hbits</span> <span class="p">=</span> <span class="nx">hbits</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// Load bits once. See CL 22712 and issue 16973 for discussion.
</span><span class="c1"></span>		<span class="nx">bits</span> <span class="o">:=</span> <span class="nx">hbits</span><span class="p">.</span><span class="nf">bits</span><span class="p">()</span>
		<span class="c1">// During checkmarking, 1-word objects store the checkmark
</span><span class="c1"></span>		<span class="c1">// in the type bit for the one word. The only one-word objects
</span><span class="c1"></span>		<span class="c1">// are pointers, or else they&#39;d be merged with other non-pointer
</span><span class="c1"></span>		<span class="c1">// data into larger allocations.
</span><span class="c1"></span>		<span class="c1">// 检查scan bit判断是否扫描
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">&amp;&amp;</span> <span class="nx">bits</span><span class="o">&amp;</span><span class="nx">bitScan</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">break</span> <span class="c1">// no more pointers in this object
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="c1">// 不是指针则跳过
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">bits</span><span class="o">&amp;</span><span class="nx">bitPointer</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">continue</span> <span class="c1">// not a pointer
</span><span class="c1"></span>		<span class="p">}</span>

		<span class="c1">// 取值
</span><span class="c1"></span>		<span class="nx">obj</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span> <span class="o">+</span> <span class="nx">i</span><span class="p">))</span>

		<span class="c1">// At this point we have extracted the next potential pointer.
</span><span class="c1"></span>		<span class="c1">// Quickly filter out nil and pointers back to the current object.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">obj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="o">-</span><span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">n</span> <span class="p">{</span>
			<span class="c1">// Test if obj points into the Go heap and, if so,
</span><span class="c1"></span>			<span class="c1">// mark the object.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// Note that it&#39;s possible for findObject to
</span><span class="c1"></span>			<span class="c1">// fail if obj points to a just-allocated heap
</span><span class="c1"></span>			<span class="c1">// object because of a race with growing the
</span><span class="c1"></span>			<span class="c1">// heap. In this case, we know the object was
</span><span class="c1"></span>			<span class="c1">// just allocated and hence will be marked by
</span><span class="c1"></span>			<span class="c1">// allocation itself.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span> <span class="nx">obj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">greyobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nx">objIndex</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="gcmarkdone">gcMarkDone</h4>
<p>调用gcMarkDone进入完成标记阶段
在并行GC中gcMarkDone会被执行两次, 第一次会禁止本地标记队列然后重新开始后台标记任务, 第二次会进入完成标记阶段(mark termination)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkDone</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 加锁确定同一时间只有1个线程在运行
</span><span class="c1"></span>	<span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markDoneSema</span><span class="p">)</span>

<span class="nx">top</span><span class="p">:</span>
	<span class="c1">// Re-check transition condition under transition lock.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// It&#39;s critical that this checks the global work queues are
</span><span class="c1"></span>	<span class="c1">// empty before performing the ragged barrier. Otherwise,
</span><span class="c1"></span>	<span class="c1">// there could be global work that a P could take after the P
</span><span class="c1"></span>	<span class="c1">// has passed the ragged barrier.
</span><span class="c1"></span>	<span class="c1">// 再次检查
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!(</span><span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmark</span> <span class="o">&amp;&amp;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span> <span class="p">{</span>
		<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markDoneSema</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// Flush all local buffers and collect flushedWork flags.
</span><span class="c1"></span>	<span class="c1">// 刷新所有本地缓存并收集刷新任务标示
</span><span class="c1"></span>	<span class="nx">gcMarkDoneFlushed</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
		<span class="c1">// Mark the user stack as preemptible so that it may be scanned.
</span><span class="c1"></span>		<span class="c1">// Otherwise, our attempt to force all P&#39;s to a safepoint could
</span><span class="c1"></span>		<span class="c1">// result in a deadlock as we attempt to preempt a worker that&#39;s
</span><span class="c1"></span>		<span class="c1">// trying to preempt us (e.g. for a stack scan).
</span><span class="c1"></span>		<span class="c1">// 标记g为可抢占，以便对其扫描
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
		<span class="nf">forEachP</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Flush the write barrier buffer, since this may add
</span><span class="c1"></span>			<span class="c1">// work to the gcWork.
</span><span class="c1"></span>			<span class="c1">// 刷新写屏障buffer
</span><span class="c1"></span>			<span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="c1">// For debugging, shrink the write barrier
</span><span class="c1"></span>			<span class="c1">// buffer so it flushes immediately.
</span><span class="c1"></span>			<span class="c1">// wbBuf.reset will keep it at this size as
</span><span class="c1"></span>			<span class="c1">// long as throwOnGCWork is set.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
				<span class="nx">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">wbBuf</span>
				<span class="nx">b</span><span class="p">.</span><span class="nx">end</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">wbBufEntryPointers</span><span class="p">]))</span>
				<span class="nx">b</span><span class="p">.</span><span class="nx">debugGen</span> <span class="p">=</span> <span class="nx">gcWorkPauseGen</span>
			<span class="p">}</span>
			<span class="c1">// Flush the gcWork, since this may create global work
</span><span class="c1"></span>			<span class="c1">// and set the flushedWork flag.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// TODO(austin): Break up these workbufs to
</span><span class="c1"></span>			<span class="c1">// better distribute work.
</span><span class="c1"></span>			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">dispose</span><span class="p">()</span>
			<span class="c1">// Collect the flushedWork flag.
</span><span class="c1"></span>			<span class="c1">// 统计flushedWork
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span> <span class="p">{</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcMarkDoneFlushed</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
				<span class="c1">// For debugging, freeze the gcWork
</span><span class="c1"></span>				<span class="c1">// until we know whether we&#39;ve reached
</span><span class="c1"></span>				<span class="c1">// completion or not. If we think
</span><span class="c1"></span>				<span class="c1">// we&#39;ve reached completion, but
</span><span class="c1"></span>				<span class="c1">// there&#39;s a paused gcWork, then
</span><span class="c1"></span>				<span class="c1">// that&#39;s a bug.
</span><span class="c1"></span>				<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseGen</span> <span class="p">=</span> <span class="nx">gcWorkPauseGen</span>
				<span class="c1">// Capture the G&#39;s stack.
</span><span class="c1"></span>				<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseStack</span> <span class="p">{</span>
					<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseStack</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
				<span class="p">}</span>
				<span class="nf">callers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseStack</span><span class="p">[:])</span>
			<span class="p">}</span>
		<span class="p">})</span>
		<span class="c1">// 重置g的状
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">gcMarkDoneFlushed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
			<span class="c1">// Release paused gcWorks.
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcWorkPauseGen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// More grey objects were discovered since the
</span><span class="c1"></span>		<span class="c1">// previous termination check, so there may be more
</span><span class="c1"></span>		<span class="c1">// work to do. Keep going. It&#39;s possible the
</span><span class="c1"></span>		<span class="c1">// transition condition became true again during the
</span><span class="c1"></span>		<span class="c1">// ragged barrier, so re-check it.
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
		<span class="nx">throwOnGCWork</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="c1">// Release paused gcWorks. If there are any, they
</span><span class="c1"></span>		<span class="c1">// should now observe throwOnGCWork and panic.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcWorkPauseGen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 记录完成标记的时间和开始STW的时间
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">tMarkTerm</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="c1">// 禁止G抢占
</span><span class="c1"></span>	<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;gcing&#34;</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSTWStart</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// STW 
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">stopTheWorldWithSema</span><span class="p">)</span>
	<span class="c1">// The gcphase is _GCmark, it will transition to _GCmarktermination
</span><span class="c1"></span>	<span class="c1">// below. The important thing is that the wb remains active until
</span><span class="c1"></span>	<span class="c1">// all marking is complete. This includes writes made by the GC.
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
		<span class="c1">// For debugging, double check that no work was added after we
</span><span class="c1"></span>		<span class="c1">// went around above and disable write barrier buffering.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
			<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcw</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">printlock</span><span class="p">()</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: P &#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="s">&#34; flushedWork &#34;</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf1</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf1=&lt;nil&gt;&#34;</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf1.n=&#34;</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf1</span><span class="p">.</span><span class="nx">nobj</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf2=&lt;nil&gt;&#34;</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nb">print</span><span class="p">(</span><span class="s">&#34; wbuf2.n=&#34;</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">wbuf2</span><span class="p">.</span><span class="nx">nobj</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">pauseGen</span> <span class="o">==</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">putGen</span> <span class="p">{</span>
					<span class="nb">println</span><span class="p">(</span><span class="s">&#34;runtime: checkPut already failed at this generation&#34;</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;throwOnGCWork&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// For unknown reasons (see issue #27993), there is
</span><span class="c1"></span>		<span class="c1">// sometimes work left over when we enter mark
</span><span class="c1"></span>		<span class="c1">// termination. Detect this and resume concurrent
</span><span class="c1"></span>		<span class="c1">// mark. This is obviously unfortunate.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Switch to the system stack to call wbBufFlush1,
</span><span class="c1"></span>		<span class="c1">// though in this case it doesn&#39;t matter because we&#39;re
</span><span class="c1"></span>		<span class="c1">// non-preemptible anyway.
</span><span class="c1"></span>		<span class="nx">restart</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
				<span class="c1">// 刷新写屏障buffer
</span><span class="c1"></span>				<span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">restart</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">})</span>
		<span class="k">if</span> <span class="nx">restart</span> <span class="p">{</span>
			<span class="c1">// 标记为可抢占
</span><span class="c1"></span>			<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
			<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="c1">// 启动STW
</span><span class="c1"></span>				<span class="nx">now</span> <span class="o">:=</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
				<span class="c1">// 暂停的时间
</span><span class="c1"></span>				<span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="o">+=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span>
			<span class="p">})</span>
			<span class="k">goto</span> <span class="nx">top</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 禁止gc辅助助手和后台任务
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="c1">// 唤醒所有因为辅助GC而休眠的G
</span><span class="c1"></span>	<span class="nf">gcWakeAllAssists</span><span class="p">()</span>

	<span class="c1">// Likewise, release the transition lock. Blocked
</span><span class="c1"></span>	<span class="c1">// workers and assists will run when we start the
</span><span class="c1"></span>	<span class="c1">// world again.
</span><span class="c1"></span>	<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markDoneSema</span><span class="p">)</span>

	<span class="c1">// In STW mode, re-enable user goroutines. These will be
</span><span class="c1"></span>	<span class="c1">// queued to run after we start the world.
</span><span class="c1"></span>	<span class="nf">schedEnableUser</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>

	<span class="c1">// 计算下一次GC需要的heap大小
</span><span class="c1"></span>	<span class="nx">nextTriggerRatio</span> <span class="o">:=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">endCycle</span><span class="p">()</span>

	<span class="c1">// 完成标记界面，会重新Start the world
</span><span class="c1"></span>	<span class="nf">gcMarkTermination</span><span class="p">(</span><span class="nx">nextTriggerRatio</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="gcmarktermination">gcMarkTermination</h4>
<p>进入标记完成阶段</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkTermination</span><span class="p">(</span><span class="nx">nextTriggerRatio</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 世界停止了....
</span><span class="c1"></span>
	<span class="c1">// 禁止辅助GC和后台标记任务运行
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="c1">// 进入GC完成标记阶段，开启写屏障
</span><span class="c1"></span>	<span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCmarktermination</span><span class="p">)</span>

	<span class="nx">work</span><span class="p">.</span><span class="nx">heap1</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span>
	<span class="c1">// 记录开始时间
</span><span class="c1"></span>	<span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>

	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="c1">// 禁止抢占
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;gcing&#34;</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
	<span class="c1">// 设置Gwaiting状态
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">waitReasonGarbageCollection</span>

	<span class="c1">// 切换到g0
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 开始标记
</span><span class="c1"></span>		<span class="nf">gcMark</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>
		<span class="c1">// 必须直接返回，因为外面的栈有可能被移动，所以我们不能直接访问外面的变量
</span><span class="c1"></span>	<span class="p">})</span>

	<span class="c1">// 重新切换到g0执行
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">work</span><span class="p">.</span><span class="nx">heap2</span> <span class="p">=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">bytesMarked</span>
		<span class="c1">// 如果启动了checkmark，检查所有的对象是否都有标记
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gccheckmark</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// Run a full non-parallel, stop-the-world
</span><span class="c1"></span>			<span class="c1">// mark using checkmark bits, to check that we
</span><span class="c1"></span>			<span class="c1">// didn&#39;t forget to mark anything during the
</span><span class="c1"></span>			<span class="c1">// concurrent mark process.
</span><span class="c1"></span>			<span class="nf">gcResetMarkState</span><span class="p">()</span>
			<span class="nf">initCheckmarks</span><span class="p">()</span>
			<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">gcw</span>
			<span class="nf">gcDrain</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nf">dispose</span><span class="p">()</span>
			<span class="nf">clearCheckmarks</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="c1">// 更新GC状态为关闭，关闭写屏障
</span><span class="c1"></span>		<span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCoff</span><span class="p">)</span>
		<span class="c1">// 唤醒后台庆松任务
</span><span class="c1"></span>		<span class="nf">gcSweep</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">mode</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="c1">// 将g状态修改为运行中
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCDone</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// 运行g抢占
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>

	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gc done but gcphase != _GCoff&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 更新下一轮的gc trigger
</span><span class="c1"></span>	<span class="nf">gcSetTriggerRatio</span><span class="p">(</span><span class="nx">nextTriggerRatio</span><span class="p">)</span>

	<span class="c1">// 更新时间统计
</span><span class="c1"></span>	<span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
	<span class="nx">sec</span><span class="p">,</span> <span class="nx">nsec</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">time_now</span><span class="p">()</span>
	<span class="nx">unixNow</span> <span class="o">:=</span> <span class="nx">sec</span><span class="o">*</span><span class="mf">1e9</span> <span class="o">+</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">nsec</span><span class="p">)</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="o">+=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">tEnd</span> <span class="p">=</span> <span class="nx">now</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">last_gc_unix</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">unixNow</span><span class="p">))</span> <span class="c1">// must be Unix time to make sense to user
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">last_gc_nanotime</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span> <span class="c1">// monotonic time for us
</span><span class="c1"></span>	<span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_ns</span><span class="p">[</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_ns</span><span class="p">))]</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_end</span><span class="p">[</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_end</span><span class="p">))]</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">unixNow</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">pause_total_ns</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span><span class="p">)</span>

	<span class="c1">// 更新任务总时间
</span><span class="c1"></span>	<span class="nx">sweepTermCpu</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">tMark</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span><span class="p">)</span>
	<span class="c1">// We report idle marking time below, but omit it from the
</span><span class="c1"></span>	<span class="c1">// overall utilization here since it&#39;s &#34;free&#34;.
</span><span class="c1"></span>	<span class="nx">markCpu</span> <span class="o">:=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistTime</span> <span class="o">+</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span> <span class="o">+</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">fractionalMarkTime</span>
	<span class="nx">markTermCpu</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">tEnd</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tMarkTerm</span><span class="p">)</span>
	<span class="nx">cycleCpu</span> <span class="o">:=</span> <span class="nx">sweepTermCpu</span> <span class="o">+</span> <span class="nx">markCpu</span> <span class="o">+</span> <span class="nx">markTermCpu</span>
	<span class="nx">work</span><span class="p">.</span><span class="nx">totaltime</span> <span class="o">+=</span> <span class="nx">cycleCpu</span>

	<span class="c1">// 计算总的GC CPU利用率
</span><span class="c1"></span>	<span class="nx">totalCpu</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">totaltime</span> <span class="o">+</span> <span class="p">(</span><span class="nx">now</span><span class="o">-</span><span class="nx">sched</span><span class="p">.</span><span class="nx">procresizetime</span><span class="p">)</span><span class="o">*</span><span class="nb">int64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_cpu_fraction</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">totaltime</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">totalCpu</span><span class="p">)</span>

	<span class="c1">// 重置清扫状态
</span><span class="c1"></span>	<span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">sweep</span><span class="p">.</span><span class="nx">npausesweep</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">userForced</span> <span class="p">{</span>
		<span class="nx">memstats</span><span class="p">.</span><span class="nx">numforcedgc</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="c1">// 统计GC执行的次数和唤醒等待清扫的G
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="o">++</span>
	<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">list</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Finish the current heap profiling cycle and start a new
</span><span class="c1"></span>	<span class="c1">// heap profiling cycle. We do this before starting the world
</span><span class="c1"></span>	<span class="c1">// so events don&#39;t leak into the wrong cycle.
</span><span class="c1"></span>	<span class="c1">// 性能统计
</span><span class="c1"></span>	<span class="nf">mProf_NextCycle</span><span class="p">()</span>

	<span class="c1">// START THE WORLD
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">})</span>

	<span class="c1">// Flush the heap profile so we can start a new cycle next GC.
</span><span class="c1"></span>	<span class="c1">// This is relatively expensive, so we don&#39;t do it with the
</span><span class="c1"></span>	<span class="c1">// world stopped.
</span><span class="c1"></span>	<span class="c1">// 性能统计
</span><span class="c1"></span>	<span class="nf">mProf_Flush</span><span class="p">()</span>

	<span class="c1">// Prepare workbufs for freeing by the sweeper. We do this
</span><span class="c1"></span>	<span class="c1">// asynchronously because it can take non-trivial time.
</span><span class="c1"></span>	<span class="c1">// 移动
</span><span class="c1"></span>	<span class="nf">prepareFreeWorkbufs</span><span class="p">()</span>

	<span class="c1">// 释放空闲的spans
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">freeStackSpans</span><span class="p">)</span>

	<span class="c1">// Ensure all mcaches are flushed. Each P will flush its own
</span><span class="c1"></span>	<span class="c1">// mcache before allocating, but idle Ps may not. Since this
</span><span class="c1"></span>	<span class="c1">// is necessary to sweep all spans, we need to ensure all
</span><span class="c1"></span>	<span class="c1">// mcaches are flushed before we start the next GC cycle.
</span><span class="c1"></span>	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">forEachP</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
		<span class="p">})</span>
	<span class="p">})</span>

	<span class="c1">// Print gctrace before dropping worldsema. As soon as we drop
</span><span class="c1"></span>	<span class="c1">// worldsema another cycle could start and smash the stats
</span><span class="c1"></span>	<span class="c1">// we&#39;re trying to print.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gctrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">util</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_cpu_fraction</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

		<span class="kd">var</span> <span class="nx">sbuf</span> <span class="p">[</span><span class="mi">24</span><span class="p">]</span><span class="kt">byte</span>
		<span class="nf">printlock</span><span class="p">()</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;gc &#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="p">,</span>
			<span class="s">&#34; @&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nf">itoaDiv</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span><span class="o">-</span><span class="nx">runtimeInitTime</span><span class="p">)</span><span class="o">/</span><span class="mf">1e6</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="s">&#34;s &#34;</span><span class="p">,</span>
			<span class="nx">util</span><span class="p">,</span> <span class="s">&#34;%: &#34;</span><span class="p">)</span>
		<span class="nx">prev</span> <span class="o">:=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span>
		<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ns</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">int64</span><span class="p">{</span><span class="nx">work</span><span class="p">.</span><span class="nx">tMark</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tMarkTerm</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tEnd</span><span class="p">}</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;+&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">fmtNSAsMS</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">ns</span><span class="o">-</span><span class="nx">prev</span><span class="p">))))</span>
			<span class="nx">prev</span> <span class="p">=</span> <span class="nx">ns</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34; ms clock, &#34;</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ns</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">int64</span><span class="p">{</span><span class="nx">sweepTermCpu</span><span class="p">,</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistTime</span><span class="p">,</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span> <span class="o">+</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">fractionalMarkTime</span><span class="p">,</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">idleMarkTime</span><span class="p">,</span> <span class="nx">markTermCpu</span><span class="p">}</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
				<span class="c1">// Separate mark time components with /.
</span><span class="c1"></span>				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;+&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nb">print</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nf">fmtNSAsMS</span><span class="p">(</span><span class="nx">sbuf</span><span class="p">[:],</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">ns</span><span class="p">))))</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34; ms cpu, &#34;</span><span class="p">,</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">heap0</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;-&gt;&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">heap1</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;-&gt;&#34;</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">heap2</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34; MB, &#34;</span><span class="p">,</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">heapGoal</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34; MB goal, &#34;</span><span class="p">,</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">maxprocs</span><span class="p">,</span> <span class="s">&#34; P&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">userForced</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34; (forced)&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">printunlock</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>
	<span class="c1">// Careful: another GC cycle may start now.
</span><span class="c1"></span>
	<span class="c1">// 允许g可以被抢占
</span><span class="c1"></span>	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nx">mp</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// now that gc is done, kick off finalizer thread if needed
</span><span class="c1"></span>	<span class="c1">// gc已完成
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">concurrentSweep</span> <span class="p">{</span>
		<span class="c1">// give the queued finalizers, if any, a chance to run
</span><span class="c1"></span>		<span class="c1">// 非并行GC，让M开始调度
</span><span class="c1"></span>		<span class="nf">Gosched</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="gcsweep">gcSweep</h4>
<p>唤醒后台清扫任务</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcSweep</span><span class="p">(</span><span class="nx">mode</span> <span class="nx">gcMode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcSweep being done but phase is not GCoff&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 增加sweepgen，sweepSpan两个队列角色会交换，所有的span会变成待清扫
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">+=</span> <span class="mi">2</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nx">index</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// We should have drained this list during the last
</span><span class="c1"></span>		<span class="c1">// sweep phase. We certainly need to start this phase
</span><span class="c1"></span>		<span class="c1">// with an empty swept list.
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;non-empty swept list&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSwept</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepArenas</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">allArenas</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimIndex</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimCredit</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// 非并行GC或者是强制模式(runtime.GC)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">_ConcurrentSweep</span> <span class="o">||</span> <span class="nx">mode</span> <span class="o">==</span> <span class="nx">gcForceBlockMode</span> <span class="p">{</span>
		<span class="c1">// Special case synchronous sweep.
</span><span class="c1"></span>		<span class="c1">// Record that no proportional sweeping has to happen.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepPagesPerByte</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="c1">// Sweep all spans eagerly.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">sweep</span><span class="p">.</span><span class="nx">npausesweep</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="c1">// Free workbufs eagerly.
</span><span class="c1"></span>		<span class="nf">prepareFreeWorkbufs</span><span class="p">()</span>
		<span class="k">for</span> <span class="nf">freeSomeWbufs</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">}</span>
		<span class="c1">// All &#34;free&#34; events for this mark/sweep cycle have
</span><span class="c1"></span>		<span class="c1">// now happened, so we can make this profile cycle
</span><span class="c1"></span>		<span class="c1">// available immediately.
</span><span class="c1"></span>		<span class="nf">mProf_NextCycle</span><span class="p">()</span>
		<span class="nf">mProf_Flush</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// 后台清扫
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">{</span>
		<span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="nf">ready</span><span class="p">(</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h4 id="bgsweep">bgsweep</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">bgsweep</span><span class="p">(</span><span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sweep</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// 等待唤醒
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>
	<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonGCSweepWait</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="c1">// 循环清扫
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="c1">// sweepone清扫heap上的数据，如果返回page number ==^uintptr(0)表示清理完成
</span><span class="c1"></span>		<span class="k">for</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span><span class="o">++</span>
			<span class="nf">Gosched</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="c1">// 释放一些未标记队列buf到heap，返回true则需要再释放一些
</span><span class="c1"></span>		<span class="k">for</span> <span class="nf">freeSomeWbufs</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">Gosched</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="c1">// 是否清扫完成，未完成则继续循环， sweepdone != 0
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nf">isSweepDone</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// This can happen if a GC runs between
</span><span class="c1"></span>			<span class="c1">// gosweepone returning ^0 above
</span><span class="c1"></span>			<span class="c1">// and the lock being acquired.
</span><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 让清扫任务进入休眠
</span><span class="c1"></span>		<span class="c1">// goparkunlock 会将goroutine变为等待状态，并且解锁，等待goready唤醒
</span><span class="c1"></span>		<span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonGCSweepWait</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="sweepone">sweepone</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">sweepRatio</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepPagesPerByte</span> <span class="c1">// For debugging
</span><span class="c1"></span>
	<span class="c1">// 禁止抢占
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
		<span class="k">return</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 同时执行sweep任务数量
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepers</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// 找出一个需要清扫的span
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="nx">sg</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">pop</span><span class="p">()</span>
		<span class="c1">// 没有需要清扫的span，退出
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// span没在使用，换而言之其他M正在清扫这个span
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanInUse</span> <span class="p">{</span>
			<span class="c1">// This can happen if direct sweeping already
</span><span class="c1"></span>			<span class="c1">// swept this span, but in that case the sweep
</span><span class="c1"></span>			<span class="c1">// generation should always be up-to-date.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!(</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: bad span s.state=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="s">&#34; s.sweepgen=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34; sweepgen=&#34;</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
				<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;non in-use span in unswept list&#34;</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c1">// 增加span的sweepgen，如果增加失败，表示有其他M已经操作了，直接退出
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 清扫sapn
</span><span class="c1"></span>	<span class="nx">npages</span> <span class="o">:=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">npages</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Whole span was freed. Count it toward the
</span><span class="c1"></span>			<span class="c1">// page reclaimer credit since these pages can
</span><span class="c1"></span>			<span class="c1">// now be used for span allocation.
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimCredit</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// Span is still in-use, so this returned no
</span><span class="c1"></span>			<span class="c1">// pages to the heap and the span needs to
</span><span class="c1"></span>			<span class="c1">// move to the swept in-use list.
</span><span class="c1"></span>			<span class="nx">npages</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 更新sweepers
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcpacertrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;pacer: sweep done at heap size &#34;</span><span class="p">,</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;MB; allocated &#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="o">-</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepHeapLiveBasis</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">,</span> <span class="s">&#34;MB during sweep; swept &#34;</span><span class="p">,</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSwept</span><span class="p">,</span> <span class="s">&#34; pages at &#34;</span><span class="p">,</span> <span class="nx">sweepRatio</span><span class="p">,</span> <span class="s">&#34; pages/byte\n&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="k">return</span> <span class="nx">npages</span>
<span class="p">}</span>
</code></pre></div><h4 id="sweep">sweep</h4>
<p>清扫单个span</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="nf">sweep</span><span class="p">(</span><span class="nx">preserve</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// It&#39;s critical that we enter this function with preemption disabled,
</span><span class="c1"></span>	<span class="c1">// GC must not start while we are in the middle of this function.
</span><span class="c1"></span>	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mspan.sweep: m is not locked&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">sweepgen</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanInUse</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">!=</span> <span class="nx">sweepgen</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;mspan.sweep: state=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="s">&#34; sweepgen=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34; mheap.sweepgen=&#34;</span><span class="p">,</span> <span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mspan.sweep: bad span state&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGCSweepSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span> <span class="o">*</span> <span class="nx">_PageSize</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 计数++
</span><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSwept</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">))</span>

	<span class="nx">spc</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="kc">false</span>

	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span>
	<span class="nx">freeToHeap</span> <span class="o">:=</span> <span class="kc">false</span>

	<span class="c1">// The allocBits indicate which unmarked objects don&#39;t need to be
</span><span class="c1"></span>	<span class="c1">// processed since they were free at the end of the last GC cycle
</span><span class="c1"></span>	<span class="c1">// and were not allocated since then.
</span><span class="c1"></span>	<span class="c1">// If the allocBits index is &gt;= s.freeindex and the bit
</span><span class="c1"></span>	<span class="c1">// is not marked then the object remains unallocated
</span><span class="c1"></span>	<span class="c1">// since the last GC.
</span><span class="c1"></span>	<span class="c1">// This situation is analogous to being on a freelist.
</span><span class="c1"></span>
	<span class="c1">// Unlink &amp; free special records for any objects we&#39;re about to free.
</span><span class="c1"></span>	<span class="c1">// Two complications here:
</span><span class="c1"></span>	<span class="c1">// 1. An object can have both finalizer and profile special records.
</span><span class="c1"></span>	<span class="c1">//    In such case we need to queue finalizer for execution,
</span><span class="c1"></span>	<span class="c1">//    mark the object as live and preserve the profile special.
</span><span class="c1"></span>	<span class="c1">// 2. A tiny object can have several finalizers setup for different offsets.
</span><span class="c1"></span>	<span class="c1">//    If such object is not marked, we need to queue all finalizers at once.
</span><span class="c1"></span>	<span class="c1">// Both 1 and 2 are possible at the same time.
</span><span class="c1"></span>	<span class="nx">specialp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">specials</span>
	<span class="nx">special</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">specialp</span>
	<span class="k">for</span> <span class="nx">special</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// A finalizer can be set for an inner byte of an object, find object beginning.
</span><span class="c1"></span>		<span class="nx">objIndex</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">special</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">/</span> <span class="nx">size</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">objIndex</span><span class="o">*</span><span class="nx">size</span>
		<span class="nx">mbits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">markBitsForIndex</span><span class="p">(</span><span class="nx">objIndex</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// This object is not marked and has at least one special record.
</span><span class="c1"></span>			<span class="c1">// Pass 1: see if it has at least one finalizer.
</span><span class="c1"></span>			<span class="nx">hasFin</span> <span class="o">:=</span> <span class="kc">false</span>
			<span class="nx">endOffset</span> <span class="o">:=</span> <span class="nx">p</span> <span class="o">-</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">size</span>
			<span class="k">for</span> <span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">special</span><span class="p">;</span> <span class="nx">tmp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">tmp</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">endOffset</span><span class="p">;</span> <span class="nx">tmp</span> <span class="p">=</span> <span class="nx">tmp</span><span class="p">.</span><span class="nx">next</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">tmp</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">_KindSpecialFinalizer</span> <span class="p">{</span>
					<span class="c1">// Stop freeing of object if it has a finalizer.
</span><span class="c1"></span>					<span class="nx">mbits</span><span class="p">.</span><span class="nf">setMarkedNonAtomic</span><span class="p">()</span>
					<span class="nx">hasFin</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="c1">// Pass 2: queue all finalizers _or_ handle profile record.
</span><span class="c1"></span>			<span class="k">for</span> <span class="nx">special</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">special</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">endOffset</span> <span class="p">{</span>
				<span class="c1">// Find the exact byte for which the special was setup
</span><span class="c1"></span>				<span class="c1">// (as opposed to object beginning).
</span><span class="c1"></span>				<span class="nx">p</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">special</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">special</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">_KindSpecialFinalizer</span> <span class="o">||</span> <span class="p">!</span><span class="nx">hasFin</span> <span class="p">{</span>
					<span class="c1">// Splice out special record.
</span><span class="c1"></span>					<span class="nx">y</span> <span class="o">:=</span> <span class="nx">special</span>
					<span class="nx">special</span> <span class="p">=</span> <span class="nx">special</span><span class="p">.</span><span class="nx">next</span>
					<span class="o">*</span><span class="nx">specialp</span> <span class="p">=</span> <span class="nx">special</span>
					<span class="nf">freespecial</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="c1">// This is profile record, but the object has finalizers (so kept alive).
</span><span class="c1"></span>					<span class="c1">// Keep special record.
</span><span class="c1"></span>					<span class="nx">specialp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">special</span><span class="p">.</span><span class="nx">next</span>
					<span class="nx">special</span> <span class="p">=</span> <span class="o">*</span><span class="nx">specialp</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// object is still live: keep special record
</span><span class="c1"></span>			<span class="nx">specialp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">special</span><span class="p">.</span><span class="nx">next</span>
			<span class="nx">special</span> <span class="p">=</span> <span class="o">*</span><span class="nx">specialp</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">allocfreetrace</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">clobberfree</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">raceenabled</span> <span class="o">||</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="c1">// Find all newly freed objects. This doesn&#39;t have to
</span><span class="c1"></span>		<span class="c1">// efficient; allocfreetrace has massive overhead.
</span><span class="c1"></span>		<span class="nx">mbits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">markBitsForBase</span><span class="p">()</span>
		<span class="nx">abits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">allocBitsForIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">abits</span><span class="p">.</span><span class="nx">index</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="o">||</span> <span class="nx">abits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">())</span> <span class="p">{</span>
				<span class="nx">x</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">i</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
				<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">allocfreetrace</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nf">tracefree</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">clobberfree</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nf">clobberfree</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
					<span class="nf">racefree</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
					<span class="nf">msanfree</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">mbits</span><span class="p">.</span><span class="nf">advance</span><span class="p">()</span>
			<span class="nx">abits</span><span class="p">.</span><span class="nf">advance</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 计算这个span上要释放的对象数量
</span><span class="c1"></span>	<span class="nx">nalloc</span> <span class="o">:=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">countAlloc</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nalloc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 如果span sizeclass=0，代表大对象，需要释放到heap
</span><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">1</span>
		<span class="nx">freeToHeap</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nx">nfreed</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="o">-</span> <span class="nx">nalloc</span>
	<span class="k">if</span> <span class="nx">nalloc</span> <span class="p">&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;runtime: nelems=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">,</span> <span class="s">&#34; nalloc=&#34;</span><span class="p">,</span> <span class="nx">nalloc</span><span class="p">,</span> <span class="s">&#34; previous allocCount=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="p">,</span> <span class="s">&#34; nfreed=&#34;</span><span class="p">,</span> <span class="nx">nfreed</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;sweep increased allocation count&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="nx">nalloc</span>
	<span class="nx">wasempty</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">nextFreeIndex</span><span class="p">()</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span>
	<span class="c1">// 重置freeindex
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// reset allocation index to start of span.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">traceReclaimed</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">nfreed</span><span class="p">)</span> <span class="o">*</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
	<span class="p">}</span>

	<span class="c1">// 将gcmarkBits变为allocBits
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">allocBits</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ggcmarkBitscmarkBits</span>
	<span class="c1">// 重新分配
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nx">gcmarkBits</span> <span class="p">=</span> <span class="nf">newMarkBits</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>

	<span class="c1">// 初始化allocBits
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="c1">// 如果需要释放到heap或者span无存活对象则更新sweepgen
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">freeToHeap</span> <span class="o">||</span> <span class="nx">nfreed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// The span must be in our exclusive ownership until we update sweepgen,
</span><span class="c1"></span>		<span class="c1">// check for potential races.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanInUse</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">!=</span> <span class="nx">sweepgen</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
			<span class="nb">print</span><span class="p">(</span><span class="s">&#34;mspan.sweep: state=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="s">&#34; sweepgen=&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34; mheap.sweepgen=&#34;</span><span class="p">,</span> <span class="nx">sweepgen</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mspan.sweep: bad span state after sweep&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// Serialization point.
</span><span class="c1"></span>		<span class="c1">// At this point the mark bits are cleared and allocation ready
</span><span class="c1"></span>		<span class="c1">// to go so release the span.
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sweepgen</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">nfreed</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 将span返回mcentral，res表示是否成功
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">local_nsmallfree</span><span class="p">[</span><span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()]</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">nfreed</span><span class="p">)</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">preserve</span><span class="p">,</span> <span class="nx">wasempty</span><span class="p">)</span>
		<span class="c1">// mcentral.freeSpan updates sweepgen
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">freeToHeap</span> <span class="p">{</span>
		<span class="c1">// 释放大块span到heap
</span><span class="c1"></span>		<span class="c1">// Free large span to heap
</span><span class="c1"></span>
		<span class="c1">// NOTE(rsc,dvyukov): The original implementation of efence
</span><span class="c1"></span>		<span class="c1">// in CL 22060046 used sysFree instead of sysFault, so that
</span><span class="c1"></span>		<span class="c1">// the operating system would eventually give the memory
</span><span class="c1"></span>		<span class="c1">// back to us again, so that an efence program could run
</span><span class="c1"></span>		<span class="c1">// longer without running out of memory. Unfortunately,
</span><span class="c1"></span>		<span class="c1">// calling sysFree here without any kind of adjustment of the
</span><span class="c1"></span>		<span class="c1">// heap data structures means that when the memory does
</span><span class="c1"></span>		<span class="c1">// come back to us, we have the wrong metadata for it, either in
</span><span class="c1"></span>		<span class="c1">// the mspan structures or in the garbage collection bitmap.
</span><span class="c1"></span>		<span class="c1">// Using sysFault here means that the program will run out of
</span><span class="c1"></span>		<span class="c1">// memory fairly quickly in efence mode, but at least it won&#39;t
</span><span class="c1"></span>		<span class="c1">// have mysterious crashes due to confused memory reuse.
</span><span class="c1"></span>		<span class="c1">// It should be possible to switch back to sysFree if we also
</span><span class="c1"></span>		<span class="c1">// implement and then call some kind of mheap.deleteSpan.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">efence</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// prevent mlookup from finding this span
</span><span class="c1"></span>			<span class="nf">sysFault</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()),</span> <span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">mheap_</span><span class="p">.</span><span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_nlargefree</span><span class="o">++</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">local_largefree</span> <span class="o">+=</span> <span class="nx">size</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">res</span> <span class="p">{</span>
		<span class="c1">// The span has been swept and is still in-use, so put
</span><span class="c1"></span>		<span class="c1">// it on the swept in-use list.
</span><span class="c1"></span>		<span class="c1">// span已经清扫过但是还是使用则放到swept in-use队列
</span><span class="c1"></span>		<span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="nx">sweepgen</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></div><h3 id="参考">参考</h3>
<p><a href="https://www.cnblogs.com/zkweb/p/7880099.html">https://www.cnblogs.com/zkweb/p/7880099.html</a></p>
]]></content>
		</item>
		
		<item>
			<title>Go-深入理解Defer</title>
			<link>https://leonzyang.github.io/posts/defer/</link>
			<pubDate>Sun, 27 Jun 2021 09:20:26 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/defer/</guid>
			<description>深入理解Defer defer defer函数的参数在声明之前，其实已经确定了值
defer 结构体 type _defer struct { siz int32 // 参数的大小 	started bool // 是否执行过了 	sp uintptr // 函数栈指针 	pc uintptr fn *funcval _panic *_panic // defer中的panic 	link *_defer // 通过链表的形势存储_defer 	} deferproc func deferproc(siz int32, fn *funcval) { // arguments of fn follow fn 	if getg().m.curg != getg() { // go code on the system stack can&amp;#39;t defer 	throw(&amp;#34;defer on system stack&amp;#34;) } sp := getcallersp() argp := uintptr(unsafe.</description>
			<content type="html"><![CDATA[<h2 id="深入理解defer">深入理解Defer</h2>
<h3 id="defer">defer</h3>
<p>defer函数的参数在声明之前，其实已经确定了值</p>
<h3 id="defer--结构体">defer  结构体</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="kd">type</span> <span class="nx">_defer</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">siz</span>     <span class="kt">int32</span>   <span class="c1">// 参数的大小
</span><span class="c1"></span>		<span class="nx">started</span> <span class="kt">bool</span>    <span class="c1">// 是否执行过了
</span><span class="c1"></span>		<span class="nx">sp</span>      <span class="kt">uintptr</span> <span class="c1">// 函数栈指针
</span><span class="c1"></span>		<span class="nx">pc</span>      <span class="kt">uintptr</span> 
		<span class="nx">fn</span>      <span class="o">*</span><span class="nx">funcval</span> 
		<span class="nx">_panic</span>  <span class="o">*</span><span class="nx">_panic</span> <span class="c1">// defer中的panic
</span><span class="c1"></span>		<span class="nx">link</span>    <span class="o">*</span><span class="nx">_defer</span> <span class="c1">// 通过链表的形势存储_defer
</span><span class="c1"></span>	<span class="p">}</span>
</code></pre></div><h3 id="deferproc">deferproc</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">deferproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// arguments of fn follow fn
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="nf">getg</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// go code on the system stack can&#39;t defer
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;defer on system stack&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="nx">argp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
	<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
	<span class="c1">// 新建一个defer
</span><span class="c1"></span>	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">newdefer</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;deferproc: d.panic != nil after newdefer&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 设置defer信息
</span><span class="c1"></span>	<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="nx">fn</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nx">callerpc</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="k">switch</span> <span class="nx">siz</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// Do nothing.
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
		<span class="c1">// 如果是指针，_defer后面内存存储参数地址信息
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// 如果不是指针类型，把参数拷贝到_defer后面
</span><span class="c1"></span>		<span class="nf">memmove</span><span class="p">(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// deferproc returns 0 normally.
</span><span class="c1"></span>	<span class="c1">// a deferred func that stops a panic
</span><span class="c1"></span>	<span class="c1">// makes the deferproc return 1.
</span><span class="c1"></span>	<span class="c1">// the code the compiler generates always
</span><span class="c1"></span>	<span class="c1">// checks the return value and jumps to the
</span><span class="c1"></span>	<span class="c1">// end of the function if deferproc returns != 0.
</span><span class="c1"></span>	<span class="nf">return0</span><span class="p">()</span>
	<span class="c1">// No code can go here - the C return register has
</span><span class="c1"></span>	<span class="c1">// been set and must not be clobbered.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="newdefer">newdefer</h3>
<p>newdefer 是获取一个_defer对象，并把它加入到链表头部</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newdefer</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">_defer</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">_defer</span>
	<span class="c1">// 根据size通过deferclass得出应该分配的sizeclass，系统会预先分配好一些sizeclass，然后根据对应的sz，去直接读取缓存
</span><span class="c1"></span>	<span class="nx">sc</span> <span class="o">:=</span> <span class="nf">deferclass</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">))</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 在当前p的范围内，去p上找
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sc</span> <span class="p">&lt;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">{}.</span><span class="nx">deferpool</span><span class="p">))</span> <span class="p">{</span>
		<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 当前p上对应sc的缓存为0，则从sched上获取一批
</span><span class="c1"></span>			<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
				<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="p">&lt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">d</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span>
					<span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
					<span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="kc">nil</span>
					<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">],</span> <span class="nx">d</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
			<span class="p">})</span>
		<span class="p">}</span>
		<span class="c1">// 从sched获取到了，并且不为空，则分配
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]);</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">d</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][:</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 如果还没找到，则直接分配
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">total</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nf">totaldefersize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)))</span>
			<span class="nx">d</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">_defer</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">total</span><span class="p">,</span> <span class="nx">deferType</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="p">})</span>
		<span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
			<span class="c1">// Duplicate the tail below so if there&#39;s a
</span><span class="c1"></span>			<span class="c1">// crash in checkPut we can tell if d was just
</span><span class="c1"></span>			<span class="c1">// allocated or came from the pool.
</span><span class="c1"></span>			<span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">=</span> <span class="nx">siz</span>
			<span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span>
			<span class="k">return</span> <span class="nx">d</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">=</span> <span class="nx">siz</span>
	<span class="c1">// 插入链表头部
</span><span class="c1"></span>	<span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span>
	<span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>
</code></pre></div><h3 id="deferreturn">deferreturn</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">deferreturn</span><span class="p">(</span><span class="nx">arg0</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 获取最后一个声明的defer
</span><span class="c1"></span>	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="o">!=</span> <span class="nx">sp</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// Moving arguments around.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Everything called after this point must be recursively
</span><span class="c1"></span>	<span class="c1">// nosplit because the garbage collector won&#39;t know the form
</span><span class="c1"></span>	<span class="c1">// of the arguments until the jmpdefer can flip the PC over to
</span><span class="c1"></span>	<span class="c1">// fn.
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// Do nothing.
</span><span class="c1"></span>	<span class="k">case</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">))</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">),</span> <span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">fn</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="c1">// defer用完了就盛放
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
	<span class="c1">// 释放defer
</span><span class="c1"></span>	<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="c1">// 跳转执行其他defer
</span><span class="c1"></span>	<span class="nf">jmpdefer</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div><h3 id="freedefer">freedefer</h3>
<p>释放defer</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">_defer</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">freedeferpanic</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">freedeferfn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 判断sizeclass
</span><span class="c1"></span>	<span class="nx">sc</span> <span class="o">:=</span> <span class="nf">deferclass</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">))</span>
	<span class="c1">// 超过当前deferpool的范围，则直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sc</span> <span class="o">&gt;=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">{}.</span><span class="nx">deferpool</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">pp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="c1">// 本地容量已经满了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="o">==</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="p">{</span>
		<span class="c1">// 转移一半到sched
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">first</span><span class="p">,</span> <span class="nx">last</span> <span class="o">*</span><span class="nx">_defer</span>
			<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
				<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span>
				<span class="nx">d</span> <span class="o">:=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
				<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][:</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="k">if</span> <span class="nx">first</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">first</span> <span class="p">=</span> <span class="nx">d</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nx">last</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">d</span>
				<span class="p">}</span>
				<span class="nx">last</span> <span class="p">=</span> <span class="nx">d</span>
			<span class="p">}</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
			<span class="nx">last</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">first</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">deferlock</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="c1">// 清空defer数据
</span><span class="c1"></span>	<span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">started</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">],</span> <span class="nx">d</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="说明">说明</h3>
<p>从上面可以看出，defer函数的参数在defer语句的时候已经定义下来了，从下面几个例子我们着重说明</p>
<h4 id="example1">Example1</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">demo1</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  	<span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
  	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">x</span><span class="o">++</span> 
	<span class="p">}()</span>
	<span class="k">return</span> <span class="nx">x</span> 
<span class="p">}</span>
</code></pre></div><p>先看第一个例子，这个应该输出什么？ 答案是1，为什么会输出1，我们试着转换一下,是不是就很清晰了，最后返回的起始一个已经被赋值后的变量tmp，跟x就没关系了</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">demo1</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">x</span>
	<span class="nx">x</span><span class="o">++</span>
	<span class="k">return</span> <span class="nx">tmp</span>
<span class="p">}</span>
</code></pre></div><h4 id="example2">Example2</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">demo2</span><span class="p">()</span> <span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">x</span><span class="p">=</span><span class="mi">1</span>
  	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    	<span class="nx">x</span><span class="o">++</span>
	<span class="p">}()</span>
	<span class="k">return</span> 
<span class="p">}</span>
</code></pre></div><p>第二个例子输出什么呢？ 如果你能马上答出2，那么说明你已经完全理解第一个例子了，那么我们还是翻译一下, 如果这还不明白，请面壁思过下</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">demo2</span><span class="p">()</span> <span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">x</span><span class="p">=</span><span class="mi">1</span>
  	<span class="nx">x</span><span class="o">++</span>
	<span class="k">return</span> 
<span class="p">}</span>
</code></pre></div><h4 id="example3">Example3</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">demo3</span><span class="p">()</span> <span class="p">(</span><span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
  	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    	<span class="nx">x</span><span class="o">++</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="nx">x</span> 
<span class="p">}</span>
</code></pre></div><p>第三个例子呢， 输出是1，其实第三个和第一个是一种情况，只不过有一些误导性，再看下第一个例子就会明白了</p>
]]></content>
		</item>
		
		<item>
			<title>Go-深入理解interface</title>
			<link>https://leonzyang.github.io/posts/interface/</link>
			<pubDate>Sun, 27 Jun 2021 09:19:35 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/interface/</guid>
			<description>深入理解interface Interface（接口）是我非常喜欢的一个特性，你可以在代码中实现接口组合、鸭子类型和多态等特性。
数据结构 iface和eface是Go里面描述接口的底层结构，iface表示有方法的接口，eface表示不包含方法的接口
type iface struct { tab *itab data unsafe.Pointer // 保存数据 } type eface struct { _type *_type data unsafe.Pointer } 接下来我们一个一个看
itab type itab struct { inter *interfacetype // 接口的类型 	_type *_type hash uint32 // copy of _type.hash. Used for type switches.  _ [4]byte // 放置和接口方法对应的具体数据类型和方法地址 	fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter. } type interfacetype struct { typ _type pkgpath name // package import名 	mhdr []imethod // 接口所定义的函数列表 } _type type _type struct { size uintptr // 类型大小 	ptrdata uintptr // size of memory prefix holding all pointers 	hash uint32 // 类型hash值 	tflag tflag // 类型tags 	align uint8 // 内存对齐 	fieldalign uint8 // 字段对齐 	kind uint8 // 类型 	alg *typeAlg // gcdata stores the GC type data for the garbage collector.</description>
			<content type="html"><![CDATA[<h2 id="深入理解interface">深入理解interface</h2>
<p>Interface（接口）是我非常喜欢的一个特性，你可以在代码中实现接口组合、鸭子类型和多态等特性。</p>
<h3 id="数据结构">数据结构</h3>
<p><code>iface</code>和<code>eface</code>是Go里面描述接口的底层结构，<code>iface</code>表示有方法的接口，<code>eface</code>表示不包含方法的接口</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">iface</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">tab</span>  <span class="o">*</span><span class="nx">itab</span>
	<span class="nx">data</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>  <span class="c1">// 保存数据
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">eface</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">_type</span> <span class="o">*</span><span class="nx">_type</span>
	<span class="nx">data</span>  <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
<span class="p">}</span>
</code></pre></div><p>接下来我们一个一个看</p>
<h4 id="itab">itab</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">itab</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">inter</span> <span class="o">*</span><span class="nx">interfacetype</span>    <span class="c1">// 接口的类型
</span><span class="c1"></span>	<span class="nx">_type</span> <span class="o">*</span><span class="nx">_type</span>
	<span class="nx">hash</span>  <span class="kt">uint32</span> <span class="c1">// copy of _type.hash. Used for type switches.
</span><span class="c1"></span>    <span class="nx">_</span>     <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span>
    <span class="c1">// 放置和接口方法对应的具体数据类型和方法地址
</span><span class="c1"></span>	<span class="nx">fun</span>   <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c1">// variable sized. fun[0]==0 means _type does not implement inter.
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">interfacetype</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">typ</span>     <span class="nx">_type</span>   
	<span class="nx">pkgpath</span> <span class="nx">name</span>   <span class="c1">// package import名
</span><span class="c1"></span>	<span class="nx">mhdr</span>    <span class="p">[]</span><span class="nx">imethod</span>  <span class="c1">// 接口所定义的函数列表
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h4 id="_type">_type</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">_type</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">size</span>       <span class="kt">uintptr</span> <span class="c1">// 类型大小
</span><span class="c1"></span>	<span class="nx">ptrdata</span>    <span class="kt">uintptr</span> <span class="c1">// size of memory prefix holding all pointers
</span><span class="c1"></span>	<span class="nx">hash</span>       <span class="kt">uint32</span>  <span class="c1">// 类型hash值
</span><span class="c1"></span>	<span class="nx">tflag</span>      <span class="nx">tflag</span>   <span class="c1">// 类型tags
</span><span class="c1"></span>	<span class="nx">align</span>      <span class="kt">uint8</span>   <span class="c1">// 内存对齐
</span><span class="c1"></span>	<span class="nx">fieldalign</span> <span class="kt">uint8</span>   <span class="c1">// 字段对齐
</span><span class="c1"></span>	<span class="nx">kind</span>       <span class="kt">uint8</span>  <span class="c1">// 类型
</span><span class="c1"></span>	<span class="nx">alg</span>        <span class="o">*</span><span class="nx">typeAlg</span>
	<span class="c1">// gcdata stores the GC type data for the garbage collector.
</span><span class="c1"></span>	<span class="c1">// If the KindGCProg bit is set in kind, gcdata is a GC program.
</span><span class="c1"></span>	<span class="c1">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
</span><span class="c1"></span>	<span class="nx">gcdata</span>    <span class="o">*</span><span class="kt">byte</span>
	<span class="nx">str</span>       <span class="nx">nameOff</span>
	<span class="nx">ptrToThis</span> <span class="nx">typeOff</span>
<span class="p">}</span>
</code></pre></div><h4 id="data">data</h4>
<p>data里面存储数据，Golang里面参数传递是<code>值传递</code>，所以如果源类型是个值，那么interface会copy一份数据存储；如果源类型是个指针，那么interface会直接保存该指针，指向同一个变量</p>
<p>接下来我们看几个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="kd">var</span> <span class="nx">j</span> <span class="p">=</span> <span class="mi">45</span>
	<span class="kd">var</span> <span class="nx">i</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="nx">j</span>
	<span class="kd">var</span> <span class="nx">x</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">j</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">j</span><span class="p">)</span>   <span class="c1">// 0xc000016088
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">i</span><span class="p">)</span>   <span class="c1">// 0xc0000101e0
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>    <span class="c1">// 0xc000016088
</span><span class="c1"></span>
</code></pre></div><h3 id="接口转换">接口转换</h3>
<h4 id="convt2i">convT2I</h4>
<p>结构转接口</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">convT2I</span><span class="p">(</span><span class="nx">tab</span> <span class="o">*</span><span class="nx">itab</span><span class="p">,</span> <span class="nx">elem</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">i</span> <span class="nx">iface</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">tab</span><span class="p">.</span><span class="nx">_type</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">convT2I</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 从堆中分配内存
</span><span class="c1"></span>	<span class="nx">x</span> <span class="o">:=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">elem</span><span class="p">)</span>
	<span class="nx">i</span><span class="p">.</span><span class="nx">tab</span> <span class="p">=</span> <span class="nx">tab</span>
	<span class="nx">i</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nx">x</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><h4 id="convi2i">convI2I</h4>
<p>接口转接口</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">convI2I</span><span class="p">(</span><span class="nx">inter</span> <span class="o">*</span><span class="nx">interfacetype</span><span class="p">,</span> <span class="nx">i</span> <span class="nx">iface</span><span class="p">)</span> <span class="p">(</span><span class="nx">r</span> <span class="nx">iface</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tab</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">tab</span>
	<span class="k">if</span> <span class="nx">tab</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">tab</span><span class="p">.</span><span class="nx">inter</span> <span class="o">==</span> <span class="nx">inter</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">tab</span> <span class="p">=</span> <span class="nx">tab</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">data</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">tab</span> <span class="p">=</span> <span class="nf">getitab</span><span class="p">(</span><span class="nx">inter</span><span class="p">,</span> <span class="nx">tab</span><span class="p">.</span><span class="nx">_type</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">data</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><h4 id="getitab">getitab</h4>
<p>getitab缓存了itab，根据接口类型和实际数据类型</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getitab</span><span class="p">(</span><span class="nx">inter</span> <span class="o">*</span><span class="nx">interfacetype</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">canfail</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">itab</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">inter</span><span class="p">.</span><span class="nx">mhdr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;internal error - misuse of itab&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// easy case
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">tflag</span><span class="o">&amp;</span><span class="nx">tflagUncommon</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">canfail</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="nx">name</span> <span class="o">:=</span> <span class="nx">inter</span><span class="p">.</span><span class="nx">typ</span><span class="p">.</span><span class="nf">nameOff</span><span class="p">(</span><span class="nx">inter</span><span class="p">.</span><span class="nx">mhdr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">name</span><span class="p">)</span>
		<span class="nb">panic</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">TypeAssertionError</span><span class="p">{</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">typ</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">inter</span><span class="p">.</span><span class="nx">typ</span><span class="p">,</span> <span class="nx">name</span><span class="p">.</span><span class="nf">name</span><span class="p">()})</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">m</span> <span class="o">*</span><span class="nx">itab</span>

	<span class="c1">// 先从存在的table中寻找itab
</span><span class="c1"></span>	<span class="c1">// First, look in the existing table to see if we can find the itab we need.
</span><span class="c1"></span>	<span class="c1">// This is by far the most common case, so do it without locks.
</span><span class="c1"></span>	<span class="c1">// Use atomic to ensure we see any previous writes done by the thread
</span><span class="c1"></span>	<span class="c1">// that updates the itabTable field (with atomic.Storep in itabAdd).
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">itabTableType</span><span class="p">)(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Loadp</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">itabTable</span><span class="p">)))</span>
	<span class="k">if</span> <span class="nx">m</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nx">inter</span><span class="p">,</span> <span class="nx">typ</span><span class="p">);</span> <span class="nx">m</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="nx">finish</span>
	<span class="p">}</span>

	<span class="c1">// Not found.  Grab the lock and try again.
</span><span class="c1"></span>	<span class="c1">// 没找到，加锁再次找一下
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">itabLock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">m</span> <span class="p">=</span> <span class="nx">itabTable</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nx">inter</span><span class="p">,</span> <span class="nx">typ</span><span class="p">);</span> <span class="nx">m</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">itabLock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">finish</span>
	<span class="p">}</span>

	<span class="c1">// Entry doesn&#39;t exist yet. Make a new entry &amp; add it.
</span><span class="c1"></span>	<span class="c1">// 不存在，新建一个，然后加入到table中
</span><span class="c1"></span>	<span class="nx">m</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">itab</span><span class="p">)(</span><span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">itab</span><span class="p">{})</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">inter</span><span class="p">.</span><span class="nx">mhdr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">))</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">inter</span> <span class="p">=</span> <span class="nx">inter</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">_type</span> <span class="p">=</span> <span class="nx">typ</span>
	<span class="nx">m</span><span class="p">.</span><span class="nf">init</span><span class="p">()</span>
	<span class="nf">itabAdd</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">itabLock</span><span class="p">)</span>
<span class="nx">finish</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">fun</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">m</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">canfail</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// this can only happen if the conversion
</span><span class="c1"></span>	<span class="c1">// was already done once using the , ok form
</span><span class="c1"></span>	<span class="c1">// and we have a cached negative result.
</span><span class="c1"></span>	<span class="c1">// The cached result doesn&#39;t record which
</span><span class="c1"></span>	<span class="c1">// interface function was missing, so initialize
</span><span class="c1"></span>	<span class="c1">// the itab again to get the missing function name.
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">TypeAssertionError</span><span class="p">{</span><span class="nx">concrete</span><span class="p">:</span> <span class="nx">typ</span><span class="p">,</span> <span class="nx">asserted</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">inter</span><span class="p">.</span><span class="nx">typ</span><span class="p">,</span> <span class="nx">missingMethod</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nf">init</span><span class="p">()})</span>
<span class="p">}</span>
</code></pre></div><h4 id="find">find</h4>
<p>find</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// find finds the given interface/type pair in t.
</span><span class="c1">// Returns nil if the given interface/type pair isn&#39;t present.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">itabTableType</span><span class="p">)</span> <span class="nf">find</span><span class="p">(</span><span class="nx">inter</span> <span class="o">*</span><span class="nx">interfacetype</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">)</span> <span class="o">*</span><span class="nx">itab</span> <span class="p">{</span>
	<span class="c1">// Implemented using quadratic probing.
</span><span class="c1"></span>	<span class="c1">// Probe sequence is h(i) = h0 + i*(i+1)/2 mod 2^k.
</span><span class="c1"></span>	<span class="c1">// We&#39;re guaranteed to hit all table entries using this probe sequence.
</span><span class="c1"></span>	<span class="nx">mask</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">size</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nf">itabHashFunc</span><span class="p">(</span><span class="nx">inter</span><span class="p">,</span> <span class="nx">typ</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nx">mask</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="p">(</span><span class="o">**</span><span class="nx">itab</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">entries</span><span class="p">),</span> <span class="nx">h</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">))</span>
		<span class="c1">// Use atomic read here so if we see m != nil, we also see
</span><span class="c1"></span>		<span class="c1">// the initializations of the fields of m.
</span><span class="c1"></span>		<span class="c1">// m := *p
</span><span class="c1"></span>		<span class="nx">m</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">itab</span><span class="p">)(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Loadp</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">)))</span>
		<span class="k">if</span> <span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">inter</span> <span class="o">==</span> <span class="nx">inter</span> <span class="o">&amp;&amp;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">_type</span> <span class="o">==</span> <span class="nx">typ</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">m</span>
		<span class="p">}</span>
		<span class="nx">h</span> <span class="o">+=</span> <span class="nx">i</span>
		<span class="nx">h</span> <span class="o">&amp;=</span> <span class="nx">mask</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="itabadd">itabAdd</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">itabAdd</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">itab</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Bugs can lead to calling this while mallocing is set,
</span><span class="c1"></span>	<span class="c1">// typically because this is called while panicing.
</span><span class="c1"></span>	<span class="c1">// Crash reliably, rather than only when we need to grow
</span><span class="c1"></span>	<span class="c1">// the hash table.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;malloc deadlock&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">itabTable</span>
	<span class="c1">// 超过75%，需要扩容
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">count</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">size</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 75% load factor
</span><span class="c1"></span>		<span class="c1">// Grow hash table.
</span><span class="c1"></span>		<span class="c1">// t2 = new(itabTableType) + some additional entries
</span><span class="c1"></span>		<span class="c1">// We lie and tell malloc we want pointer-free memory because
</span><span class="c1"></span>		<span class="c1">// all the pointed-to values are not in the heap.
</span><span class="c1"></span>		<span class="c1">// 两倍扩容
</span><span class="c1"></span>		<span class="nx">t2</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">itabTableType</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">((</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="nx">t</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="nx">t2</span><span class="p">.</span><span class="nx">size</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="mi">2</span>

		<span class="c1">// Copy over entries.
</span><span class="c1"></span>		<span class="c1">// Note: while copying, other threads may look for an itab and
</span><span class="c1"></span>		<span class="c1">// fail to find it. That&#39;s ok, they will then try to get the itab lock
</span><span class="c1"></span>		<span class="c1">// and as a consequence wait until this copying is complete.
</span><span class="c1"></span>		<span class="nf">iterate_itabs</span><span class="p">(</span><span class="nx">t2</span><span class="p">.</span><span class="nx">add</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">t2</span><span class="p">.</span><span class="nx">count</span> <span class="o">!=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">count</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;mismatched count during itab table copy&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// Publish new hash table. Use an atomic write: see comment in getitab.
</span><span class="c1"></span>		<span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">itabTable</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">t2</span><span class="p">))</span>
		<span class="c1">// Adopt the new table as our own.
</span><span class="c1"></span>		<span class="nx">t</span> <span class="p">=</span> <span class="nx">itabTable</span>
		<span class="c1">// Note: the old table can be GC&#39;ed here.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">t</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="add">add</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">itabTableType</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">itab</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// See comment in find about the probe sequence.
</span><span class="c1"></span>	<span class="c1">// Insert new itab in the first empty spot in the probe sequence.
</span><span class="c1"></span>	<span class="nx">mask</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">size</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="c1">// 计算偏移量
</span><span class="c1"></span>	<span class="nx">h</span> <span class="o">:=</span> <span class="nf">itabHashFunc</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">inter</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">_type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nx">mask</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="p">(</span><span class="o">**</span><span class="nx">itab</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">.</span><span class="nx">entries</span><span class="p">),</span> <span class="nx">h</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">))</span>
		<span class="nx">m2</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">p</span>
		<span class="k">if</span> <span class="nx">m2</span> <span class="o">==</span> <span class="nx">m</span> <span class="p">{</span>
			<span class="c1">// A given itab may be used in more than one module
</span><span class="c1"></span>			<span class="c1">// and thanks to the way global symbol resolution works, the
</span><span class="c1"></span>			<span class="c1">// pointed-to itab may already have been inserted into the
</span><span class="c1"></span>			<span class="c1">// global &#39;hash&#39;.
</span><span class="c1"></span>			<span class="c1">// 已经存在过了，不用加了
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">m2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Use atomic write here so if a reader sees m, it also
</span><span class="c1"></span>			<span class="c1">// sees the correctly initialized fields of m.
</span><span class="c1"></span>			<span class="c1">// NoWB is ok because m is not in heap memory.
</span><span class="c1"></span>			<span class="c1">// *p = m
</span><span class="c1"></span>			<span class="c1">// 存储m，类似*p = m, 不用写屏障
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">StorepNoWB</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
			<span class="nx">t</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">h</span> <span class="o">+=</span> <span class="nx">i</span>
		<span class="nx">h</span> <span class="o">&amp;=</span> <span class="nx">mask</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="断言">断言</h3>
<p>接口可以通过断言来解析实际类型</p>
<p>我们可以用下面两种方式进行断言，如果类型不匹配，那么第一种painc，第二种不会panic，ok会返回false</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">x</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">int64</span><span class="p">)</span>
	<span class="nx">y</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">int64</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">assertI2I</span><span class="p">(</span><span class="nx">inter</span> <span class="o">*</span><span class="nx">interfacetype</span><span class="p">,</span> <span class="nx">i</span> <span class="nx">iface</span><span class="p">)</span> <span class="p">(</span><span class="nx">r</span> <span class="nx">iface</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tab</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">tab</span>
	<span class="k">if</span> <span class="nx">tab</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// explicit conversions require non-nil interface value.
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">TypeAssertionError</span><span class="p">{</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">inter</span><span class="p">.</span><span class="nx">typ</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">})</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">tab</span><span class="p">.</span><span class="nx">inter</span> <span class="o">==</span> <span class="nx">inter</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">tab</span> <span class="p">=</span> <span class="nx">tab</span>
		<span class="nx">r</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">data</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">tab</span> <span class="p">=</span> <span class="nf">getitab</span><span class="p">(</span><span class="nx">inter</span><span class="p">,</span> <span class="nx">tab</span><span class="p">.</span><span class="nx">_type</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">data</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">assertI2I2</span><span class="p">(</span><span class="nx">inter</span> <span class="o">*</span><span class="nx">interfacetype</span><span class="p">,</span> <span class="nx">i</span> <span class="nx">iface</span><span class="p">)</span> <span class="p">(</span><span class="nx">r</span> <span class="nx">iface</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tab</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">tab</span>
	<span class="k">if</span> <span class="nx">tab</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">tab</span><span class="p">.</span><span class="nx">inter</span> <span class="o">!=</span> <span class="nx">inter</span> <span class="p">{</span>
		<span class="nx">tab</span> <span class="p">=</span> <span class="nf">getitab</span><span class="p">(</span><span class="nx">inter</span><span class="p">,</span> <span class="nx">tab</span><span class="p">.</span><span class="nx">_type</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">tab</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">tab</span> <span class="p">=</span> <span class="nx">tab</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nx">i</span><span class="p">.</span><span class="nx">data</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>interface严格来说不算真正的duck typing，因为它要求输入的参数和返回的参数一致</p>
]]></content>
		</item>
		
		<item>
			<title>Go-深入理解IO</title>
			<link>https://leonzyang.github.io/posts/io/</link>
			<pubDate>Sun, 27 Jun 2021 09:19:27 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/io/</guid>
			<description>深入理解IO 接口 Reader type Reader interface { Read(p []byte) (n int, err error) } Read读取len(p)个字节到p中，返回的读取到字节的数量(0&amp;lt;=n&amp;lt;=len(p))和发生的错误。 及时Read返回的n &amp;lt; len(p), 它也会在调用过程中暂用len(p)个字节做为暂存空间。如果读取到的数据小于len(p)个字节，Read会返回可用的数据，而不是等待更多数据。 当Read在成功读取n&amp;gt;0个字节后遇到一个错误或者EOF，它会返回读取到的字节数。它可能会同时在本次调用中返回一个non-nil的错误或是在下一次调用中返回这个错误(且n=0)。一般情况下，Reader读取到结尾会返回一个非0的字节数量，可能err返回EOF或者nil，并且之后的Read会返回(n=0, err=EOF)
调用方应该在处理错误前处理n&amp;gt;0的字节数据，这样做可以正确处理在读取字节后产生的IO错误，同时也允许EOF的出现
实现Read应该避免返回n=0和err=nil，除非len(p)=0, 同时返回n=0和err=nil，将表示什么都没有发生。
Writer type Writer interface { Write(p []byte) (n int, err error) } Writer实现了write方法，write写入len(p)个字节， 返回的字节0&amp;lt;=n&amp;lt;=len(p)和导致写入失败的错误。 Write如果返回的n小于len(p)，必须返回个non-nil错误。Write不允许修改p，即便是暂时也不行。
实现io.Reader或是io.Writer接口的类型  os.File 同时实现了 io.Reader 和 io.Writer strings.Reader 实现了 io.Reader bufio.Reader/Writer 分别实现了 io.Reader 和 io.Writer bytes.Buffer 同时实现了 io.Reader 和 io.Writer bytes.Reader 实现了 io.Reader compress/gzip.Reader/Writer 分别实现了 io.Reader 和 io.Writer crypto/cipher.StreamReader/StreamWriter 分别实现了 io.Reader 和 io.</description>
			<content type="html"><![CDATA[<h2 id="深入理解io">深入理解IO</h2>
<h3 id="接口">接口</h3>
<h4 id="reader">Reader</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Read读取len(p)个字节到p中，返回的读取到字节的数量(0&lt;=n&lt;=len(p))和发生的错误。
及时Read返回的n &lt; len(p), 它也会在调用过程中暂用len(p)个字节做为暂存空间。如果读取到的数据小于len(p)个字节，Read会返回可用的数据，而不是等待更多数据。
当Read在成功读取n&gt;0个字节后遇到一个错误或者EOF，它会返回读取到的字节数。它可能会同时在本次调用中返回一个non-nil的错误或是在下一次调用中返回这个错误(且n=0)。一般情况下，Reader读取到结尾会返回一个非0的字节数量，可能err返回EOF或者nil，并且之后的Read会返回(n=0, err=EOF)</p>
<p>调用方应该在处理错误前处理n&gt;0的字节数据，这样做可以正确处理在读取字节后产生的IO错误，同时也允许EOF的出现</p>
<p>实现Read应该避免返回n=0和err=nil，除非len(p)=0, 同时返回n=0和err=nil，将表示什么都没有发生。</p>
<h4 id="writer">Writer</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Writer实现了write方法，write写入len(p)个字节， 返回的字节0&lt;=n&lt;=len(p)和导致写入失败的错误。
Write如果返回的n小于len(p)，必须返回个non-nil错误。Write不允许修改p，即便是暂时也不行。</p>
<h4 id="实现ioreader或是iowriter接口的类型">实现io.Reader或是io.Writer接口的类型</h4>
<ul>
<li><code>os.File</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>strings.Reader</code> 实现了 <code>io.Reader</code></li>
<li><code>bufio.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>bytes.Buffer</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>bytes.Reader</code> 实现了 <code>io.Reader</code></li>
<li><code>compress/gzip.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>crypto/cipher.StreamReader/StreamWriter</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>crypto/tls.Conn</code> 同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>encoding/csv.Reader/Writer</code> 分别实现了 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>mime/multipart.Part</code> 实现了 <code>io.Reader</code></li>
<li><code>io.LimitedReader</code>、<code>io.PipeReader</code>、<code>io.SectionReader</code>实现了<code>io.Reader</code></li>
<li><code>io.PipeWriter</code>实现了<code>io.Writer</code></li>
</ul>
<p>大家可以看下我的另一篇文章<code>深入理解bufio</code></p>
<h4 id="readerat和writerat">ReaderAt和WriterAt</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ReaderAt</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">ReadAt</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">off</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>ReaderAt从输入源的偏移量off读取len(p)个字节，它会返回读取的字节(0&lt;=n&lt;=len(p))和任何遇到的错误。
如果ReadAt返回的n &lt; len(p)，它返回一个non-nil的错误来解释为什么没有返回更多的字节，这一点上，ReadAt比Read更严格。
及时ReadAt返回的n &lt; len(p)，它也会使用p做全部的暂存空间。若可读取的数据不到len(p)字节，ReadAt就会阻塞知道所有的数据都可用或一个错误发生，这点ReadAt不同于Read。
如果n == len(p) 个字节从输入源的结尾由ReadAt返回，Read可能返回err == EOF或者err == nil。
如果ReadAt读取一个带偏移量的输入源，ReadAt不应该影响它或者被它影响
可对相同的数据源执行并发调用</p>
<pre><code>type WriterAt interface {
	WriteAt(p []byte, off int64) (n int, err error)
}
</code></pre><p>WriteAt从p中将len(p)个字节写入到偏移量off的数据流中。它返回从p中被写入的字节数n(0 &lt;= n &lt;=len(p)) 以及任何遇到的引起写入停止的错误。若WriteAt返回的n &lt; len(p)，它就必须返回一个non-nil的错误
如果WriteAt写入一个带有偏移量的源，它不应该影响或者被它影响（和ReadAt一样）
WriteAt允许对于不同的区域进行并发写入</p>
<h4 id="copy">Copy</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Copy</span><span class="p">(</span><span class="nx">dst</span> <span class="nx">Writer</span><span class="p">,</span> <span class="nx">src</span> <span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">written</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">copyBuffer</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Copy拷贝从src到dst直到在src遇到EOF或者发生错误，它返回拷贝的字节数量和拷贝过程中发生的第一个错误。
一个成功的copy返回的err == nil,并不是err == EOF。因为copy的定义就是从src拷贝直到EOF，它不会将这个定义为错误。
如果src实现了WriterTo接口，那么copy就会调用src.WriteTo(dst)，否则如果dst实现了ReaderFrom接口，那么就会调用dst.ReadFrom(src)。</p>
<h5 id="copybuffer">copyBuffer</h5>
<p>如果buf == nil，那么就会分配一个</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">copyBuffer</span><span class="p">(</span><span class="nx">dst</span> <span class="nx">Writer</span><span class="p">,</span> <span class="nx">src</span> <span class="nx">Reader</span><span class="p">,</span> <span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">written</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// If the reader has a WriteTo method, use it to do the copy.
</span><span class="c1"></span>	<span class="c1">// Avoids an allocation and a copy.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">wt</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">src</span><span class="p">.(</span><span class="nx">WriterTo</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">wt</span><span class="p">.</span><span class="nf">WriteTo</span><span class="p">(</span><span class="nx">dst</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Similarly, if the writer has a ReadFrom method, use it to do the copy.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">rt</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">dst</span><span class="p">.(</span><span class="nx">ReaderFrom</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ReadFrom</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">buf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">size</span> <span class="o">:=</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span>
		<span class="c1">// 如果src是LimitedReader，则将buf的大小设置为LimitedReader.N
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">src</span><span class="p">.(</span><span class="o">*</span><span class="nx">LimitedReader</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">size</span> <span class="p">=</span> <span class="mi">1</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">size</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">N</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">nr</span><span class="p">,</span> <span class="nx">er</span> <span class="o">:=</span> <span class="nx">src</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">nr</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">nw</span><span class="p">,</span> <span class="nx">ew</span> <span class="o">:=</span> <span class="nx">dst</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">nr</span><span class="p">])</span>
			<span class="k">if</span> <span class="nx">nw</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">written</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">nw</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">ew</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">ew</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="c1">// 写入和读取的字节不一致
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">nr</span> <span class="o">!=</span> <span class="nx">nw</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">ErrShortWrite</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">er</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">er</span> <span class="o">!=</span> <span class="nx">EOF</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="nx">er</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">written</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><h5 id="limitreader">LimitReader</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// LimitReader returns a Reader that reads from r
</span><span class="c1">// but stops with EOF after n bytes.
</span><span class="c1">// The underlying implementation is a *LimitedReader.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">LimitReader</span><span class="p">(</span><span class="nx">r</span> <span class="nx">Reader</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">Reader</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="nx">LimitedReader</span><span class="p">{</span><span class="nx">r</span><span class="p">,</span> <span class="nx">n</span><span class="p">}</span> <span class="p">}</span>

<span class="c1">// A LimitedReader reads from R but limits the amount of
</span><span class="c1">// data returned to just N bytes. Each call to Read
</span><span class="c1">// updates N to reflect the new amount remaining.
</span><span class="c1">// Read returns EOF when N &lt;= 0 or when the underlying R returns EOF.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">LimitedReader</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">R</span> <span class="nx">Reader</span> <span class="c1">// underlying reader
</span><span class="c1"></span>	<span class="nx">N</span> <span class="kt">int64</span>  <span class="c1">// max bytes remaining
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LimitedReader</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">EOF</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">l</span><span class="p">.</span><span class="nx">N</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">R</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">N</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><h5 id="pipe">Pipe</h5>
<p>Pipe创建了一个同步的内存管道（没有内部缓冲），可以进行一对一、一对多、多对一，多对多的数据传输。 并发写和并发读是安全的。
除非有read，否则write是阻塞式的写入</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Pipe</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">PipeReader</span><span class="p">,</span> <span class="o">*</span><span class="nx">PipeWriter</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 都是无缓存的chan
</span><span class="c1"></span>	<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">pipe</span><span class="p">{</span>
		<span class="nx">wrCh</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">),</span>
		<span class="nx">rdCh</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">),</span>
		<span class="nx">done</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">PipeReader</span><span class="p">{</span><span class="nx">p</span><span class="p">},</span> <span class="o">&amp;</span><span class="nx">PipeWriter</span><span class="p">{</span><span class="nx">p</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>PipeReader和PipeWriter也是使用pipe结构进行交互</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PipeReader</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">*</span><span class="nx">pipe</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">PipeWriter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">*</span><span class="nx">pipe</span>
<span class="p">}</span>
</code></pre></div><h6 id="pipe-1">pipe</h6>
<p>pipe是PipeReader和PipeWriter共享管道结构</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">pipe</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">wrMu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// Serializes Write operations
</span><span class="c1"></span>	<span class="nx">wrCh</span> <span class="kd">chan</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nx">rdCh</span> <span class="kd">chan</span> <span class="kt">int</span>

	<span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span> <span class="c1">// Protects closing done
</span><span class="c1"></span>	<span class="nx">done</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
	<span class="nx">rerr</span> <span class="nx">atomicError</span>
	<span class="nx">werr</span> <span class="nx">atomicError</span>
<span class="p">}</span>
</code></pre></div><h5 id="read">Read</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">pipe</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">p</span><span class="p">.</span><span class="nx">done</span><span class="p">:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">readCloseError</span><span class="p">()</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>

	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">bw</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">p</span><span class="p">.</span><span class="nx">wrCh</span><span class="p">:</span>     <span class="c1">// 从wrCh中读取数据
</span><span class="c1"></span>		<span class="nx">nr</span> <span class="o">:=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">bw</span><span class="p">)</span>    <span class="c1">// 将读取的数据copy到b中
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nx">rdCh</span> <span class="o">&lt;-</span> <span class="nx">nr</span>         <span class="c1">// 将读取的字节数量写入到rdCh，这个在write里说下
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">nr</span><span class="p">,</span> <span class="kc">nil</span>       <span class="c1">// 返回读取到字节的数量和错误
</span><span class="c1"></span>	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">p</span><span class="p">.</span><span class="nx">done</span><span class="p">:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">readCloseError</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h5 id="write">Write</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">pipe</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">p</span><span class="p">.</span><span class="nx">done</span><span class="p">:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">writeCloseError</span><span class="p">()</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// 加锁，保证写入顺序
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nx">wrMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">defer</span> <span class="nx">p</span><span class="p">.</span><span class="nx">wrMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// once主要的作用是防止当len(b) == 0 ，不会进行此判断，这样就无法和Read沟通
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">once</span> <span class="o">:=</span> <span class="kc">true</span><span class="p">;</span> <span class="nx">once</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">once</span> <span class="p">=</span> <span class="kc">false</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">p</span><span class="p">.</span><span class="nx">wrCh</span> <span class="o">&lt;-</span> <span class="nx">b</span><span class="p">:</span>    <span class="c1">// 将数据写入到wrCh
</span><span class="c1"></span>			<span class="nx">nw</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">p</span><span class="p">.</span><span class="nx">rdCh</span>   <span class="c1">// 从rdCh同步上一次读取的数量（当Read一次没读取完，下次Read需要继续读取）
</span><span class="c1"></span>			<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">nw</span><span class="p">:]</span>       <span class="c1">// 修改b
</span><span class="c1"></span>			<span class="nx">n</span> <span class="o">+=</span> <span class="nx">nw</span>          <span class="c1">// 累加写入的字节数量
</span><span class="c1"></span>		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">p</span><span class="p">.</span><span class="nx">done</span><span class="p">:</span>
			<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">writeCloseError</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go-深入理解Slice</title>
			<link>https://leonzyang.github.io/posts/slice/</link>
			<pubDate>Sun, 27 Jun 2021 09:19:13 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/slice/</guid>
			<description>深入理解Slice Slice 就是我们常说的切片，Slice在内存中占用2个字节
###用法
func main(){ var ( a []int b [3]int // 数组，是单独一个类型  c = make([]int, 3) ) a = append(a, 1) b[0] = 1 // 元素直接填充0， 固定长度，append 会报错  c[0] = 1 // 元素填充0， 可以append，但是会在直接追加到队尾，可以使用make([]int, 0, 3)  fmt.Println(a, b, c) } 结构 type slice struct { array unsafe.Pointer // 指向所引用的数组 	len int // 当前切片的长度 	cap int // 当前切片的容量， cap &amp;gt;= len, 否则会报panic:&amp;#34;makeslice: cap out of range&amp;#34; } 理解Len和Cap 下面以几个例子说明下</description>
			<content type="html"><![CDATA[<h2 id="深入理解slice">深入理解Slice</h2>
<p>Slice 就是我们常说的切片，Slice在内存中占用2个字节</p>
<p>###用法</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="p">(</span>
        <span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span>
        <span class="nx">b</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span> <span class="c1">// 数组，是单独一个类型
</span><span class="c1"></span>        <span class="nx">c</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>   <span class="c1">// 元素直接填充0， 固定长度，append 会报错
</span><span class="c1"></span>    <span class="nx">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>   <span class="c1">// 元素填充0， 可以append，但是会在直接追加到队尾，可以使用make([]int, 0, 3)
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="结构">结构</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">slice</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">array</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 指向所引用的数组
</span><span class="c1"></span>	<span class="nx">len</span>   <span class="kt">int</span>         <span class="c1">// 当前切片的长度
</span><span class="c1"></span>	<span class="nx">cap</span>   <span class="kt">int</span>         <span class="c1">// 当前切片的容量， cap &gt;= len, 否则会报panic:&#34;makeslice: cap out of range&#34;
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="理解len和cap">理解Len和Cap</h3>
<p>下面以几个例子说明下</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="kd">var</span> <span class="p">(</span>
        <span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span>
        <span class="nx">b</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span> 
        <span class="nx">c</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>   <span class="c1">// 0, 0
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>   <span class="c1">// 3, 3
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>   <span class="c1">// 3, 3
</span><span class="c1"></span>
    <span class="c1">// 存储数据 
</span><span class="c1"></span>    <span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="nx">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>   <span class="c1">// 1, 1
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>   <span class="c1">// 3, 3
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>   <span class="c1">// 3, 3
</span><span class="c1"></span>
    <span class="c1">// 向c中append数据
</span><span class="c1"></span>    <span class="nx">c</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span>   <span class="c1">// 4, 6
</span><span class="c1"></span>

    <span class="c1">// 思考？
</span><span class="c1"></span>    <span class="c1">// var d = make([]int, 0, 3) len = ? and cap = ? 
</span></code></pre></div><p>从上面的例子，可以看出，b长度和容量是不可变的， c的长度和容量是相等的</p>
<h3 id="slice-扩容规则">slice 扩容规则</h3>
<p>TODO: 这里有改动
slice扩容有下面几个规则</p>
<ul>
<li>如果新的容量大于旧的Slice的长度2倍，则扩容为当前Slice的2倍</li>
<li>如果旧Slice的长度低于1024，则以两倍扩容，如果大于1024，则按旧Slice长度的1/4进行扩容</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span>
    <span class="nx">doublecap</span> <span class="o">:=</span> <span class="nx">newcap</span> <span class="o">+</span> <span class="nx">newcap</span>
    <span class="k">if</span> <span class="nx">cap</span> <span class="p">&gt;</span> <span class="nx">doublecap</span> <span class="p">{</span>
        <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">1024</span> <span class="p">{</span>
            <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">doublecap</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Check 0 &lt; newcap to detect overflow
</span><span class="c1"></span>            <span class="c1">// and prevent an infinite loop.
</span><span class="c1"></span>            <span class="k">for</span> <span class="mi">0</span> <span class="p">&lt;</span> <span class="nx">newcap</span> <span class="o">&amp;&amp;</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="nx">cap</span> <span class="p">{</span>
                <span class="nx">newcap</span> <span class="o">+=</span> <span class="nx">newcap</span> <span class="o">/</span> <span class="mi">4</span>
            <span class="p">}</span>
            <span class="c1">// Set newcap to the requested cap when
</span><span class="c1"></span>            <span class="c1">// the newcap calculation overflowed.
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">newcap</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div><h3 id="切片陷阱">切片陷阱</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">)))</span> <span class="c1">// 0xc00001c090
</span><span class="c1"></span>    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">)))</span> <span class="c1">// 0xc00001c098
</span><span class="c1"></span>    <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">11</span>  <span class="c1">// 此时由于还是引用同一地址，不仅b[0]是2， a[1] 同样也变成11
</span></code></pre></div><p>可以看到切片后的地址相差了8个字节，也就是一个int，还是引用相同的一块内存地址</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>

    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// 触发扩容，生成新的Slice
</span><span class="c1"></span>    <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">11</span>  <span class="c1">// 此时就只有b[0]变成了11， a[0]还是1
</span></code></pre></div><h3 id="slice-copy">Slice copy</h3>
<p>从源Slice将数据拷贝到目的Slice中，拷贝的Slice大小是dst的大小</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="kt">int</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">slicecopy</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">fm</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">width</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">fm</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">to</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>  <span class="c1">// 源和目的长度都为0 直接返回
</span><span class="c1"></span>		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">fm</span><span class="p">.</span><span class="nx">len</span>
	<span class="k">if</span> <span class="nx">to</span><span class="p">.</span><span class="nx">len</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>    <span class="c1">// 如果目的slice大小小于源silce的大小，按目的的大小算
</span><span class="c1"></span>		<span class="nx">n</span> <span class="p">=</span> <span class="nx">to</span><span class="p">.</span><span class="nx">len</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">n</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">slicecopy</span><span class="p">)</span>
		<span class="nf">racewriterangepc</span><span class="p">(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">width</span><span class="p">)),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
		<span class="nf">racereadrangepc</span><span class="p">(</span><span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">width</span><span class="p">)),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanwrite</span><span class="p">(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">width</span><span class="p">)))</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">width</span><span class="p">)))</span>
	<span class="p">}</span>

	<span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">*</span> <span class="nx">width</span>
    <span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span> <span class="c1">// common case worth about 2x to do here
</span><span class="c1"></span>        <span class="c1">// TODO: is this still worth it with new memmove impl?
</span><span class="c1"></span>        <span class="c1">// 只有1个元素，直接拷贝指针
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">)</span> <span class="c1">// known to be a byte pointer
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 从fm拷贝size个字节到to
</span><span class="c1"></span>		<span class="nf">memmove</span><span class="p">(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>

</code></pre></div><h3 id="小陷阱">小陷阱</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// [0, 0, 0, 1]
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// [1]  
</span></code></pre></div><p>make 第二个参数是len，第三个参数是cap，如果不传第三个参数，那么cap = len，所以就会有下面的输出</p>
<h3 id="其他">其他</h3>
<p>slice切片的时候，可以设定切片后的cap</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">    <span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint16</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
    <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">3</span>
    <span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="mi">4</span>
    <span class="nx">s</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="mi">5</span>

    <span class="c1">// 5 就是新切片的cap，不能大于原始切片的cap，否则会报panic: runtime error: slice bounds out of range
</span><span class="c1"></span>    <span class="nx">v</span><span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go-深入理解Goroutine</title>
			<link>https://leonzyang.github.io/posts/goroutine/</link>
			<pubDate>Sun, 27 Jun 2021 09:19:08 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/goroutine/</guid>
			<description>深入理解Goroutine CSP CSP模型的全称为Communicating Sequential Processes，是一个很强大的并发数据模型，是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。相对于Actor模型，CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。
理解并发不是并行 举个排队的例子，有两个队伍，但是只有1个窗口审核，是并发，如果有两个窗口则是并行，Golang里面就是并发
MGP
M指的是Machine，一个M关联了一个内核线程 P指的是Processor，代表了M的上下文环境 G指的是Goroutine 三者关系如下： P的数量可以由runtime.GOMAXPROCS()来指定，它代表了真正的并发能力
数据结构 注：下面的代码有些地方省略显示
G(goroutine) type g struct { // Stack parameters. 	// stack describes the actual stack memory: [stack.lo, stack.hi). 	// stackguard0 is the stack pointer compared in the Go stack growth prologue. 	// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. 	// stackguard1 is the stack pointer compared in the C stack growth prologue.</description>
			<content type="html"><![CDATA[<h2 id="深入理解goroutine">深入理解Goroutine</h2>
<h3 id="csp">CSP</h3>
<p>CSP模型的全称为Communicating Sequential Processes，是一个很强大的并发数据模型，是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。相对于Actor模型，CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。</p>
<h3 id="理解并发不是并行">理解并发不是并行</h3>
<p>举个排队的例子，有两个队伍，但是只有1个窗口审核，是并发，如果有两个窗口则是并行，Golang里面就是并发</p>
<p>MGP</p>
<p><code>M</code>指的是Machine，一个M关联了一个内核线程
<code>P</code>指的是Processor，代表了M的上下文环境
<code>G</code>指的是Goroutine
三者关系如下：
<img src="posts/images/go-scheduler-in-motion.jpg" alt="image">
P的数量可以由runtime.GOMAXPROCS()来指定，它代表了真正的并发能力</p>
<h3 id="数据结构">数据结构</h3>
<p>注：下面的代码有些地方省略显示</p>
<h4 id="ggoroutine">G(goroutine)</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Stack parameters.
</span><span class="c1"></span>	<span class="c1">// stack describes the actual stack memory: [stack.lo, stack.hi).
</span><span class="c1"></span>	<span class="c1">// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span><span class="c1"></span>	<span class="c1">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span><span class="c1"></span>	<span class="c1">// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span><span class="c1"></span>	<span class="c1">// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span><span class="c1"></span>    <span class="c1">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span><span class="c1"></span>    
	<span class="c1">// 当前g使用的栈空间，栈结构包含两个成员lo和hi
</span><span class="c1"></span>	<span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo
</span><span class="c1"></span>	<span class="c1">// 检测栈是否需要扩展，用Go实现
</span><span class="c1"></span>	<span class="nx">stackguard0</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>	<span class="c1">// 检测栈是否需要扩展，用C实现
</span><span class="c1"></span>	<span class="nx">stackguard1</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>	<span class="c1">// 最内层的Panic
</span><span class="c1"></span>	<span class="nx">_panic</span>         <span class="o">*</span><span class="nx">_panic</span> <span class="c1">// innermost panic - offset known to liblink
</span><span class="c1"></span>	<span class="c1">// 最内层的dfer
</span><span class="c1"></span>	<span class="nx">_defer</span>         <span class="o">*</span><span class="nx">_defer</span> <span class="c1">// innermost defer
</span><span class="c1"></span>	<span class="c1">// 当前所绑定的M
</span><span class="c1"></span>	<span class="nx">m</span>              <span class="o">*</span><span class="nx">m</span>      <span class="c1">// current m; offset known to arm liblink
</span><span class="c1"></span>	<span class="c1">// 当前g的调度数据，当goroutine切换时，保留当前g的上下文，用于恢复g
</span><span class="c1"></span>	<span class="nx">sched</span>          <span class="nx">gobuf</span>


	<span class="nx">syscallsp</span>      <span class="kt">uintptr</span>        <span class="c1">// if status==Gsyscall, syscallsp = sched.sp to use during gc
</span><span class="c1"></span>	<span class="nx">syscallpc</span>      <span class="kt">uintptr</span>        <span class="c1">// if status==Gsyscall, syscallpc = sched.pc to use during gc
</span><span class="c1"></span>	<span class="nx">stktopsp</span>       <span class="kt">uintptr</span>        <span class="c1">// expected sp at top of stack, to check in traceback
</span><span class="c1"></span>	<span class="nx">param</span>          <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 传递唤醒参数
</span><span class="c1"></span>
	<span class="c1">// 当前g的状态
</span><span class="c1"></span>	<span class="nx">atomicstatus</span>   <span class="kt">uint32</span>
	<span class="nx">stackLock</span>      <span class="kt">uint32</span> <span class="c1">// sigprof/scang lock; TODO: fold in to atomicstatus
</span><span class="c1"></span>	<span class="c1">// 当前g的id
</span><span class="c1"></span>	<span class="nx">goid</span>           <span class="kt">int64</span>
	<span class="c1">// 下一个g的地址，通过guintptr
</span><span class="c1"></span>	<span class="nx">schedlink</span>      <span class="nx">guintptr</span>
	<span class="nx">waitsince</span>      <span class="kt">int64</span>      <span class="c1">// 当前g阻塞的时间
</span><span class="c1"></span>	<span class="nx">waitreason</span>     <span class="nx">waitReason</span> <span class="c1">// 当前g被阻塞的原因，当前g处在Gwaiting
</span><span class="c1"></span>	<span class="c1">// 是否抢占
</span><span class="c1"></span>	<span class="nx">preempt</span>        <span class="kt">bool</span>       <span class="c1">// preemption signal, duplicates stackguard0 = stackpreempt
</span><span class="c1"></span>	<span class="nx">paniconfault</span>   <span class="kt">bool</span>       <span class="c1">// panic (instead of crash) on unexpected fault address
</span><span class="c1"></span>	<span class="nx">preemptscan</span>    <span class="kt">bool</span>       <span class="c1">// 被强占是否进行gc
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><p>G的状态</p>
<pre><code>_Gidle 表示Goroutine刚刚被分配，还未初始化
_Grunnable 表示Goroutine已经在运行队列中，但是还未运行代码，没有自己的堆栈
_Grunning 表示Goroutine可能在运行用户代码，已经拥有自己的堆栈，并且已经分配到M和P
_Gsyscall 表示Goroutine正在执行系统调用，分配有M
_Gwaiting 表示Goroutine被系统库Block
_Gmoribund_unused 没使用，但是在gdb脚本中硬编码
_Gdead 表示Goroutine不在使用，可能是刚退出、或者刚刚初始化，没有自己的堆栈
_Genqueue_unused 没有使用
_Gscan 表示Gc正在扫描
</code></pre><h4 id="pprocess">P(process)</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span> <span class="nx">mutex</span>

	<span class="nx">id</span>          <span class="kt">int32</span>
	<span class="nx">status</span>      <span class="kt">uint32</span> <span class="c1">// P的状态
</span><span class="c1"></span>	<span class="nx">link</span>        <span class="nx">puintptr</span>
	<span class="nx">schedtick</span>   <span class="kt">uint32</span>     <span class="c1">// 每次调度都增加
</span><span class="c1"></span>	<span class="nx">syscalltick</span> <span class="kt">uint32</span>     <span class="c1">// 每次系统调用时增加
</span><span class="c1"></span>	<span class="nx">sysmontick</span>  <span class="nx">sysmontick</span> <span class="c1">// last tick observed by sysmon
</span><span class="c1"></span>	<span class="nx">m</span>           <span class="nx">muintptr</span>   <span class="c1">// 反向连接当前m，如果空闲则为nil
</span><span class="c1"></span>	<span class="nx">mcache</span>      <span class="o">*</span><span class="nx">mcache</span>
	<span class="nx">racectx</span>     <span class="kt">uintptr</span>

	<span class="nx">deferpool</span>    <span class="p">[</span><span class="mi">5</span><span class="p">][]</span><span class="o">*</span><span class="nx">_defer</span> <span class="c1">// pool of available defer structs of different sizes (see panic.go)
</span><span class="c1"></span>	<span class="nx">deferpoolbuf</span> <span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>

	<span class="c1">// 缓存goroutine ids
</span><span class="c1"></span>	<span class="nx">goidcache</span>    <span class="kt">uint64</span>
	<span class="nx">goidcacheend</span> <span class="kt">uint64</span>

	<span class="c1">// Queue of runnable goroutines. Accessed without lock.
</span><span class="c1"></span>	<span class="nx">runqhead</span> <span class="kt">uint32</span>
	<span class="nx">runqtail</span> <span class="kt">uint32</span>
	<span class="c1">// 本地可运行的g，用数组实现
</span><span class="c1"></span>	<span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>
	<span class="c1">// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span><span class="c1"></span>	<span class="c1">// the current G and should be run next instead of what&#39;s in
</span><span class="c1"></span>	<span class="c1">// runq if there&#39;s time remaining in the running G&#39;s time
</span><span class="c1"></span>	<span class="c1">// slice. It will inherit the time left in the current time
</span><span class="c1"></span>	<span class="c1">// slice. If a set of goroutines is locked in a
</span><span class="c1"></span>	<span class="c1">// communicate-and-wait pattern, this schedules that set as a
</span><span class="c1"></span>	<span class="c1">// unit and eliminates the (potentially large) scheduling
</span><span class="c1"></span>	<span class="c1">// latency that otherwise arises from adding the ready&#39;d
</span><span class="c1"></span>	<span class="c1">// goroutines to the end of the run queue.
</span><span class="c1"></span>	<span class="c1">// 如果不为nil， 则存放待运行的g
</span><span class="c1"></span>	<span class="nx">runnext</span> <span class="nx">guintptr</span>

	<span class="c1">// Available G&#39;s (status == Gdead)
</span><span class="c1"></span>	<span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">gList</span>
		<span class="nx">n</span> <span class="kt">int32</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>P的状态</p>
<pre><code>_Pidle         空闲状态，未和M绑定
_Prunning      运行状态，已和M绑定，并且执行G
_Psyscall      系统调用，此时P中运行的G正在执行系统调用
_Pgcstop       runtime正在进行GC
_Pdead         此时P不在使用(调用runtime.GOMAXPROCS减少P的数量的时候，多余的P就会处于这个状态)
</code></pre><h4 id="mmachine">M(machine)</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">g0</span>      <span class="o">*</span><span class="nx">g</span>     <span class="c1">// 系统调度时候使用的g
</span><span class="c1"></span>	<span class="nx">gsignal</span>       <span class="o">*</span><span class="nx">g</span>           <span class="c1">// 处理信号的g
</span><span class="c1"></span>	<span class="nx">tls</span>           <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">uintptr</span>   <span class="c1">// thead-local storage
</span><span class="c1"></span>	<span class="nx">mstartfn</span>      <span class="kd">func</span><span class="p">()</span>
	<span class="nx">curg</span>          <span class="o">*</span><span class="nx">g</span>       <span class="c1">// 当前正在运行的Goroutine
</span><span class="c1"></span>	<span class="nx">caughtsig</span>     <span class="nx">guintptr</span> <span class="c1">// goroutine running during fatal signal
</span><span class="c1"></span>	<span class="nx">p</span>             <span class="nx">puintptr</span> <span class="c1">// 关联p和执行p代码（不执行时为nil）
</span><span class="c1"></span>	<span class="nx">nextp</span>         <span class="nx">puintptr</span> <span class="c1">// 唤醒m时， m就绑定这个p
</span><span class="c1"></span>	<span class="nx">oldp</span>          <span class="nx">puintptr</span> <span class="c1">// the p that was attached before executing a syscall
</span><span class="c1"></span>	<span class="nx">id</span>            <span class="kt">int64</span>
	<span class="nx">mallocing</span>     <span class="kt">int32</span>
	<span class="nx">throwing</span>      <span class="kt">int32</span>
	<span class="nx">preemptoff</span>    <span class="kt">string</span> <span class="c1">// if != &#34;&#34;, keep curg running on this m
</span><span class="c1"></span>	<span class="nx">locks</span>         <span class="kt">int32</span>
	<span class="nx">dying</span>         <span class="kt">int32</span>
	<span class="nx">profilehz</span>     <span class="kt">int32</span>
	<span class="nx">spinning</span>      <span class="kt">bool</span> <span class="c1">// m 是否是处在自旋状态，用于判断m是否空闲，如果空闲则寻找g
</span><span class="c1"></span>	<span class="nx">blocked</span>       <span class="kt">bool</span> <span class="c1">// m 是否阻塞
</span><span class="c1"></span>	<span class="nx">inwb</span>          <span class="kt">bool</span> <span class="c1">// m 是否在执行写屏障
</span><span class="c1"></span>	<span class="nx">newSigstack</span>   <span class="kt">bool</span> <span class="c1">// minit on C thread called sigaltstack
</span><span class="c1"></span>	<span class="nx">printlock</span>     <span class="kt">int8</span>
	<span class="nx">incgo</span>         <span class="kt">bool</span>   <span class="c1">// m 执行cgo调用
</span><span class="c1"></span>	<span class="nx">ncgocall</span>      <span class="kt">uint64</span>      <span class="c1">// cgo调用的数量
</span><span class="c1"></span>	<span class="nx">ncgo</span>          <span class="kt">int32</span>       <span class="c1">// 当前cgo正在调用的数量
</span><span class="c1"></span>	<span class="nx">alllink</span>       <span class="o">*</span><span class="nx">m</span> <span class="c1">// 链接m
</span><span class="c1"></span>	<span class="nx">schedlink</span>     <span class="nx">muintptr</span>
	<span class="nx">mcache</span>        <span class="o">*</span><span class="nx">mcache</span>
	<span class="nx">lockedg</span>       <span class="nx">guintptr</span>  <span class="c1">// 锁定g在当前m上
</span><span class="c1"></span>	<span class="nx">waittraceev</span>   <span class="kt">byte</span>
	<span class="nx">waittraceskip</span> <span class="kt">int</span>
	<span class="nx">startingtrace</span> <span class="kt">bool</span>
	<span class="nx">syscalltick</span>   <span class="kt">uint32</span>
	<span class="nx">thread</span>        <span class="kt">uintptr</span> <span class="c1">// thread handle
</span><span class="c1"></span>	<span class="nx">freelink</span>      <span class="o">*</span><span class="nx">m</span>      <span class="c1">// on sched.freem
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>M的状态</p>
<pre><code>spinning     自旋状态，此时M正在寻找P
执行go代码     M正在执行g的代码，此时拥有一个P
执行远程代码   此时M正在执行原生代码或者阻塞syscall，此时M不拥有P
休眠中        M发现没有待运行的g，则会加入到空闲列表，这时不拥有P
</code></pre><h4 id="schedt-调度">schedt 调度</h4>
<p>全局调度使用的数据结构，保存有M的idle队列，P的idle队列</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// 访问是原子性的
</span><span class="c1"></span>	<span class="nx">goidgen</span>  <span class="kt">uint64</span>
	<span class="nx">lastpoll</span> <span class="kt">uint64</span>

	<span class="nx">lock</span> <span class="nx">mutex</span>

	<span class="c1">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be
</span><span class="c1"></span>	<span class="c1">// sure to call checkdead().
</span><span class="c1"></span>
	<span class="nx">midle</span>        <span class="nx">muintptr</span> <span class="c1">// 空闲的M，用链表存储
</span><span class="c1"></span>	<span class="nx">nmidle</span>       <span class="kt">int32</span>    <span class="c1">// 空闲M的数量
</span><span class="c1"></span>	<span class="nx">nmidlelocked</span> <span class="kt">int32</span>    <span class="c1">// M被锁定并等待中的数量
</span><span class="c1"></span>	<span class="nx">mnext</span>        <span class="kt">int64</span>    <span class="c1">// 下一个M的id，用来记录创建的M的数量
</span><span class="c1"></span>	<span class="nx">maxmcount</span>    <span class="kt">int32</span>    <span class="c1">// 最多允许M的数量
</span><span class="c1"></span>	<span class="nx">nmsys</span>        <span class="kt">int32</span>    <span class="c1">// number of system m&#39;s not counted for deadlock
</span><span class="c1"></span>	<span class="nx">nmfreed</span>      <span class="kt">int64</span>    <span class="c1">// 释放m的数量
</span><span class="c1"></span>
	<span class="nx">ngsys</span> <span class="kt">uint32</span> <span class="c1">// Goroutine的数量
</span><span class="c1"></span>
	<span class="nx">pidle</span>      <span class="nx">puintptr</span> <span class="c1">// 空闲的P，用链表存储
</span><span class="c1"></span>	<span class="nx">npidle</span>     <span class="kt">uint32</span>
	<span class="nx">nmspinning</span> <span class="kt">uint32</span> <span class="c1">// See &#34;Worker thread parking/unparking&#34; comment in proc.go.
</span><span class="c1"></span>
	<span class="c1">// 全局队列， 当本地g过多或者过少时本地的队列会跟全局队列平衡
</span><span class="c1"></span>	<span class="nx">runq</span>     <span class="nx">gQueue</span>
	<span class="nx">runqsize</span> <span class="kt">int32</span>

	<span class="c1">// 存放释放掉的g，链表结构
</span><span class="c1"></span>	<span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">lock</span>    <span class="nx">mutex</span>
		<span class="nx">stack</span>   <span class="nx">gList</span> <span class="c1">// Gs with stacks
</span><span class="c1"></span>		<span class="nx">noStack</span> <span class="nx">gList</span> <span class="c1">// Gs without stacks
</span><span class="c1"></span>		<span class="nx">n</span>       <span class="kt">int32</span>
	<span class="p">}</span>


	<span class="c1">// freem is the list of m&#39;s waiting to be freed when their
</span><span class="c1"></span>	<span class="c1">// m.exited is set. Linked through m.freelink.
</span><span class="c1"></span>	<span class="c1">// 等待释放的m
</span><span class="c1"></span>	<span class="nx">freem</span> <span class="o">*</span><span class="nx">m</span>
<span class="p">}</span>
</code></pre></div><h3 id="创建goroutine">创建Goroutine</h3>
<h4 id="newproc">newproc</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 获取参数的地址
</span><span class="c1"></span>	<span class="nx">argp</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
	<span class="c1">// 获取当前执行的g
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 获取g的pc地址
</span><span class="c1"></span>	<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// 调用g0去执行newproc1
</span><span class="c1"></span>		<span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="kt">uint8</span><span class="p">)(</span><span class="nx">argp</span><span class="p">),</span> <span class="nx">siz</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><h4 id="newproc1">newproc1</h4>
<p>newproc1会创建或是获取一个空闲的g，并进行初始化，并尝试去寻找m和p去执行g</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">,</span> <span class="nx">argp</span> <span class="o">*</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">narg</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">callergp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">fn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">throwing</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// do not dump full stacks
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;go of nil func value&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span> <span class="c1">// 加锁禁止抢占
</span><span class="c1"></span>	<span class="nx">siz</span> <span class="o">:=</span> <span class="nx">narg</span>
	<span class="nx">siz</span> <span class="p">=</span> <span class="p">(</span><span class="nx">siz</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="mi">7</span>

	<span class="c1">// We could allocate a larger initial stack if necessary.
</span><span class="c1"></span>	<span class="c1">// Not worth it: this is almost always an error.
</span><span class="c1"></span>	<span class="c1">// 4*sizeof(uintreg): extra space added below
</span><span class="c1"></span>	<span class="c1">// sizeof(uintreg): caller&#39;s LR (arm) or return address (x86, in gostartcall).
</span><span class="c1"></span>	<span class="c1">//  如果参数太多，就会抛出异常，栈的大小是2k
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">siz</span> <span class="o">&gt;=</span> <span class="nx">_StackMin</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span><span class="o">-</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc: function arguments too large for new goroutine&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="c1">// 尝试获取一个空闲的g，如果获取不到，则新建一个，并且放到allgs里面
</span><span class="c1"></span>	<span class="c1">// gfget优先会尝试从绑定的p上获取g，如果获取不到，则会从全局中平衡一些到本地p
</span><span class="c1"></span>	<span class="nx">newg</span> <span class="o">:=</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">newg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">newg</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">_StackMin</span><span class="p">)</span>
		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gidle</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
		<span class="c1">// append到allgs
</span><span class="c1"></span>		<span class="nf">allgadd</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="c1">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc1: newg missing stack&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 判断g的状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">_Gdead</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc1: new g is not Gdead&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">totalSize</span> <span class="o">:=</span> <span class="mi">4</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span> <span class="c1">// extra space in case of reads slightly beyond frame
</span><span class="c1"></span>	<span class="c1">// 空间大小对齐
</span><span class="c1"></span>	<span class="nx">totalSize</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">totalSize</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">SpAlign</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>                  <span class="c1">// align to spAlign
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">totalSize</span>
	<span class="nx">spArg</span> <span class="o">:=</span> <span class="nx">sp</span>
	<span class="k">if</span> <span class="nx">usesLR</span> <span class="p">{</span>
		<span class="c1">// caller&#39;s LR
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">prepGoExitFrame</span><span class="p">(</span><span class="nx">sp</span><span class="p">)</span>
		<span class="nx">spArg</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">narg</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 将参数拷贝入栈
</span><span class="c1"></span>		<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">spArg</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">narg</span><span class="p">))</span>
		<span class="c1">// This is a stack-to-stack copy. If write barriers
</span><span class="c1"></span>		<span class="c1">// are enabled and the source stack is grey (the
</span><span class="c1"></span>		<span class="c1">// destination is always black), then perform a
</span><span class="c1"></span>		<span class="c1">// barrier copy. We do this *after* the memmove
</span><span class="c1"></span>		<span class="c1">// because the destination stack may have garbage on
</span><span class="c1"></span>		<span class="c1">// it.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">needed</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">{</span>
			<span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span><span class="p">)</span>
			<span class="nx">stkmap</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">stackmap</span><span class="p">)(</span><span class="nf">funcdata</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">_FUNCDATA_ArgsPointerMaps</span><span class="p">))</span>
			<span class="k">if</span> <span class="nx">stkmap</span><span class="p">.</span><span class="nx">nbit</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// We&#39;re in the prologue, so it&#39;s always stack map index 0.
</span><span class="c1"></span>				<span class="nx">bv</span> <span class="o">:=</span> <span class="nf">stackmapdata</span><span class="p">(</span><span class="nx">stkmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
				<span class="nf">bulkBarrierBitmap</span><span class="p">(</span><span class="nx">spArg</span><span class="p">,</span> <span class="nx">spArg</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">bv</span><span class="p">.</span><span class="nx">n</span><span class="p">)</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">bv</span><span class="p">.</span><span class="nx">bytedata</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">))</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="c1">// 这里保存了goexit的地址，在函数调用结束后，会根据pc来执行goexit
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">goexit</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span> <span class="c1">// +PCQuantum so that previous instruction is in same function
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">))</span>
	<span class="nf">gostartcallfn</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">gopc</span> <span class="p">=</span> <span class="nx">callerpc</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">ancestors</span> <span class="p">=</span> <span class="nf">saveAncestors</span><span class="p">(</span><span class="nx">callergp</span><span class="p">)</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span> <span class="p">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">labels</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">newg</span><span class="p">.</span><span class="nx">gcscanvalid</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="c1">// Gdead =&gt; Grunnable
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="c1">// 如果goid用完了，则在从Sched申请一部分
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">==</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcacheend</span> <span class="p">{</span>
		<span class="c1">// Sched.goidgen is the last allocated id,
</span><span class="c1"></span>		<span class="c1">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
</span><span class="c1"></span>		<span class="c1">// At startup sched.goidgen=0, so main goroutine receives goid=1.
</span><span class="c1"></span>		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">goidgen</span><span class="p">,</span> <span class="nx">_GoidCacheBatch</span><span class="p">)</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">-=</span> <span class="nx">_GoidCacheBatch</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcacheend</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">+</span> <span class="nx">_GoidCacheBatch</span>
	<span class="p">}</span>
	<span class="c1">// 分配goid
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">goid</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">racectx</span> <span class="p">=</span> <span class="nf">racegostart</span><span class="p">(</span><span class="nx">callerpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoCreate</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 把g加入到p的可执行队列中
</span><span class="c1"></span>	<span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">newg</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="c1">// 判断是否需要空闲的p，且是否需要一个m来执行g
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">mainStarted</span> <span class="p">{</span>
		<span class="nf">wakep</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span> <span class="c1">// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="gfget">gfget</h4>
<p>看下p有没有空闲的g，如果没有，则从gFree中获取</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
<span class="nx">retry</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(!</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">||</span> <span class="p">!</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="c1">// Move a batch of free Gs to the P.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">32</span> <span class="p">{</span>
			<span class="c1">// Prefer Gs with stacks.
</span><span class="c1"></span>			<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">gp</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">retry</span>
	<span class="p">}</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span><span class="o">--</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Stack was deallocated in gfput. Allocate a new one.
</span><span class="c1"></span>		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nx">_FixedStack</span><span class="p">)</span>
		<span class="p">})</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racemalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
			<span class="nf">msanmalloc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">),</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>
</code></pre></div><h4 id="runqput">runqput</h4>
<p>runqput尝试将g放入到本地队列中, 如果next是false，则runqput会把g放到runnable队尾，否则，把g放入了runnext，
如果本地队列满了，会把g放到全局队列中</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">randomizeScheduler</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span> <span class="o">&amp;&amp;</span> <span class="nf">fastrand</span><span class="p">()</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">next</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 把g放到runnext中
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">next</span> <span class="p">{</span>
	<span class="nx">retryNext</span><span class="p">:</span>
		<span class="nx">oldnext</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">oldnext</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="nx">retryNext</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">oldnext</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// Kick the old runnext out to the regular run queue.
</span><span class="c1"></span>		<span class="nx">gp</span> <span class="p">=</span> <span class="nx">oldnext</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="p">}</span>

<span class="nx">retry</span><span class="p">:</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span> <span class="c1">// load-acquire, synchronize with consumers
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
	<span class="c1">// 判断p的队列长度是否超出，runq长度是256，如果超出了则放到全局队列中
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span> <span class="p">&lt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">t</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// store-release, makes the item available for consumption
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 将本地队列的g丢到全局队列中
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// the queue is not full, now the put above must succeed
</span><span class="c1"></span>	<span class="k">goto</span> <span class="nx">retry</span>
<span class="p">}</span>
</code></pre></div><p>至此，新建任务已经结束，剩下就等着调度就行，从上面看队列的优先级是p.runnext &gt; p.runq &gt; sched.runq</p>
<h4 id="wakeup">wakeup</h4>
<p>newproc1创建任务后，会调用wakep 来唤醒M</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">wakep</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// be conservative about spinning threads
</span><span class="c1"></span>	<span class="c1">// 一次只允许1个M在自旋，否则退出
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 开始唤醒M
</span><span class="c1"></span>	<span class="nf">startm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="创建m">创建M</h3>
<h4 id="startm">startm</h4>
<p>调度或者创建M来运行P，如果p==nil则会去获取一个空闲的g</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">spinning</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">_p_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">()</span>   <span class="c1">// 如果p为nil，则尝试获取一个空闲的p
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">spinning</span> <span class="p">{</span>
				<span class="c1">// The caller incremented nmspinning, but there are no idle Ps,
</span><span class="c1"></span>				<span class="c1">// so it&#39;s okay to just undo the increment and give up.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startm: negative nmspinning&#34;</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">mget</span><span class="p">()</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 如果后去不到m，则创建一个spinning为true的M，并将p绑定到M上返回
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">spinning</span> <span class="p">{</span>
			<span class="c1">// The caller incremented nmspinning, so set m.spinning in the new M.
</span><span class="c1"></span>			<span class="nx">fn</span> <span class="p">=</span> <span class="nx">mspinning</span>
		<span class="p">}</span>
		<span class="nf">newm</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 判断M是否为自旋
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startm: m is spinning&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 判断获取到的M是否有P
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startm: m has p&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">spinning</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startm: p has runnable gs&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 这里spinning已经被父函数增加，这里只要设置spinning即可
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="nx">spinning</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="c1">// 唤醒m
</span><span class="c1"></span>	<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h4 id="newm">newm</h4>
<p>创建新的M</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newm</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">allocm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>   <span class="c1">// 将新建的M绑定到指定的P上
</span><span class="c1"></span>	<span class="c1">// 省略...
</span><span class="c1"></span>	<span class="nf">newm1</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newm1</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// ...省略...
</span><span class="c1"></span>	<span class="nf">newosproc</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
	<span class="c1">// ...省略...
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><h4 id="newosproc">newosproc</h4>
<p>newosproc创建一个新的系统线程，并执行mstart_stub函数，之后调用master函数进入调度</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newosproc</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 省略...
</span><span class="c1"></span>
	<span class="kd">var</span> <span class="nx">oset</span> <span class="nx">sigset</span>
	<span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">_SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sigset_all</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oset</span><span class="p">)</span>
	<span class="c1">// 创建线程，并传入启动函数mstart_stub， 之后调用start
</span><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">attr</span><span class="p">,</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">mstart_stub</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">))</span>
	<span class="nf">sigprocmask</span><span class="p">(</span><span class="nx">_SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oset</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">write</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">failthreadcreate</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">failthreadcreate</span><span class="p">)))</span>
		<span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="allocm">allocm</h4>
<p>allocm会分配m，首先从sched.free，然后去创建m，在初始化m</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">allocm</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span> <span class="o">*</span><span class="nx">m</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span> <span class="c1">// disable GC because it can be called from sysmon
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">// temporarily borrow p for mallocs in this function
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// Release the free M list. We need to do this somewhere and
</span><span class="c1"></span>	<span class="c1">// this may free up a stack we can use.
</span><span class="c1"></span>	<span class="c1">// 释放掉freem
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">freem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="kd">var</span> <span class="nx">newList</span> <span class="o">*</span><span class="nx">m</span>
		<span class="k">for</span> <span class="nx">freem</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">freem</span><span class="p">;</span> <span class="nx">freem</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">freem</span><span class="p">.</span><span class="nx">freeWait</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">next</span> <span class="o">:=</span> <span class="nx">freem</span><span class="p">.</span><span class="nx">freelink</span>
				<span class="nx">freem</span><span class="p">.</span><span class="nx">freelink</span> <span class="p">=</span> <span class="nx">newList</span>
				<span class="nx">newList</span> <span class="p">=</span> <span class="nx">freem</span>
				<span class="nx">freem</span> <span class="p">=</span> <span class="nx">next</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nf">stackfree</span><span class="p">(</span><span class="nx">freem</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span>
			<span class="nx">freem</span> <span class="p">=</span> <span class="nx">freem</span><span class="p">.</span><span class="nx">freelink</span>
		<span class="p">}</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">freem</span> <span class="p">=</span> <span class="nx">newList</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">mp</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
	<span class="c1">// 启动函数，这个fn就是下面这个函数
</span><span class="c1"></span>	<span class="c1">// var fn func()
</span><span class="c1"></span>	<span class="c1">// if spinning {
</span><span class="c1"></span>	<span class="c1">// 	fn = mspinning
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>	<span class="nx">mp</span><span class="p">.</span><span class="nx">mstartfn</span> <span class="p">=</span> <span class="nx">fn</span>
	<span class="c1">// 初始化m
</span><span class="c1"></span>	<span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>

	<span class="c1">// In case of cgo or Solaris or Darwin, pthread_create will make us a stack.
</span><span class="c1"></span>	<span class="c1">// Windows and Plan 9 will layout sched stack on OS stack.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">iscgo</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;solaris&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;plan9&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;darwin&#34;</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="mi">8192</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">StackGuardMultiplier</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">mp</span>

	<span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">releasep</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span> <span class="c1">// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">mp</span>
<span class="p">}</span>

</code></pre></div><h3 id="执行">执行</h3>
<h4 id="mstart">mstart</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mstart</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// ...省略...
</span><span class="c1"></span>	<span class="c1">// 调用mstart1 来处理
</span><span class="c1"></span>	<span class="nf">mstart1</span><span class="p">()</span>
	<span class="c1">// ...省略...
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">mstart1</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad runtime·mstart&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Record the caller for use as the top of stack in mcall and
</span><span class="c1"></span>	<span class="c1">// for terminating the thread.
</span><span class="c1"></span>	<span class="c1">// We&#39;re never coming back to mstart1 after we call schedule,
</span><span class="c1"></span>	<span class="c1">// so other calls can reuse the current frame.
</span><span class="c1"></span>	<span class="c1">// 保存程序的PC和SP值
</span><span class="c1"></span>	<span class="nf">save</span><span class="p">(</span><span class="nf">getcallerpc</span><span class="p">(),</span> <span class="nf">getcallersp</span><span class="p">())</span>
	<span class="nf">asminit</span><span class="p">()</span>
	<span class="c1">// 初始化m的栈
</span><span class="c1"></span>	<span class="nf">minit</span><span class="p">()</span>

	<span class="c1">// handle signals
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="nf">mstartm0</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 如果设置mastartfn， 则执行fn
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mstartfn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">fn</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
		<span class="c1">// 获取nextp
</span><span class="c1"></span>		<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">nextp</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h4 id="acquirep">acquirep</h4>
<p>acquirep 主要是关联当前的m和p</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Do the part that isn&#39;t allowed to have write barriers.
</span><span class="c1"></span>	<span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>

	<span class="c1">// Have p; write barriers now allowed.
</span><span class="c1"></span>
	<span class="c1">// Perform deferred mcache flush before this P can allocate
</span><span class="c1"></span>	<span class="c1">// from a potentially stale mcache.
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceProcStart</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="wirep">wirep</h4>
<p>wirep会绑定m和p</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">wirep</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: already in go&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Pidle</span> <span class="p">{</span>
		<span class="nx">id</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">id</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span>
		<span class="p">}</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;wirep: p-&gt;m=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;(&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="s">&#34;) p-&gt;status=&#34;</span><span class="p">,</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;wirep: invalid p state&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// m和p的cache共享
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span>
	<span class="c1">// 将m和p进行绑定
</span><span class="c1"></span>	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span>
	<span class="c1">// p的状态变为running
</span><span class="c1"></span>	<span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span>
<span class="p">}</span>

</code></pre></div><h4 id="schedule-调度">schedule 调度</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">schedule</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: holding locks&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果有lockedg，停止当前M
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 解除lockedm的锁定，并执行当前g
</span><span class="c1"></span>		<span class="nf">stoplockedm</span><span class="p">()</span>
		<span class="nf">execute</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// Never returns.
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// We should not schedule away from a g that is executing a cgo call,
</span><span class="c1"></span>	<span class="c1">// since the cgo call is using the m&#39;s g0 stack.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">incgo</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: in cgo&#34;</span><span class="p">)</span>
	<span class="p">}</span>

<span class="nx">top</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">gcstopm</span><span class="p">()</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runSafePointFn</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span>
	<span class="kd">var</span> <span class="nx">inheritTime</span> <span class="kt">bool</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="o">||</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">shutdown</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="p">=</span> <span class="nf">traceReader</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
			<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="p">=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">findRunnableGCWorker</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Check the global runnable queue once in a while to ensure fairness.
</span><span class="c1"></span>		<span class="c1">// Otherwise two goroutines can completely occupy the local runqueue
</span><span class="c1"></span>		<span class="c1">// by constantly respawning each other.
</span><span class="c1"></span>		<span class="c1">// 每61s从全局队列获取g
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">%</span><span class="mi">61</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">gp</span> <span class="p">=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 全局获取不到runable的g，从local获取
</span><span class="c1"></span>		<span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;schedule: spinning with local work&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 如果依赖没有获取到g，则从开始查找，从local p、global p、全局io poll获取待运行的g
</span><span class="c1"></span>		<span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="c1">// blocks until work is available
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// This thread is going to run a goroutine and is not spinning anymore,
</span><span class="c1"></span>	<span class="c1">// so if it was marked as spinning we need to reset it now and potentially
</span><span class="c1"></span>	<span class="c1">// start a new spinning M.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="nf">resetspinning</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">user</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Scheduling of this goroutine is disabled. Put it on
</span><span class="c1"></span>		<span class="c1">// the list of pending runnable goroutines for when we
</span><span class="c1"></span>		<span class="c1">// re-enable user scheduling and look again.
</span><span class="c1"></span>		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nf">schedEnabled</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Something re-enabled scheduling while we
</span><span class="c1"></span>			<span class="c1">// were acquiring the lock.
</span><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">runnable</span><span class="p">.</span><span class="nf">pushBack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">disable</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">goto</span> <span class="nx">top</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Hands off own p to the locked m,
</span><span class="c1"></span>		<span class="c1">// then blocks waiting for a new p.
</span><span class="c1"></span>		<span class="c1">// 如果g有lockedm，则休眠上交p，休眠m，等待新m，唤醒后跳转到top
</span><span class="c1"></span>		<span class="nf">startlockedm</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="c1">// 开始执行这个g
</span><span class="c1"></span>	<span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h4 id="execute">execute</h4>
<p>开始准备执行</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 更新g的状态，标记为不允许抢占
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">inheritTime</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span>

	<span class="c1">// Check whether the profiler needs to be turned on or off.
</span><span class="c1"></span>	<span class="nx">hz</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">profilehz</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">profilehz</span> <span class="o">!=</span> <span class="nx">hz</span> <span class="p">{</span>
		<span class="nf">setThreadCPUProfiler</span><span class="p">(</span><span class="nx">hz</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="c1">// GoSysExit has to happen when we have a P, but before GoStart.
</span><span class="c1"></span>		<span class="c1">// So we emit it here.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">syscallsp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sysblocktraced</span> <span class="p">{</span>
			<span class="nf">traceGoSysExit</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sysexitticks</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">traceGoStart</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 执行g的代码
</span><span class="c1"></span>	<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="goexit">goexit</h4>
<p>goroutine退出显示调用goexit1, goexit1会调用goexit0</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// goexit continuation on g0.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">goexit0</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="c1">// 将g状态更改为Dead
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
	<span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 清空g的状态
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">locked</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">lockedm</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">paniconfault</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// should be true already but just in case.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// non-nil for Goexit during panic. points at stack-allocated data.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">writebuf</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Flush assist credit to the global pool. This gives
</span><span class="c1"></span>		<span class="c1">// better information to pacing if the application is
</span><span class="c1"></span>		<span class="c1">// rapidly creating an exiting goroutines.
</span><span class="c1"></span>		<span class="nx">scanCredit</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistWorkPerByte</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span><span class="p">))</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="nx">scanCredit</span><span class="p">)</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="c1">// Note that gp&#39;s stack scan is now &#34;valid&#34; because it has no
</span><span class="c1"></span>	<span class="c1">// stack.
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">gcscanvalid</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nf">dropg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;wasm&#34;</span> <span class="p">{</span> <span class="c1">// no threads yet on wasm
</span><span class="c1"></span>		<span class="nf">gfput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">)</span>
		<span class="nf">schedule</span><span class="p">()</span> <span class="c1">// never returns
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedInt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;invalid m-&gt;lockedInt = &#34;</span><span class="p">,</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedInt</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;internal lockOSThread error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 把g放到到空闲列表中，以备复用
</span><span class="c1"></span>	<span class="nf">gfput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">locked</span> <span class="p">{</span>
		<span class="c1">// The goroutine may have locked this thread because
</span><span class="c1"></span>		<span class="c1">// it put it in an unusual kernel state. Kill it
</span><span class="c1"></span>		<span class="c1">// rather than returning it to the thread pool.
</span><span class="c1"></span>
		<span class="c1">// Return to mstart, which will release the P and exit
</span><span class="c1"></span>		<span class="c1">// the thread.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;plan9&#34;</span> <span class="p">{</span> <span class="c1">// See golang.org/issue/22227.
</span><span class="c1"></span>			<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// Clear lockedExt on plan9 since we may end up re-using
</span><span class="c1"></span>			<span class="c1">// this thread.
</span><span class="c1"></span>			<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedExt</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 再次开启调度
</span><span class="c1"></span>	<span class="nf">schedule</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div><h4 id="findrunnable">findrunnable</h4>
<p>主要功能：寻找可运行的g，主要流程</p>
<ul>
<li>从p的local队列中寻找可运行的g</li>
<li>从全局队列中寻找可以运行的g</li>
<li>从netpoll中获取一个已经准备好的g</li>
<li>从其他p的local队列中偷取可运行的g，并且会随机偷取1个next g</li>
<li>再试着从netpoll中获取准备的g，阻塞获取</li>
<li>没有的话， 就stopm</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

<span class="nx">top</span><span class="p">:</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">gcstopm</span><span class="p">()</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">runSafePointFn</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">fingwait</span> <span class="o">&amp;&amp;</span> <span class="nx">fingwake</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">wakefing</span><span class="p">();</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="o">*</span><span class="nx">cgo_yield</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">asmcgocall</span><span class="p">(</span><span class="o">*</span><span class="nx">cgo_yield</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 从本地队列中寻找可运行的g
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span>
	<span class="p">}</span>

	<span class="c1">// 从全局队列中寻找可运行的g
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 看看netpoll中有没有已经准备好的g
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWaiters</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// non-blocking
</span><span class="c1"></span>			<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
			<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
				<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Steal work from other P&#39;s.
</span><span class="c1"></span>	<span class="c1">// 从其他的P中偷取g
</span><span class="c1"></span>	<span class="nx">procs</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="nx">procs</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="c1">// 如果sched.npidle == procs-1 ,说明除了我们其他的p都是空闲的，无需偷取
</span><span class="c1"></span>		<span class="c1">// Either GOMAXPROCS=1 or everybody, except for us, is idle already.
</span><span class="c1"></span>		<span class="c1">// New work can appear from returning syscall/cgocall, network or timers.
</span><span class="c1"></span>		<span class="c1">// Neither of that submits to local run queues, so no point in stealing.
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">stop</span>
	<span class="p">}</span>
	<span class="c1">// If number of spinning M&#39;s &gt;= number of busy P&#39;s, block.
</span><span class="c1"></span>	<span class="c1">// This is necessary to prevent excessive CPU consumption
</span><span class="c1"></span>	<span class="c1">// when GOMAXPROCS&gt;&gt;1 but the program parallelism is low.
</span><span class="c1"></span>	<span class="c1">// 如果当前处在自旋状态M大于非空闲P的一半，则不再查找，避免CPU过度损耗
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="o">&amp;&amp;</span> <span class="mi">2</span><span class="o">*</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">procs</span><span class="o">-</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="nx">stop</span>
	<span class="p">}</span>
	<span class="c1">// 修改M的自旋状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 开始偷取他的P上待运行的g
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">enum</span> <span class="o">:=</span> <span class="nx">stealOrder</span><span class="p">.</span><span class="nf">start</span><span class="p">(</span><span class="nf">fastrand</span><span class="p">());</span> <span class="p">!</span><span class="nx">enum</span><span class="p">.</span><span class="nf">done</span><span class="p">();</span> <span class="nx">enum</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">top</span>
			<span class="p">}</span>
			<span class="c1">// 优先寻找待运行g超过1的P
</span><span class="c1"></span>			<span class="nx">stealRunNextG</span> <span class="o">:=</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="c1">// first look for ready queues with more than 1 g
</span><span class="c1"></span>			<span class="c1">// 偷取1半的任务，并且根据stealRunNextG判断是否从_p_.runnext随机偷取
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">runqsteal</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">enum</span><span class="p">.</span><span class="nf">position</span><span class="p">()],</span> <span class="nx">stealRunNextG</span><span class="p">);</span> <span class="nx">gp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nx">stop</span><span class="p">:</span>

	<span class="c1">// We have nothing to do. If we&#39;re in the GC mark phase, can
</span><span class="c1"></span>	<span class="c1">// safely scan and blacken objects, and have work to do, run
</span><span class="c1"></span>	<span class="c1">// idle-time marking rather than give up the P.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerIdleMode</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
			<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// wasm only:
</span><span class="c1"></span>	<span class="c1">// If a callback returned and no other goroutine is awake,
</span><span class="c1"></span>	<span class="c1">// then pause execution until a callback was triggered.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">beforeIdle</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// At least one goroutine got woken.
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>

	<span class="c1">// Before we drop our P, make a snapshot of the allp slice,
</span><span class="c1"></span>	<span class="c1">// which can change underfoot once we no longer block
</span><span class="c1"></span>	<span class="c1">// safe-points. We don&#39;t need to snapshot the contents because
</span><span class="c1"></span>	<span class="c1">// everything up to cap(allp) is immutable.
</span><span class="c1"></span>	<span class="nx">allpSnapshot</span> <span class="o">:=</span> <span class="nx">allp</span>

	<span class="c1">// return P and block
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nf">releasep</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">_p_</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: wrong p&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Delicate dance: thread transitions from spinning to non-spinning state,
</span><span class="c1"></span>	<span class="c1">// potentially concurrently with submission of new goroutines. We must
</span><span class="c1"></span>	<span class="c1">// drop nmspinning first and then check all per-P queues again (with
</span><span class="c1"></span>	<span class="c1">// #StoreLoad memory barrier in between). If we do it the other way around,
</span><span class="c1"></span>	<span class="c1">// another thread can submit a goroutine after we&#39;ve checked all run queues
</span><span class="c1"></span>	<span class="c1">// but before we drop nmspinning; as the result nobody will unpark a thread
</span><span class="c1"></span>	<span class="c1">// to run the goroutine.
</span><span class="c1"></span>	<span class="c1">// If we discover new work below, we need to restore m.spinning as a signal
</span><span class="c1"></span>	<span class="c1">// for resetspinning to unpark a new worker thread (because there can be more
</span><span class="c1"></span>	<span class="c1">// than one starving goroutine). However, if after discovering new work
</span><span class="c1"></span>	<span class="c1">// we also observe no idle Ps, it is OK to just park the current thread:
</span><span class="c1"></span>	<span class="c1">// the system is fully loaded so no spinning threads are required.
</span><span class="c1"></span>	<span class="c1">// Also see &#34;Worker thread parking/unparking&#34; comment at the top of the file.
</span><span class="c1"></span>	<span class="nx">wasSpinning</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: negative nmspinning&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// check all runqueues once again
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_p_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allpSnapshot</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">_p_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">()</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">wasSpinning</span> <span class="p">{</span>
					<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">goto</span> <span class="nx">top</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//省略
</span><span class="c1"></span>
	<span class="c1">// 从io poll中获取运行的g
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWaiters</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xchg64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: netpoll with p&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">spinning</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;findrunnable: netpoll with spinning&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="c1">// block until new work is available
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">nanotime</span><span class="p">()))</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="nx">_p_</span> <span class="p">=</span> <span class="nf">pidleget</span><span class="p">()</span>
			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">_p_</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">acquirep</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
				<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
				<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
				<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
					<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">stopm</span><span class="p">()</span>
	<span class="k">goto</span> <span class="nx">top</span>
<span class="p">}</span>
</code></pre></div><h3 id="系统监控-sysmon">系统监控 sysmon</h3>
<p>sysmon 是go的监控，主要完成下面几件事：</p>
<ul>
<li>释放闲置超过5分钟的span物理内存</li>
<li>如果超过2分钟没有执行垃圾回收，则强制执行</li>
<li>将长时间未处理的netpoll添加到全局队列中</li>
<li>对长时间运行中的g发起抢占</li>
<li>收回因为syscall而长时间阻塞的p</li>
</ul>
<p>监控不是时刻都在运行，它自己有个唤醒周期，第一次是20us, 每次执行完，增加1倍休眠时间，最大休眠时间是10ms</p>
<h4 id="retake-偷取">Retake 偷取</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// forcePreemptNS is the time slice given to a G before it is
</span><span class="c1">// preempted.
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">forcePreemptNS</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000</span> <span class="c1">// 10ms
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">retake</span><span class="p">(</span><span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="c1">// Prevent allp slice changes. This lock will be completely
</span><span class="c1"></span>	<span class="c1">// uncontended unless we&#39;re already stopping the world.
</span><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="c1">// We can&#39;t use a range loop over allp because we may
</span><span class="c1"></span>	<span class="c1">// temporarily drop the allpLock. Hence, we need to re-fetch
</span><span class="c1"></span>	<span class="c1">// allp each time around the loop.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// This can happen if procresize has grown
</span><span class="c1"></span>			<span class="c1">// allp but not yet created new Ps.
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">pd</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">sysmontick</span>
		<span class="nx">s</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span>
		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="p">{</span>
			<span class="c1">// Retake P from syscall if it&#39;s there for more than 1 sysmon tick (at least 20us).
</span><span class="c1"></span>			<span class="c1">// 只有sysmon才更新，所以第一次不会抢占，而是第二次开始抢占，至少间隔20us，最多10ms
</span><span class="c1"></span>			<span class="nx">t</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">syscalltick</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">syscalltick</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span>
				<span class="nx">pd</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
				<span class="nx">pd</span><span class="p">.</span><span class="nx">syscallwhen</span> <span class="p">=</span> <span class="nx">now</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// On the one hand we don&#39;t want to retake Ps if there is no other work to do,
</span><span class="c1"></span>			<span class="c1">// but on the other hand we want to retake them eventually
</span><span class="c1"></span>			<span class="c1">// because they can prevent the sysmon thread from deep sleep.
</span><span class="c1"></span>			<span class="c1">// 是否有空P， 是否有寻找p的m以及空闲的p，以及当p在syscall后超过10ms的
</span><span class="c1"></span>			<span class="k">if</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span><span class="o">+</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">syscallwhen</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// Drop allpLock so we can take sched.lock.
</span><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
			<span class="c1">// Need to decrement number of idle locked M&#39;s
</span><span class="c1"></span>			<span class="c1">// (pretending that one more is running) before the CAS.
</span><span class="c1"></span>			<span class="c1">// Otherwise the M from which we retake can exit the syscall,
</span><span class="c1"></span>			<span class="c1">// increment nmidle and report deadlock.
</span><span class="c1"></span>			<span class="nf">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="c1">// 抢占p，把p的状态改为idle
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">_Pidle</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
					<span class="nf">traceGoSysBlock</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
					<span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">n</span><span class="o">++</span>
				<span class="nx">_p_</span><span class="p">.</span><span class="nx">syscalltick</span><span class="o">++</span>
				<span class="nf">handoffp</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nf">incidlelocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Prunning</span> <span class="p">{</span>
			<span class="c1">// Preempt G if it&#39;s running for too long.
</span><span class="c1"></span>			<span class="c1">// 如果p是running，并且执行时间过长，则抢占
</span><span class="c1"></span>			<span class="nx">t</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">schedtick</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">schedtick</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span> <span class="c1">// 在周期内已经调度过，即当前p上运行的g改变过
</span><span class="c1"></span>				<span class="nx">pd</span><span class="p">.</span><span class="nx">schedtick</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
				<span class="nx">pd</span><span class="p">.</span><span class="nx">schedwhen</span> <span class="p">=</span> <span class="nx">now</span>  <span class="c1">// 更新最后一次抢占检测时间
</span><span class="c1"></span>				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// 判断是否超出10ms，不超过则不抢占
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">schedwhen</span><span class="o">+</span><span class="nx">forcePreemptNS</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">// 开始抢占
</span><span class="c1"></span>			<span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="handoffp">handoffp</h4>
<p>handoffp 主要的功能是</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">handoffp</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// handoffp must start an M in any situation where
</span><span class="c1"></span>	<span class="c1">// findrunnable would return a G to run on _p_.
</span><span class="c1"></span>
	<span class="c1">// 如果本地有待运行的任务，则立即开始调度
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="o">||</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// if it has GC work, start it straight away
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// no local work, check that there are no spinning/idle M&#39;s,
</span><span class="c1"></span>	<span class="c1">// otherwise our help is not required
</span><span class="c1"></span>	<span class="c1">// 如果本地没有任务，则开始检查有没有自旋和空闲的P，如果有则开始调度
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span><span class="o">+</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// TODO: fast atomic
</span><span class="c1"></span>		<span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
		<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runSafePointFn</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nf">safePointFn</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">safePointWait</span><span class="o">--</span>
		<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">safePointWait</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">safePointNote</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 判断全局g队列为不为空，如果不为空，则尝试开始调度
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// If this is the last running P and nobody is polling network,
</span><span class="c1"></span>	<span class="c1">// need to wakeup another M to poll network.
</span><span class="c1"></span>	<span class="c1">// 如果这个没有人运行poll networ，则需要唤醒一个M去执行
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span> <span class="o">==</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nf">startm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 如果都没有，则把p放到空闲队列中
</span><span class="c1"></span>	<span class="nf">pidleput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><p>####preemptone 抢占
当g发现栈不够用，就会去进行栈扩张(调用newstack分配一个新站)，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">mp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">mp</span> <span class="o">==</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span>
	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="c1">// 设置抢占
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="c1">// stackPreempt是个特殊的常量，比任何栈地址都大
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><h4 id="newstack的抢占判断逻辑">newstack的抢占判断逻辑</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="c1">// 发现是抢占，则会重新调度
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preempt</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mallocing</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="o">||</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Prunning</span> <span class="p">{</span>
			<span class="c1">// Let the goroutine keep running for now.
</span><span class="c1"></span>			<span class="c1">// gp-&gt;preempt is set, so it will be preempted next time.
</span><span class="c1"></span>			<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
			<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span> <span class="c1">// never return
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div><p>Gdead&ndash; newproc &ndash;&gt; Grunable &ndash; execute &ndash;&gt; Grunning &ndash;&gt; goexit0 -&gt; Gdead</p>
<h3 id="总结">总结</h3>
<p>当调用go func的时候，大致流程如下</p>
<pre><code class="language-mermaid" data-lang="mermaid">graph LR
   G的默认状态(Gidle) --newproc--&gt; 生成G(Gdead) 
   生成G(Gdead) --空闲的P&amp;&amp;sched不在自旋--&gt; 开始尝试唤醒M
   开始尝试唤醒M --M不足则新建 --&gt; 获取M
   获取M -- startm --&gt; 启动M 
   启动M -- 等待调度 --&gt; schedule调度
   schedule调度 -- 获取待运行的g --&gt; 获取成功 
   获取g成功 -- 运行g--&gt; G状态更新为Grunning
   G状态更新为Grunning -- goexit --&gt; 执行完毕G的状态变为Gdead
   
</code></pre><h3 id="参考资料">参考资料</h3>
<ol>
<li><a href="https://segmentfault.com/a/1190000020254937">https://segmentfault.com/a/1190000020254937</a></li>
<li><a href="https://blog.csdn.net/u010853261/article/details/84790392#35_sysmon_1026">https://blog.csdn.net/u010853261/article/details/84790392#35_sysmon_1026</a></li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>Go-深入理解context</title>
			<link>https://leonzyang.github.io/posts/context/</link>
			<pubDate>Sun, 27 Jun 2021 09:19:02 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/context/</guid>
			<description>深入理解context context是一个服务上下文切换的包，我们可以定义deadline或者手动cancel对一些派生的goroutine进行控制，比较常见的就是http服务，一个http可能会启动N个goroutine，那么当http request取消后，如果快速关闭这些goroutine，还有种场景就是进行上下文变量传递。
数据结构 Context Context是个接口类型
type Context interface { // 返回当前任务取消的时间， ok表示是否设置deadline 	Deadline() (deadline time.Time, ok bool) // done返回一个只读channel，当cancel被调用或者deadline过期后，会close 这个channnel 	Done() &amp;lt;-chan struct{} // 如果Done没有被关闭，返回nil，否则返回一个非nil的error 	Err() error // value返回这个上下文关联key的value，如果没有设置，则返回nil 	Value(key interface{}) interface{} } Backgroud和TODO emptyCtx是一个无法cancel的Context，backgroud和todo是两个emptyCtx的指针，如果你不确定你的Context有什么用，那么就用context.TODO()
var ( background = new(emptyCtx) todo = new(emptyCtx) ) cancelCtx cancelCtx实现了取消，如果取消，那么children(实现了cancel)的也会被取消
type cancelCtx struct { Context // 锁 	mu sync.Mutex // protects following fields 	// 首次取消会close 	done chan struct{} // created lazily, closed by first cancel call 	// 首次cancel，会被设置成nil 	children map[canceler]struct{} // set to nil by the first cancel call 	// 首次取消是个非nil的error· 	err error // set to non-nil by the first cancel call } timerCtx timerCtx内嵌了cancelCtx</description>
			<content type="html"><![CDATA[<h2 id="深入理解context">深入理解context</h2>
<p>context是一个服务上下文切换的包，我们可以定义deadline或者手动cancel对一些派生的goroutine进行控制，比较常见的就是http服务，一个http可能会启动N个goroutine，那么当http request取消后，如果快速关闭这些goroutine，还有种场景就是进行上下文变量传递。</p>
<h3 id="数据结构">数据结构</h3>
<h4 id="context">Context</h4>
<p>Context是个接口类型</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// 返回当前任务取消的时间， ok表示是否设置deadline
</span><span class="c1"></span>	<span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>

    <span class="c1">// done返回一个只读channel，当cancel被调用或者deadline过期后，会close 这个channnel
</span><span class="c1"></span>	<span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>

    <span class="c1">// 如果Done没有被关闭，返回nil，否则返回一个非nil的error
</span><span class="c1"></span>	<span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span>

    <span class="c1">// value返回这个上下文关联key的value，如果没有设置，则返回nil
</span><span class="c1"></span>	<span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><h4 id="backgroud和todo">Backgroud和TODO</h4>
<p>emptyCtx是一个无法cancel的Context，backgroud和todo是两个emptyCtx的指针，如果你不确定你的Context有什么用，那么就用context.TODO()</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">background</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span>
	<span class="nx">todo</span>       <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div><h4 id="cancelctx">cancelCtx</h4>
<p>cancelCtx实现了取消，如果取消，那么children(实现了cancel)的也会被取消</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">cancelCtx</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Context</span>

	<span class="c1">// 锁
</span><span class="c1"></span>	<span class="nx">mu</span>       <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>            <span class="c1">// protects following fields
</span><span class="c1"></span>	<span class="c1">// 首次取消会close
</span><span class="c1"></span>	<span class="nx">done</span>     <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>         <span class="c1">// created lazily, closed by first cancel call
</span><span class="c1"></span>	<span class="c1">// 首次cancel，会被设置成nil
</span><span class="c1"></span>	<span class="nx">children</span> <span class="kd">map</span><span class="p">[</span><span class="nx">canceler</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}</span> <span class="c1">// set to nil by the first cancel call
</span><span class="c1"></span>	<span class="c1">// 首次取消是个非nil的error·
</span><span class="c1"></span>	<span class="nx">err</span>      <span class="kt">error</span>                 <span class="c1">// set to non-nil by the first cancel call
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><h4 id="timerctx">timerCtx</h4>
<p>timerCtx内嵌了cancelCtx</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">timerCtx</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">cancelCtx</span>
	<span class="c1">// 被cancelCtx lock保护
</span><span class="c1"></span>	<span class="nx">timer</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span> <span class="c1">// Under cancelCtx.mu.
</span><span class="c1"></span>
	<span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>

</code></pre></div><h4 id="valuectx">valueCtx</h4>
<p>valueCtx有一对key和val</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">valueCtx</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Context</span>
	<span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><h3 id="方法">方法</h3>
<h4 id="withcancel">WithCancel</h4>
<p>WithCancel创建一个cancelCtx的context</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
	<span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="withdeadline">WithDeadline</h4>
<p>WithDeadline 返回一个deadline的context，当parent done被close，deadline过期和cancel，这个context的Done会被closed</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">cur</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// The current deadline is already sooner than the new one.
</span><span class="c1"></span>        <span class="c1">// parent的deadline早于当前的deadline，肯定parent先达到expired
</span><span class="c1"></span>		<span class="k">return</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">timerCtx</span><span class="p">{</span>
		<span class="nx">cancelCtx</span><span class="p">:</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">),</span>
		<span class="nx">deadline</span><span class="p">:</span>  <span class="nx">d</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
	<span class="nx">dur</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">dur</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span> <span class="c1">// deadline has already passed
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">dur</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="withtimeout">WithTimeout</h4>
<p>WithTimeout相当于WithDeadline(parent, time.Now().Add(timeout))</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">timeout</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h4 id="withvalue">WithValue</h4>
<p>WithValue返回一个关联key的context, key必须是个可比较得指针或者对象，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithValue</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Context</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;nil key&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">key</span><span class="p">).</span><span class="nf">Comparable</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;key is not comparable&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">valueCtx</span><span class="p">{</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="其他">其他</h3>
<h4 id="propagatecancel">propagateCancel</h4>
<p>propagateCancel用来检查parent状态和启动监听任务</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">child</span> <span class="nx">canceler</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="c1">// parent is never canceled
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">parentCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// parent 已经关闭了
</span><span class="c1"></span>			<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">children</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">p</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">canceler</span><span class="p">]</span><span class="kd">struct</span><span class="p">{})</span>
			<span class="p">}</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">child</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="p">}</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// 启动监听parent和child的goroutine
</span><span class="c1"></span>			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">parent</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
				<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">child</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="parentcancelctx">parentCancelCtx</h4>
<p>从下至上直到获取cancelCtx</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">parentCancelCtx</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">cancelCtx</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="nx">c</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">:</span>
			<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kc">true</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">timerCtx</span><span class="p">:</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">,</span> <span class="kc">true</span>
		<span class="k">case</span> <span class="o">*</span><span class="nx">valueCtx</span><span class="p">:</span>
			<span class="nx">parent</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Context</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>总结：总体上看context源码还是比较简单的，在实际应用中context也是非常有用的</p>
]]></content>
		</item>
		
		<item>
			<title>Go-深入理解channel和select</title>
			<link>https://leonzyang.github.io/posts/channel/</link>
			<pubDate>Sun, 27 Jun 2021 09:18:51 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/channel/</guid>
			<description>深入理解channel和select 数据结构 hchan channel的结构体
type hchan struct { qcount uint // 队列中的数据总量 	dataqsiz uint // 环形队列大小， 大于0代表有缓存， 等于0代表无缓存 	buf unsafe.Pointer // 元素数组的指针 	elemsize uint16 // 单个元素的大小 	closed uint32 // 是否close 	elemtype *_type // 元素类型 	sendx uint // 发送数组的索引 	recvx uint // 接收数组的索引 	recvq waitq // 等待recv的数据链表 	sendq waitq // 等待send的数据链表  // lock protects all fields in hchan, as well as several 	// fields in sudogs blocked on this channel.</description>
			<content type="html"><![CDATA[<h2 id="深入理解channel和select">深入理解channel和select</h2>
<h3 id="数据结构">数据结构</h3>
<p>hchan channel的结构体</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// 队列中的数据总量
</span><span class="c1"></span>	<span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// 环形队列大小， 大于0代表有缓存， 等于0代表无缓存
</span><span class="c1"></span>	<span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 元素数组的指针
</span><span class="c1"></span>	<span class="nx">elemsize</span> <span class="kt">uint16</span>         <span class="c1">// 单个元素的大小
</span><span class="c1"></span>	<span class="nx">closed</span>   <span class="kt">uint32</span>         <span class="c1">// 是否close
</span><span class="c1"></span>	<span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span> <span class="c1">// 元素类型
</span><span class="c1"></span>	<span class="nx">sendx</span>    <span class="kt">uint</span>   <span class="c1">// 发送数组的索引
</span><span class="c1"></span>	<span class="nx">recvx</span>    <span class="kt">uint</span>   <span class="c1">// 接收数组的索引
</span><span class="c1"></span>	<span class="nx">recvq</span>    <span class="nx">waitq</span>  <span class="c1">// 等待recv的数据链表
</span><span class="c1"></span>	<span class="nx">sendq</span>    <span class="nx">waitq</span>  <span class="c1">// 等待send的数据链表
</span><span class="c1"></span>
	<span class="c1">// lock protects all fields in hchan, as well as several
</span><span class="c1"></span>	<span class="c1">// fields in sudogs blocked on this channel.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Do not change another G&#39;s status while holding this lock
</span><span class="c1"></span>	<span class="c1">// (in particular, do not ready a G), as this can deadlock
</span><span class="c1"></span>	<span class="c1">// with stack shrinking.
</span><span class="c1"></span>	<span class="nx">lock</span> <span class="nx">mutex</span>
<span class="p">}</span>
</code></pre></div><p>waitq的数据结构</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">waitq</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">first</span> <span class="o">*</span><span class="nx">sudog</span>
	<span class="nx">last</span>  <span class="o">*</span><span class="nx">sudog</span>
<span class="p">}</span>
</code></pre></div><h3 id="chan">chan</h3>
<h4 id="makechan">makechan</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
	<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span>

	<span class="c1">// 检查size是否过去打
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: invalid channel element type&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 检查内存对齐
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">hchanSize</span><span class="o">%</span><span class="nx">maxAlign</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">align</span> <span class="p">&gt;</span> <span class="nx">maxAlign</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: bad alignment&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 检查size是否小于0或者内存溢出
</span><span class="c1"></span>	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">-</span><span class="nx">hchanSize</span> <span class="o">||</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;makechan: size out of range&#34;</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</span><span class="c1"></span>	<span class="c1">// buf points into the same allocation, elemtype is persistent.
</span><span class="c1"></span>	<span class="c1">// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span><span class="c1"></span>	<span class="c1">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// Queue or element size is zero.
</span><span class="c1"></span>		<span class="c1">// size为0，无缓存
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="c1">// Race detector uses this location for synchronization.
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">()</span>
	<span class="k">case</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindNoPointers</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
		<span class="c1">// Elements do not contain pointers.
</span><span class="c1"></span>		<span class="c1">// Allocate hchan and buf in one call.
</span><span class="c1"></span>		<span class="c1">// 元素不包含内存，分配缓存
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="o">+</span><span class="nx">mem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">hchanSize</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// Elements contain pointers.
</span><span class="c1"></span>		<span class="c1">// 包含指针，不分配缓存
</span><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 元素大小
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="c1">// 元素类型
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">elem</span>
	<span class="c1">// 数据大小
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">debugChan</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;makechan: chan=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;; elemsize=&#34;</span><span class="p">,</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="s">&#34;; elemalg=&#34;</span><span class="p">,</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">alg</span><span class="p">,</span> <span class="s">&#34;; dataqsiz=&#34;</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</code></pre></div><h4 id="chansend">chansend</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="c1">// 如果c为nil，则会block,等待其他唤醒
</span><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanSendNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">debugChan</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;chansend: chan=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racereadpc</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">(),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">chansend</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// Fast path: check for failed non-blocking operation without acquiring the lock.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// After observing that the channel is not closed, we observe that the channel is
</span><span class="c1"></span>	<span class="c1">// not ready for sending. Each of these observations is a single word-sized read
</span><span class="c1"></span>	<span class="c1">// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).
</span><span class="c1"></span>	<span class="c1">// Because a closed channel cannot transition from &#39;ready for sending&#39; to
</span><span class="c1"></span>	<span class="c1">// &#39;not ready for sending&#39;, even if the channel is closed between the two observations,
</span><span class="c1"></span>	<span class="c1">// they imply a moment between the two when the channel was both not yet closed
</span><span class="c1"></span>	<span class="c1">// and not ready for sending. We behave as if we observed the channel at that moment,
</span><span class="c1"></span>	<span class="c1">// and report that the send cannot proceed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// It is okay if the reads are reordered here: if we observe that the channel is not
</span><span class="c1"></span>	<span class="c1">// ready for sending and then observe that it is not closed, that implies that the
</span><span class="c1"></span>	<span class="c1">// channel wasn&#39;t closed during the first observation.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nx">first</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">t0</span> <span class="kt">int64</span>
	<span class="k">if</span> <span class="nx">blockprofilerate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">t0</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 如果channel是closed，则会panic send on closed channel
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Found a waiting receiver. We pass the value we want to send
</span><span class="c1"></span>		<span class="c1">// directly to the receiver, bypassing the channel buffer (if any).
</span><span class="c1"></span>		<span class="c1">// 如果发现有个等待的接收者，则直接发给接收者，跳过buf
</span><span class="c1"></span>		<span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
		<span class="c1">// Space is available in the channel buffer. Enqueue the element to send.
</span><span class="c1"></span>		<span class="c1">// 如果当前buf没有满，则加入到队尾
</span><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">qp</span><span class="p">)</span>
			<span class="nf">racerelease</span><span class="p">(</span><span class="nx">qp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 直接拷贝
</span><span class="c1"></span>		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
		<span class="c1">// 更新sendx索引
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// Block on the channel. Some receiver will complete our operation for us.
</span><span class="c1"></span>	<span class="c1">// 如果没有接收者或者buf满了，则需要block
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span><span class="c1"></span>	<span class="c1">// 初始化sudog
</span><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="c1">// block 直接到有人唤醒
</span><span class="c1"></span>	<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonChanSend</span><span class="p">,</span> <span class="nx">traceEvGoBlockSend</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="c1">// Ensure the value being sent is kept alive until the
</span><span class="c1"></span>	<span class="c1">// receiver copies it out. The sudog has a pointer to the
</span><span class="c1"></span>	<span class="c1">// stack object, but sudogs aren&#39;t considered as roots of the
</span><span class="c1"></span>	<span class="c1">// stack tracer.
</span><span class="c1"></span>	<span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">ep</span><span class="p">)</span>

	<span class="c1">// someone woke us up.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;chansend: spurious wakeup&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

</code></pre></div><h4 id="send">send</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">send</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">sg</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">skip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">racesync</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// Pretend we go through the buffer, even though
</span><span class="c1"></span>			<span class="c1">// we copy directly. Note that we need to increment
</span><span class="c1"></span>			<span class="c1">// the head/tail locations only when raceenabled.
</span><span class="c1"></span>			<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
			<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">qp</span><span class="p">)</span>
			<span class="nf">racerelease</span><span class="p">(</span><span class="nx">qp</span><span class="p">)</span>
			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">sg</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
			<span class="nf">racereleaseg</span><span class="p">(</span><span class="nx">sg</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">}</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="c1">// c.sendx = (c.sendx+1) % c.dataqsiz
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 将ep直接发送到对面的sg上
</span><span class="c1"></span>		<span class="nf">sendDirect</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
	<span class="nf">unlockf</span><span class="p">()</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="c1">// 唤醒
</span><span class="c1"></span>	<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">skip</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h5 id="chanrecv">chanrecv</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// raceenabled: don&#39;t need to check ep, as it is always on the stack
</span><span class="c1"></span>	<span class="c1">// or is new memory allocated by reflect.
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">debugChan</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;chanrecv: chan=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// 如果是nil，同样也会阻塞
</span><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanReceiveNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Fast path: check for failed non-blocking operation without acquiring the lock.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// After observing that the channel is not ready for receiving, we observe that the
</span><span class="c1"></span>	<span class="c1">// channel is not closed. Each of these observations is a single word-sized read
</span><span class="c1"></span>	<span class="c1">// (first c.sendq.first or c.qcount, and second c.closed).
</span><span class="c1"></span>	<span class="c1">// Because a channel cannot be reopened, the later observation of the channel
</span><span class="c1"></span>	<span class="c1">// being not closed implies that it was also not closed at the moment of the
</span><span class="c1"></span>	<span class="c1">// first observation. We behave as if we observed the channel at that moment
</span><span class="c1"></span>	<span class="c1">// and report that the receive cannot proceed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The order of operations is important here: reversing the operations can lead to
</span><span class="c1"></span>	<span class="c1">// incorrect behavior when racing with a close.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nx">first</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loaduint</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">t0</span> <span class="kt">int64</span>
	<span class="k">if</span> <span class="nx">blockprofilerate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">t0</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 清除内存
</span><span class="c1"></span>			<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Found a waiting sender. If buffer is size 0, receive value
</span><span class="c1"></span>		<span class="c1">// directly from sender. Otherwise, receive from head of queue
</span><span class="c1"></span>		<span class="c1">// and add sender&#39;s value to the tail of the queue (both map to
</span><span class="c1"></span>		<span class="c1">// the same buffer slot because the queue is full).
</span><span class="c1"></span>		<span class="c1">// 如果有一个发送方，如果buffer为0，接收方会直接从发送方接收数据，发送的数据会直接写到队尾
</span><span class="c1"></span>		<span class="nf">recv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Receive directly from queue
</span><span class="c1"></span>		<span class="c1">// 如果buf有数据，则直接从队列中读取
</span><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">qp</span><span class="p">)</span>
			<span class="nf">racerelease</span><span class="p">(</span><span class="nx">qp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// 读取完成后清除
</span><span class="c1"></span>		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
		<span class="c1">// 更新sendx索引
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">--</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// no sender available: block on this channel.
</span><span class="c1"></span>	<span class="c1">// 没有sender，block
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="c1">// 阻塞等待唤醒
</span><span class="c1"></span>	<span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonChanReceive</span><span class="p">,</span> <span class="nx">traceEvGoBlockRecv</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

	<span class="c1">// someone woke us up
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">closed</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="o">==</span> <span class="kc">nil</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="p">!</span><span class="nx">closed</span>
<span class="p">}</span>
</code></pre></div><h4 id="recv">recv</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">recv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">sg</span> <span class="o">*</span><span class="nx">sudog</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">skip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// 无缓存buf
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">racesync</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// copy data from sender
</span><span class="c1"></span>			<span class="c1">// 如果ep不为空，则直接copy数据给sender
</span><span class="c1"></span>			<span class="nf">recvDirect</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 有缓存buf
</span><span class="c1"></span>		<span class="c1">// Queue is full. Take the item at the
</span><span class="c1"></span>		<span class="c1">// head of the queue. Make the sender enqueue
</span><span class="c1"></span>		<span class="c1">// its item at the tail of the queue. Since the
</span><span class="c1"></span>		<span class="c1">// queue is full, those are both the same slot.
</span><span class="c1"></span>		<span class="c1">// 如果队列满了，则从队头去除一个元素
</span><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">qp</span><span class="p">)</span>
			<span class="nf">racerelease</span><span class="p">(</span><span class="nx">qp</span><span class="p">)</span>
			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">sg</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
			<span class="nf">racereleaseg</span><span class="p">(</span><span class="nx">sg</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// copy data from queue to receiver
</span><span class="c1"></span>		<span class="c1">// 拷贝数据给接收方
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="c1">// copy data from sender to queue
</span><span class="c1"></span>		<span class="c1">// 将当前的数据写入到队列中
</span><span class="c1"></span>		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
		<span class="c1">// 更新索引
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="c1">// c.sendx = (c.sendx+1) % c.dataqsiz
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
	<span class="nf">unlockf</span><span class="p">()</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">skip</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="closechan">closechan</h4>
<p>关闭channel</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">closechan</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// channel为空，则报panic
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of nil channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">// 如果channel已经关闭了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of closed channel&#34;</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
		<span class="nf">racewritepc</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">(),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">closechan</span><span class="p">))</span>
		<span class="nf">racerelease</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="mi">1</span>

	<span class="kd">var</span> <span class="nx">glist</span> <span class="nx">gList</span>

	<span class="c1">// release all readers
</span><span class="c1"></span>	<span class="c1">// 把所有的接收方全部放入到glist中
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
			<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// release all writers (they will panic)
</span><span class="c1"></span>	<span class="c1">// 把所有的发送方放入到glist，他们会报panic
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

	<span class="c1">// Ready all Gs now that we&#39;ve dropped the channel lock.
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
		<span class="nx">gp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="c1">// 开始唤醒g
</span><span class="c1"></span>		<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="select">Select</h3>
<h4 id="reflect_rselect">reflect_rselect</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">reflect_rselect</span><span class="p">(</span><span class="nx">cases</span> <span class="p">[]</span><span class="nx">runtimeSelect</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 如果没有case，则block
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cases</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">block</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">sel</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">scase</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cases</span><span class="p">))</span>
	<span class="nx">order</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint16</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">cases</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">cases</span> <span class="p">{</span>
		<span class="nx">rc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">cases</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">switch</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">dir</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">selectDefault</span><span class="p">:</span>
			<span class="nx">sel</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">scase</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">caseDefault</span><span class="p">}</span>
		<span class="k">case</span> <span class="nx">selectSend</span><span class="p">:</span>
			<span class="c1">// rc.val 就是send的val
</span><span class="c1"></span>			<span class="nx">sel</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">scase</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">caseSend</span><span class="p">,</span> <span class="nx">c</span><span class="p">:</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">elem</span><span class="p">:</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">val</span><span class="p">}</span>
		<span class="k">case</span> <span class="nx">selectRecv</span><span class="p">:</span>
			<span class="c1">// rc.val 就是recv的val
</span><span class="c1"></span>			<span class="nx">sel</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">scase</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">caseRecv</span><span class="p">,</span> <span class="nx">c</span><span class="p">:</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">elem</span><span class="p">:</span> <span class="nx">rc</span><span class="p">.</span><span class="nx">val</span><span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="o">||</span> <span class="nx">msanenabled</span> <span class="p">{</span>
			<span class="nf">selectsetpc</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sel</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">selectgo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="nx">order</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cases</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h4 id="selectgo">selectgo</h4>
<p>selectgo代码比较多，有些不重要的地方做了些精简</p>
<p>大致流程如下：</p>
<ol>
<li>循环判断case，如果是阻塞，则跳过，如果有default，则执行default</li>
<li>所有case都阻塞并且没有default，则创建一个waiting队列，绑定sudog到对应recvq和sendq上，并且阻塞等待唤醒</li>
<li>如果某个sudog对应的case被G唤醒了，则清除waiting队列的数据</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">selectgo</span><span class="p">(</span><span class="nx">cas0</span> <span class="o">*</span><span class="nx">scase</span><span class="p">,</span> <span class="nx">order0</span> <span class="o">*</span><span class="kt">uint16</span><span class="p">,</span> <span class="nx">ncases</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// if debugSelect {}
</span><span class="c1"></span>	<span class="c1">// order 是2倍的ncases, cas是1倍的ncases
</span><span class="c1"></span>	<span class="nx">cas1</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">]</span><span class="nx">scase</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">cas0</span><span class="p">))</span>
	<span class="nx">order1</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">]</span><span class="kt">uint16</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">order0</span><span class="p">))</span>
	
	<span class="c1">// scases 从0-ncases
</span><span class="c1"></span>	<span class="nx">scases</span> <span class="o">:=</span> <span class="nx">cas1</span><span class="p">[:</span><span class="nx">ncases</span><span class="p">:</span><span class="nx">ncases</span><span class="p">]</span>
	<span class="c1">// pollorder 从0-ncases
</span><span class="c1"></span>	<span class="nx">pollorder</span> <span class="o">:=</span> <span class="nx">order1</span><span class="p">[:</span><span class="nx">ncases</span><span class="p">:</span><span class="nx">ncases</span><span class="p">]</span>
	<span class="c1">// lockorder 从ncases-2*ncases
</span><span class="c1"></span>	<span class="nx">lockorder</span> <span class="o">:=</span> <span class="nx">order1</span><span class="p">[</span><span class="nx">ncases</span><span class="p">:][:</span><span class="nx">ncases</span><span class="p">:</span><span class="nx">ncases</span><span class="p">]</span>

	<span class="c1">// Replace send/receive cases involving nil channels with
</span><span class="c1"></span>	<span class="c1">// caseNil so logic below can assume non-nil channel.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scases</span> <span class="p">{</span>
		<span class="nx">cas</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">scases</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">kind</span> <span class="o">!=</span> <span class="nx">caseDefault</span> <span class="p">{</span>
			<span class="o">*</span><span class="nx">cas</span> <span class="p">=</span> <span class="nx">scase</span><span class="p">{}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">t0</span> <span class="kt">int64</span>
	<span class="k">if</span> <span class="nx">blockprofilerate</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">t0</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">ncases</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">scases</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// generate permuted order
</span><span class="c1"></span>	<span class="c1">// 生成排列的顺序
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">ncases</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">j</span> <span class="o">:=</span> <span class="nf">fastrandn</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="nx">pollorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pollorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
		<span class="nx">pollorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// sort the cases by Hchan address to get the locking order.
</span><span class="c1"></span>	<span class="c1">// simple heap sort, to guarantee n log n time and constant stack footprint.
</span><span class="c1"></span>	<span class="c1">// 通过Hchan的地址来确定锁排序，使用堆排序减少时间复杂度，创建一个最大堆
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">ncases</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span>
		<span class="c1">// Start with the pollorder to permute cases on the same channel.
</span><span class="c1"></span>		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">pollorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]].</span><span class="nx">c</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">lockorder</span><span class="p">[(</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">]].</span><span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
			<span class="nx">lockorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
			<span class="nx">j</span> <span class="p">=</span> <span class="nx">k</span>
		<span class="p">}</span>
		<span class="nx">lockorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pollorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">ncases</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">o</span> <span class="o">:=</span> <span class="nx">lockorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">c</span> <span class="o">:=</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">o</span><span class="p">].</span><span class="nx">c</span>
		<span class="nx">lockorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">lockorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">k</span> <span class="o">:=</span> <span class="nx">j</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">k</span> <span class="o">&gt;=</span> <span class="nx">i</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">k</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="p">]].</span><span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]].</span><span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">k</span><span class="o">++</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">scases</span><span class="p">[</span><span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="p">]].</span><span class="nx">c</span><span class="p">.</span><span class="nf">sortkey</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">lockorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">lockorder</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
				<span class="nx">j</span> <span class="p">=</span> <span class="nx">k</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">lockorder</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">o</span>
	<span class="p">}</span>

	<span class="c1">// if debugSelect {}
</span><span class="c1"></span>
	<span class="c1">// lock all the channels involved in the select
</span><span class="c1"></span>	<span class="c1">// 锁定所有的channel按照上面的顺序
</span><span class="c1"></span>	<span class="nf">sellock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>

	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">gp</span>     <span class="o">*</span><span class="nx">g</span>
		<span class="nx">sg</span>     <span class="o">*</span><span class="nx">sudog</span>
		<span class="nx">c</span>      <span class="o">*</span><span class="nx">hchan</span>
		<span class="nx">k</span>      <span class="o">*</span><span class="nx">scase</span>
		<span class="nx">sglist</span> <span class="o">*</span><span class="nx">sudog</span>
		<span class="nx">sgnext</span> <span class="o">*</span><span class="nx">sudog</span>
		<span class="nx">qp</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
		<span class="nx">nextp</span>  <span class="o">**</span><span class="nx">sudog</span>
	<span class="p">)</span>

<span class="nx">loop</span><span class="p">:</span>
	<span class="c1">// pass 1 - look for something already waiting
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">dfli</span> <span class="kt">int</span>
	<span class="kd">var</span> <span class="nx">dfl</span> <span class="o">*</span><span class="nx">scase</span>
	<span class="kd">var</span> <span class="nx">casi</span> <span class="kt">int</span>
	<span class="kd">var</span> <span class="nx">cas</span> <span class="o">*</span><span class="nx">scase</span>
	<span class="kd">var</span> <span class="nx">recvOK</span> <span class="kt">bool</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">ncases</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">casi</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">pollorder</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nx">cas</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">scases</span><span class="p">[</span><span class="nx">casi</span><span class="p">]</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">c</span>

		<span class="k">switch</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">kind</span> <span class="p">{</span>
		
		<span class="k">case</span> <span class="nx">caseNil</span><span class="p">:</span>
			<span class="c1">// nil的case,忽略
</span><span class="c1"></span>			<span class="k">continue</span>
		
		<span class="k">case</span> <span class="nx">caseRecv</span><span class="p">:</span>
			<span class="c1">// 接收类型的case，判断sendq中有没有待发送的数据，如果有，就recv
</span><span class="c1"></span>			<span class="nx">sg</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">recv</span>
			<span class="p">}</span>
			<span class="c1">// 缓存里面有数据，跳转到bufrecv
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">bufrecv</span>
			<span class="p">}</span>
			<span class="c1">// 如果channel关闭了，则跳转到rclose
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">rclose</span>
			<span class="p">}</span>

		<span class="k">case</span> <span class="nx">caseSend</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
				<span class="nf">racereadpc</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">(),</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">chansendpc</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// 如果channel关闭了，则跳转到sclose
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">sclose</span>
			<span class="p">}</span>
			<span class="c1">// 看下待recv有没有数据，有的话，就跳转到发送
</span><span class="c1"></span>			<span class="nx">sg</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">send</span>
			<span class="p">}</span>
			<span class="c1">// 如果有缓存，切没有满，则跳转到bufsend
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">bufsend</span>
			<span class="p">}</span>

		<span class="k">case</span> <span class="nx">caseDefault</span><span class="p">:</span>
			<span class="c1">// 有default，更新case的索引和地址
</span><span class="c1"></span>			<span class="nx">dfli</span> <span class="p">=</span> <span class="nx">casi</span>
			<span class="nx">dfl</span> <span class="p">=</span> <span class="nx">cas</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//根据dfl判断是否有default，并且命中了，则直接跳转到default
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">dfl</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
		<span class="nx">casi</span> <span class="p">=</span> <span class="nx">dfli</span>
		<span class="nx">cas</span> <span class="p">=</span> <span class="nx">dfl</span>
		<span class="k">goto</span> <span class="nx">retc</span>
	<span class="p">}</span>

	<span class="c1">// pass 2 - enqueue on all chans
</span><span class="c1"></span>	<span class="c1">// 所有的case都要等待，并且没有default执行
</span><span class="c1"></span>	<span class="nx">gp</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gp.waiting != nil&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">nextp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span>
	<span class="c1">// 遍历所有的case， 然后将其放到g.waitlink中，
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">casei</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lockorder</span> <span class="p">{</span>
		<span class="nx">casi</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">casei</span><span class="p">)</span>
		<span class="nx">cas</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">scases</span><span class="p">[</span><span class="nx">casi</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">caseNil</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">c</span>
		<span class="nx">sg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="c1">// No stack splits between assigning elem and enqueuing
</span><span class="c1"></span>		<span class="c1">// sg on gp.waiting where copystack can find it.
</span><span class="c1"></span>		<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="p">}</span>
		<span class="nx">sg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
		<span class="c1">// Construct waiting list in lock order.
</span><span class="c1"></span>		<span class="o">*</span><span class="nx">nextp</span> <span class="p">=</span> <span class="nx">sg</span>
		<span class="nx">nextp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sg</span><span class="p">.</span><span class="nx">waitlink</span>
		<span class="c1">// 根据不同的cas类型，在recvq和sendq中插入这个sudog
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">kind</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">caseRecv</span><span class="p">:</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>

		<span class="k">case</span> <span class="nx">caseSend</span><span class="p">:</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 挂起等待唤醒
</span><span class="c1"></span>	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nf">gopark</span><span class="p">(</span><span class="nx">selparkcommit</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonSelect</span><span class="p">,</span> <span class="nx">traceEvGoBlockSelect</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

	<span class="nf">sellock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>

	<span class="nx">gp</span><span class="p">.</span><span class="nx">selectDone</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">sg</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">sudog</span><span class="p">)(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">param</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// pass 3 - dequeue from unsuccessful chans
</span><span class="c1"></span>	<span class="c1">// otherwise they stack up on quiet channels
</span><span class="c1"></span>	<span class="c1">// record the successful case, if any.
</span><span class="c1"></span>	<span class="c1">// We singly-linked up the SudoGs in lock order.
</span><span class="c1"></span>	<span class="nx">casi</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="nx">cas</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">sglist</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span>
	<span class="c1">// Clear all elem before unlinking from gp.waiting.
</span><span class="c1"></span>	<span class="c1">// 释放waiting队列前，需要清除数据
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">sg1</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span><span class="p">;</span> <span class="nx">sg1</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">sg1</span> <span class="p">=</span> <span class="nx">sg1</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">{</span>
		<span class="nx">sg1</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="nx">sg1</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">sg1</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">casei</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lockorder</span> <span class="p">{</span>
		<span class="nx">k</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">scases</span><span class="p">[</span><span class="nx">casei</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">k</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">caseNil</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sglist</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">k</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nx">sglist</span><span class="p">.</span><span class="nx">releasetime</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="nx">sglist</span> <span class="p">{</span>
			<span class="c1">// sg has already been dequeued by the G that woke us up.
</span><span class="c1"></span>			<span class="c1">// 确定这个sudog被唤醒的G出列
</span><span class="c1"></span>			<span class="nx">casi</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">casei</span><span class="p">)</span>
			<span class="nx">cas</span> <span class="p">=</span> <span class="nx">k</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 把其他还爱等待的sudog从waiting队列溢出
</span><span class="c1"></span>			<span class="nx">c</span> <span class="p">=</span> <span class="nx">k</span><span class="p">.</span><span class="nx">c</span>
			<span class="k">if</span> <span class="nx">k</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">caseSend</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeueSudoG</span><span class="p">(</span><span class="nx">sglist</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeueSudoG</span><span class="p">(</span><span class="nx">sglist</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">sgnext</span> <span class="p">=</span> <span class="nx">sglist</span><span class="p">.</span><span class="nx">waitlink</span>
		<span class="nx">sglist</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">sglist</span><span class="p">)</span>
		<span class="nx">sglist</span> <span class="p">=</span> <span class="nx">sgnext</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">cas</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// We can wake up with gp.param == nil (so cas == nil)
</span><span class="c1"></span>		<span class="c1">// when a channel involved in the select has been closed.
</span><span class="c1"></span>		<span class="c1">// It is easiest to loop and re-run the operation;
</span><span class="c1"></span>		<span class="c1">// we&#39;ll see that it&#39;s now closed.
</span><span class="c1"></span>		<span class="c1">// Maybe some day we can signal the close explicitly,
</span><span class="c1"></span>		<span class="c1">// but we&#39;d have to distinguish close-on-reader from close-on-writer.
</span><span class="c1"></span>		<span class="c1">// It&#39;s easiest not to duplicate the code and just recheck above.
</span><span class="c1"></span>		<span class="c1">// We know that something closed, and things never un-close,
</span><span class="c1"></span>		<span class="c1">// so we won&#39;t block again.
</span><span class="c1"></span>		<span class="c1">// 由于可以用gp.param == nil唤醒，所以cas为空，要再次循环判断下
</span><span class="c1"></span>		<span class="k">goto</span> <span class="nx">loop</span>
	<span class="p">}</span>

	<span class="nx">c</span> <span class="p">=</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">c</span>

	<span class="k">if</span> <span class="nx">debugSelect</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;wait-return: cas0=&#34;</span><span class="p">,</span> <span class="nx">cas0</span><span class="p">,</span> <span class="s">&#34; c=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34; cas=&#34;</span><span class="p">,</span> <span class="nx">cas</span><span class="p">,</span> <span class="s">&#34; kind=&#34;</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">kind</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">caseRecv</span> <span class="p">{</span>
		<span class="nx">recvOK</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">caseRecv</span> <span class="o">&amp;&amp;</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">raceWriteObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">chanrecvpc</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">caseSend</span> <span class="p">{</span>
			<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">chansendpc</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">caseRecv</span> <span class="o">&amp;&amp;</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">msanwrite</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">caseSend</span> <span class="p">{</span>
			<span class="nf">msanread</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">bufrecv</span><span class="p">:</span>
	<span class="c1">// can receive from buffer
</span><span class="c1"></span>	<span class="c1">// 从buffer中接收到了数据
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nf">raceWriteObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">chanrecvpc</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nf">raceacquire</span><span class="p">(</span><span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">))</span>
		<span class="nf">racerelease</span><span class="p">(</span><span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="o">&amp;&amp;</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">msanwrite</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">recvOK</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">qp</span> <span class="p">=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 开始拷贝
</span><span class="c1"></span>		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">--</span>
	<span class="c1">// 解锁当前case
</span><span class="c1"></span>	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">bufsend</span><span class="p">:</span>
	<span class="c1">// can send to buffer
</span><span class="c1"></span>	<span class="c1">// 可以发送给buffer
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">raceacquire</span><span class="p">(</span><span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">))</span>
		<span class="nf">racerelease</span><span class="p">(</span><span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">))</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">chansendpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">),</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>
	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">recv</span><span class="p">:</span>
	<span class="c1">// can receive from sleeping sender (sg)
</span><span class="c1"></span>	<span class="c1">// 可以从其他等待的sender中获取数据
</span><span class="c1"></span>	<span class="nf">recv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span> <span class="p">},</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">debugSelect</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;syncrecv: cas0=&#34;</span><span class="p">,</span> <span class="nx">cas0</span><span class="p">,</span> <span class="s">&#34; c=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">recvOK</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">rclose</span><span class="p">:</span>
	<span class="c1">// read at end of closed channel
</span><span class="c1"></span>	<span class="c1">// 读取到关闭的channel，解锁
</span><span class="c1"></span>	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="nx">recvOK</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 清除数据
</span><span class="c1"></span>		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">send</span><span class="p">:</span>
	<span class="c1">// can send to a sleeping receiver (sg)
</span><span class="c1"></span>	<span class="c1">// 将数据发送给一个等待的receiver
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">raceReadObjectPC</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">pc</span><span class="p">,</span> <span class="nx">chansendpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">elem</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span> <span class="p">},</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">debugSelect</span> <span class="p">{</span>
		<span class="nb">print</span><span class="p">(</span><span class="s">&#34;syncsend: cas0=&#34;</span><span class="p">,</span> <span class="nx">cas0</span><span class="p">,</span> <span class="s">&#34; c=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="nx">retc</span>

<span class="nx">retc</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">cas</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">cas</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">casi</span><span class="p">,</span> <span class="nx">recvOK</span>

<span class="nx">sclose</span><span class="p">:</span>
	<span class="c1">// send on closed channel
</span><span class="c1"></span>	<span class="c1">// 发送给一个关闭的channel，发生painc
</span><span class="c1"></span>	<span class="nf">selunlock</span><span class="p">(</span><span class="nx">scases</span><span class="p">,</span> <span class="nx">lockorder</span><span class="p">)</span>
	<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go-深入理解Buffer</title>
			<link>https://leonzyang.github.io/posts/buffer/</link>
			<pubDate>Sun, 27 Jun 2021 09:12:03 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/buffer/</guid>
			<description>深入理解Buffer Buffer是个可以供读写的可变长字节缓冲区
数据结构 type Buffer struct { // buf[off : len(buf)] 内容  buf []byte // contents are the bytes buf[off : len(buf)]  // 读取在&amp;amp;buf[off], 写入在&amp;amp;buf[len(buf)] 	off int // read at &amp;amp;buf[off], write at &amp;amp;buf[len(buf)] 	lastRead readOp // 最后一次读取操作 } const ( // 读取操作  opRead readOp = -1 // Any other read operation.  // 非读操作  opInvalid readOp = 0 // Non-read operation.  // 读取第一个字节 	opReadRune1 readOp = 1 // Read rune of size 1.</description>
			<content type="html"><![CDATA[<h2 id="深入理解buffer">深入理解Buffer</h2>
<p>Buffer是个可以供读写的可变长字节缓冲区</p>
<h3 id="数据结构">数据结构</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Buffer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// buf[off : len(buf)] 内容
</span><span class="c1"></span>    <span class="nx">buf</span>      <span class="p">[]</span><span class="kt">byte</span> <span class="c1">// contents are the bytes buf[off : len(buf)]
</span><span class="c1"></span>    <span class="c1">// 读取在&amp;buf[off], 写入在&amp;buf[len(buf)]
</span><span class="c1"></span>	<span class="nx">off</span>      <span class="kt">int</span>    <span class="c1">// read at &amp;buf[off], write at &amp;buf[len(buf)]
</span><span class="c1"></span>	<span class="nx">lastRead</span> <span class="nx">readOp</span> <span class="c1">// 最后一次读取操作
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">const</span> <span class="p">(</span>
    <span class="c1">// 读取操作
</span><span class="c1"></span>    <span class="nx">opRead</span>      <span class="nx">readOp</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// Any other read operation.
</span><span class="c1"></span>    <span class="c1">// 非读操作
</span><span class="c1"></span>    <span class="nx">opInvalid</span>   <span class="nx">readOp</span> <span class="p">=</span> <span class="mi">0</span>  <span class="c1">// Non-read operation.
</span><span class="c1"></span>    <span class="c1">// 读取第一个字节
</span><span class="c1"></span>	<span class="nx">opReadRune1</span> <span class="nx">readOp</span> <span class="p">=</span> <span class="mi">1</span>  <span class="c1">// Read rune of size 1.
</span><span class="c1"></span>	<span class="nx">opReadRune2</span> <span class="nx">readOp</span> <span class="p">=</span> <span class="mi">2</span>  <span class="c1">// Read rune of size 2.
</span><span class="c1"></span>	<span class="nx">opReadRune3</span> <span class="nx">readOp</span> <span class="p">=</span> <span class="mi">3</span>  <span class="c1">// Read rune of size 3.
</span><span class="c1"></span>	<span class="nx">opReadRune4</span> <span class="nx">readOp</span> <span class="p">=</span> <span class="mi">4</span>  <span class="c1">// Read rune of size 4.
</span><span class="c1"></span><span class="p">)</span>
</code></pre></div><h3 id="操作方法">操作方法</h3>
<h4 id="bytes">Bytes</h4>
<p>返回Buffer中未读取的字节</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">Bytes</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">b</span><span class="p">.</span><span class="nx">off</span><span class="p">:]</span> <span class="p">}</span>
</code></pre></div><h4 id="len">Len</h4>
<p>返回未读取的字节长度，b.Len() == len(b.Bytes())</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">off</span> <span class="p">}</span>
</code></pre></div><h4 id="cap">Cap</h4>
<p>Cap返回Buffer当前的容量长度</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">Cap</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><h4 id="truncate">Truncate</h4>
<p>Truncate 会丢弃除了未读的数据， 如果n==0 会丢弃所有数据</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">Truncate</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">lastRead</span> <span class="p">=</span> <span class="nx">opInvalid</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;bytes.Buffer: truncation out of range&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">b</span><span class="p">.</span><span class="nx">off</span><span class="o">+</span><span class="nx">n</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><h4 id="reset">Reset</h4>
<p>Reset清空缓存区数据</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">Reset</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">off</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">lastRead</span> <span class="p">=</span> <span class="nx">opInvalid</span>
<span class="p">}</span>
</code></pre></div><h4 id="grow">Grow</h4>
<p>Grow 会增加buffer的容量，n不得为负数</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">Grow</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;bytes.Buffer.Grow: negative count&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">m</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><h4 id="grow-1">grow</h4>
<p>grow增加buffer的容量，保证有n个字节可以写入</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">grow</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
    <span class="c1">// 如果buffer为空，执行reset获取空间
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">off</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
	<span class="p">}</span>

    <span class="c1">// 尝试快速扩容
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">tryGrowByReslice</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">i</span>
    <span class="p">}</span>
    <span class="c1">// smallBufferSize = 64
</span><span class="c1"></span>    <span class="c1">// buf为空，并且扩容的大小过小
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nx">smallBufferSize</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">smallBufferSize</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span>
    <span class="c1">// 如果buf长度+n小于等于buf容量的一半，这种只需向下滑动即可
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nx">c</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="nx">m</span> <span class="p">{</span>
		<span class="c1">// We can slide things down instead of allocating a new
</span><span class="c1"></span>		<span class="c1">// slice. We only need m+n &lt;= c to slide, but
</span><span class="c1"></span>		<span class="c1">// we instead let capacity get twice as large so we
</span><span class="c1"></span>        <span class="c1">// don&#39;t spend all our time copying.
</span><span class="c1"></span>        <span class="c1">// 丢弃已读的数据
</span><span class="c1"></span>		<span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">b</span><span class="p">.</span><span class="nx">off</span><span class="p">:])</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">c</span> <span class="p">&gt;</span> <span class="nx">maxInt</span><span class="o">-</span><span class="nx">c</span><span class="o">-</span><span class="nx">n</span> <span class="p">{</span>
        <span class="c1">// 要分配的数据太大了
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nx">ErrTooLarge</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 没有足够的空间，直接分配，分配后的大小是2*c + n
</span><span class="c1"></span>        <span class="nx">buf</span> <span class="o">:=</span> <span class="nf">makeSlice</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nx">c</span> <span class="o">+</span> <span class="nx">n</span><span class="p">)</span>
        <span class="c1">// 丢弃已读数据
</span><span class="c1"></span>		<span class="nb">copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">b</span><span class="p">.</span><span class="nx">off</span><span class="p">:])</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">buf</span>
	<span class="p">}</span>

    <span class="c1">// 重置off
</span><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">off</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">m</span><span class="o">+</span><span class="nx">n</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">m</span>
<span class="p">}</span>
</code></pre></div><h4 id="trygrowbyreslice">tryGrowByReslice</h4>
<p>tryGrowByReslice返回可写入字节的索引以及是否扩容成功，快速扩容方案</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">tryGrowByReslice</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果buf空闲的数量大于要扩容的大小
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">);</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span><span class="o">-</span><span class="nx">l</span> <span class="p">{</span>
        <span class="c1">// 快速扩容，reslice
</span><span class="c1"></span>		<span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">l</span><span class="o">+</span><span class="nx">n</span><span class="p">]</span>
		<span class="k">return</span> <span class="nx">l</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></div><h4 id="write">Write</h4>
<p>Write写入数据到buffer中，必要情况下会扩容buffer，如果err == nil，n == len(p)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">lastRead</span> <span class="p">=</span> <span class="nx">opInvalid</span>
	<span class="nx">m</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">tryGrowByReslice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">m</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">m</span><span class="p">:],</span> <span class="nx">p</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="readfrom">ReadFrom</h4>
<p>ReadFrom从r中读取直到EOF，并append到buffer中，如果需要，会扩容buffer。返回的n是读取的字节数，除了EOF的错误都会fan&rsquo;hui</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">ReadFrom</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">lastRead</span> <span class="p">=</span> <span class="nx">opInvalid</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">i</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nx">MinRead</span><span class="p">)</span> <span class="c1">// MinRead = 512
</span><span class="c1"></span>		<span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">m</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">)])</span>
		<span class="k">if</span> <span class="nx">m</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="nx">errNegativeRead</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">b</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">i</span><span class="o">+</span><span class="nx">m</span><span class="p">]</span>
		<span class="nx">n</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">e</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span> <span class="c1">// e is EOF, so return nil explicitly
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">e</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h4 id="writeto">WriteTo</h4>
<p>WriteTo 写入数据到w中，直接buffer中数据耗尽，返回写入的字节数和写入过程中遇到的错误</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">WriteTo</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">lastRead</span> <span class="p">=</span> <span class="nx">opInvalid</span>
	<span class="k">if</span> <span class="nx">nBytes</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Len</span><span class="p">();</span> <span class="nx">nBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">b</span><span class="p">.</span><span class="nx">off</span><span class="p">:])</span>
		<span class="k">if</span> <span class="nx">m</span> <span class="p">&gt;</span> <span class="nx">nBytes</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;bytes.Buffer.WriteTo: invalid Write count&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">off</span> <span class="o">+=</span> <span class="nx">m</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">e</span>
		<span class="p">}</span>
		<span class="c1">// all bytes should have been written, by definition of
</span><span class="c1"></span>		<span class="c1">// Write method in io.Writer
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">m</span> <span class="o">!=</span> <span class="nx">nBytes</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">io</span><span class="p">.</span><span class="nx">ErrShortWrite</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// Buffer 已经写完，reset
</span><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><h4 id="read">Read</h4>
<p>Read会读取下n个字节直接buffer耗尽，返回读取的字节和读取遇到的错误，如果buffer为空，错误返回EOF</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">lastRead</span> <span class="p">=</span> <span class="nx">opInvalid</span>
	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// Buffer is empty, reset to recover space.
</span><span class="c1"></span>		<span class="nx">b</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="p">=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">b</span><span class="p">.</span><span class="nx">off</span><span class="p">:])</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">off</span> <span class="o">+=</span> <span class="nx">n</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">lastRead</span> <span class="p">=</span> <span class="nx">opRead</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h4 id="next">Next</h4>
<p>Next返回下n个字节数据，如果buffer未读字节数小于n，则返回整个buffer，</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">Next</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">lastRead</span> <span class="p">=</span> <span class="nx">opInvalid</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">m</span>
	<span class="p">}</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">b</span><span class="p">.</span><span class="nx">off</span> <span class="p">:</span> <span class="nx">b</span><span class="p">.</span><span class="nx">off</span><span class="o">+</span><span class="nx">n</span><span class="p">]</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">off</span> <span class="o">+=</span> <span class="nx">n</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">lastRead</span> <span class="p">=</span> <span class="nx">opRead</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">data</span>
<span class="p">}</span>
</code></pre></div><h4 id="readrune">ReadRune</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span> <span class="nf">ReadRune</span><span class="p">()</span> <span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// Buffer is empty, reset to recover space.
</span><span class="c1"></span>		<span class="nx">b</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span>
	<span class="p">}</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">b</span><span class="p">.</span><span class="nx">off</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">c</span> <span class="p">&lt;</span> <span class="nx">utf8</span><span class="p">.</span><span class="nx">RuneSelf</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">off</span><span class="o">++</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">lastRead</span> <span class="p">=</span> <span class="nx">opReadRune1</span>
		<span class="k">return</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">r</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">utf8</span><span class="p">.</span><span class="nf">DecodeRune</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="nx">b</span><span class="p">.</span><span class="nx">off</span><span class="p">:])</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">off</span> <span class="o">+=</span> <span class="nx">n</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">lastRead</span> <span class="p">=</span> <span class="nf">readOp</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h3 id="总结">总结</h3>
<p>buffer提供了可扩容的缓冲池，如果数据比较大，我们已经提前申请好相应的buffer，以免buffer多次扩容。</p>
]]></content>
		</item>
		
		<item>
			<title>Go-深入理解unsafe</title>
			<link>https://leonzyang.github.io/posts/unsafe/</link>
			<pubDate>Sun, 27 Jun 2021 08:52:34 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/unsafe/</guid>
			<description>深入理解unsafe 指针 Go里面为什么会有指针？这里我们看个例子，例子来源于https://go101.org/article/pointer.html
func add(i int) { i+= i } func main(){ a := 1 add(a) fmt.Println(a) } 上面的代码运行会输出什么呢？ 大家肯定都知道，那就是1，因为go里面是值传递，但是如果我们想真正实现加i的功能要怎么做? 那就需要指针
我们把add这个函数改造下,那么这次输出什么呢？ 那么会输出什么？答案是2，因为我们使用的指针传参，并且用*i+=*i将指针所指向的值做加i的操作
func add(i *int) { *i+= *i } func main(){ a := 1 add(&amp;amp;a) fmt.Println(a) } 那我们再改一下,那么这次会输出什么呢？
func add(i *int) { *i+= *i i = nil } func main(){ a := 1 add(&amp;amp;a) fmt.Println(a) } 输出还是2吗？ 那我们执行下， 还真是2，这是为什么？因为函数是值传递，i和&amp;amp;a指向的是同一块地址，当把*i的值改变时，那么a对应的值也会改变，但是如果只是把i的设为nil，只是修改了指向，不会影响a本身的值。
Unsafe Go里面使用指针是相对安全，不过也有诸多限制，比如类型转换， 这时unsafe就派上用场了。unsafe提供了一些非安全的指针操作，可以让我们绕过系统进行操作
Pointer // ArbitraryType代表任意类型 type ArbitraryType int // 1.</description>
			<content type="html"><![CDATA[<h2 id="深入理解unsafe">深入理解unsafe</h2>
<h3 id="指针">指针</h3>
<p>Go里面为什么会有指针？这里我们看个例子，例子来源于https://go101.org/article/pointer.html</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">i</span><span class="o">+=</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="nf">add</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>上面的代码运行会输出什么呢？ 大家肯定都知道，那就是1，因为go里面是值传递，但是如果我们想真正实现加i的功能要怎么做? 那就需要指针</p>
<p>我们把add这个函数改造下,那么这次输出什么呢？ 那么会输出什么？答案是2，因为我们使用的指针传参，并且用<code>*i+=*i</code>将指针所指向的值做加i的操作</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">i</span><span class="o">+=</span> <span class="o">*</span><span class="nx">i</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>那我们再改一下,那么这次会输出什么呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">i</span><span class="o">+=</span> <span class="o">*</span><span class="nx">i</span>
    <span class="nx">i</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>输出还是2吗？ 那我们执行下， 还真是2，这是为什么？因为函数是值传递，i和&amp;a指向的是同一块地址，当把*i的值改变时，那么a对应的值也会改变，但是如果只是把i的设为nil，只是修改了指向，不会影响a本身的值。</p>
<h3 id="unsafe">Unsafe</h3>
<p>Go里面使用指针是相对安全，不过也有诸多限制，比如类型转换， 这时unsafe就派上用场了。unsafe提供了一些非安全的指针操作，可以让我们绕过系统进行操作</p>
<p><img src="posts/images/unsafe.png" alt="转换"></p>
<h4 id="pointer">Pointer</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ArbitraryType代表任意类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ArbitraryType</span> <span class="kt">int</span>
<span class="c1">// 1. 任何类型的指针都可以转为Pointer
</span><span class="c1">// 2. Pointer可以转换为任何类型的指针
</span><span class="c1">// 3. uintptr 可以转换为Pointer
</span><span class="c1">// 4. Pointer 可以转换为uintptr
</span><span class="c1"></span>

<span class="kd">type</span> <span class="nx">Pointer</span> <span class="o">*</span><span class="nx">ArbitraryType</span>

<span class="c1">// 获取任意类型的，返回时x类型大小的描述符，不是具体引用的内存
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Sizeof</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ArbitraryType</span><span class="p">)</span> <span class="kt">uintptr</span>

<span class="c1">// 返回结构体中字段的offset
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Offsetof</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ArbitraryType</span><span class="p">)</span> <span class="kt">uintptr</span>

<span class="c1">// 返回变量对齐字段的数量
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Alignof</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ArbitraryType</span><span class="p">)</span> <span class="kt">uintptr</span>
</code></pre></div><h4 id="uintptr">uintptr</h4>
<p>uintptr没有指针的语义，所以uintptr所指向的对象会被GC回收，但是pointer有指针语义，所以它指向的对象在被引用的时候不会被GC回收</p>
<h3 id="使用">使用</h3>
<p>下面我们用几个例子简单说明：</p>
<h4 id="slice">slice</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
	<span class="c1">// 根据偏移量，获取到slice的长度
</span><span class="c1"></span>	<span class="nx">l</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">))</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="mi">0</span><span class="p">))))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">l</span><span class="p">)</span>

	<span class="c1">// 获取slice的cap
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="mi">0</span><span class="p">))))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">c</span><span class="p">)</span>
</code></pre></div><h4 id="map">map</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">[</span><span class="s">&#34;a&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">r</span><span class="p">[</span><span class="s">&#34;b&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">r</span><span class="p">[</span><span class="s">&#34;c&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">3</span>

	<span class="c1">// map的第一个字段是count，由于map都是指针，所以需要两次解引用
</span><span class="c1"></span>	<span class="nx">count</span> <span class="o">:=</span> <span class="o">**</span><span class="p">(</span><span class="o">**</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">r</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
</code></pre></div><h4 id="struct">struct</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Demo</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
	<span class="nx">age</span>  <span class="kt">int</span>    <span class="s">`json:&#34;age&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kd">var</span> <span class="nx">d</span>  <span class="p">=</span> <span class="nx">Demo</span><span class="p">{</span><span class="s">&#34;leon&#34;</span><span class="p">,</span> <span class="mi">21</span><span class="p">}</span>
	<span class="nx">dd</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 获取第一个字段，offset是0
</span><span class="c1"></span>	<span class="nx">p</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">dd</span><span class="p">)</span> <span class="o">+</span> <span class="nx">v</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span>

	<span class="c1">// 获取age字段，string占用2个字节，所以offset是16
</span><span class="c1"></span>	<span class="nx">age</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">dd</span><span class="p">)</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">16</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">age</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h4 id="转换">转换</h4>
<p>string和bytes转换</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">string2Slice</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">stringHeader</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">StringHeader</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">))</span>

	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">{</span>
		<span class="nx">Data</span><span class="p">:</span> <span class="nx">stringHeader</span><span class="p">.</span><span class="nx">Data</span><span class="p">,</span>
		<span class="nx">Len</span><span class="p">:</span>  <span class="nx">stringHeader</span><span class="p">.</span><span class="nx">Len</span><span class="p">,</span>
		<span class="nx">Cap</span><span class="p">:</span>  <span class="nx">stringHeader</span><span class="p">.</span><span class="nx">Len</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bytes2String</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">sliceHeader</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))</span>

	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">StringHeader</span><span class="p">{</span>
		<span class="nx">Data</span><span class="p">:</span> <span class="nx">sliceHeader</span><span class="p">.</span><span class="nx">Data</span><span class="p">,</span>
		<span class="nx">Len</span><span class="p">:</span>  <span class="nx">sliceHeader</span><span class="p">.</span><span class="nx">Len</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go Module原理</title>
			<link>https://leonzyang.github.io/posts/gomdule/</link>
			<pubDate>Mon, 19 Apr 2021 20:45:00 +0800</pubDate>
			
			<guid>https://leonzyang.github.io/posts/gomdule/</guid>
			<description>Go Module原理 Go
Semantic Version 版本号遵循SemVer规范(https://semver.org/)
最小版本选择(Minimal Version Selection) Go 1.11之前 GOROOT GOPATH
GOPATH ├── bin //编译生成的二进制文件 ├── pkg //预编译文件，以加快程序的后续编译速度 |── src //所有源代码 ├── github.com ... ... 缺点：
 缺少版本管理  go1.5 vendor go.mod go1.11 已经有go mod，只是默认关闭，在go1.13 go mod将作为默认管理方式开启
module require replace replace可以指向一个repo，也可以指向本地
exclude 排除某个版本，实际中很少使用
GOPROXY 地址	简介 https://goproxy.io	一个全球代理为 Go 模块而生 https://mirrors.aliyun.com/goproxy/	阿里镜像代理 https://goproxy.cn	七牛云赞助支持的
go.sum 用于记录每个依赖包的哈希值（SHA-256 算法） 正常情况下，每个依赖包版本会包含两条记录，第一条记录为该依赖包版本整体（所有文件）的哈希值，第二条记录仅表示该依赖包版本中 go.mod 文件的哈希值，如果该依赖包版本没有 go.mod 文件，则只有第一条记录
go list -m all 查看当前项目最终所使用的 module 版本 go list -u -m all 查看依赖的新版本 go get -u .</description>
			<content type="html"><![CDATA[<h3 id="go-module原理">Go Module原理</h3>
<p>Go</p>
<h4 id="semantic-version">Semantic Version</h4>
<p>版本号遵循<code>SemVer规范</code>(<a href="https://semver.org/">https://semver.org/</a>)</p>
<p><img src="/posts/images/semantic_versioning.png" alt="semantic_version"></p>
<h4 id="最小版本选择minimal-version-selection">最小版本选择(Minimal Version Selection)</h4>
<p><img src="/posts/images/buildlist.svg" alt="semantic_version"></p>
<h3 id="go-111之前">Go 1.11之前</h3>
<p>GOROOT
GOPATH</p>
<pre><code>GOPATH
├── bin              //编译生成的二进制文件
├── pkg              //预编译文件，以加快程序的后续编译速度
|── src              //所有源代码
    ├── github.com
    ...
    ...
</code></pre><p>缺点：</p>
<ul>
<li>缺少版本管理</li>
</ul>
<h4 id="go15-vendor">go1.5 <code>vendor</code></h4>
<h3 id="gomod">go.mod</h3>
<p>go1.11 已经有go mod，只是默认关闭，在go1.13 go mod将作为默认管理方式开启</p>
<h4 id="module">module</h4>
<h4 id="require">require</h4>
<h4 id="replace">replace</h4>
<p>replace可以指向一个repo，也可以指向本地</p>
<h4 id="exclude">exclude</h4>
<p>排除某个版本，实际中很少使用</p>
<h4 id="goproxy">GOPROXY</h4>
<p>地址	简介
<a href="https://goproxy.io">https://goproxy.io</a>	一个全球代理为 Go 模块而生
<a href="https://mirrors.aliyun.com/goproxy/">https://mirrors.aliyun.com/goproxy/</a>	阿里镜像代理
<a href="https://goproxy.cn">https://goproxy.cn</a>	七牛云赞助支持的</p>
<h3 id="gosum">go.sum</h3>
<p>用于记录每个依赖包的哈希值（SHA-256 算法）
正常情况下，每个依赖包版本会包含两条记录，第一条记录为该依赖包版本整体（所有文件）的哈希值，第二条记录仅表示该依赖包版本中 go.mod 文件的哈希值，如果该依赖包版本没有 go.mod 文件，则只有第一条记录</p>
<p><code>go list -m all</code> 查看当前项目最终所使用的 module 版本
<code>go list -u -m all</code> 查看依赖的新版本
<code>go get -u ./...</code> 更新所有依赖到最新版
<code>go get -u=patch ./...</code> 更新所有依赖到最新的 patch 版本
<code>go mod tidy</code> 清理 go.mod/go.sum 中不在需要的 module
<code>go mod vendor</code> 创建 vendor 依赖目录，这时为了与之前做兼容，后面在执行 go test/build 之类的命令时，可以加上 -mod=vendor 这个 build flag 声明使用 vendor 里面的依赖，这样 go mod 就不会再去 $GOPATH/pkg/mod 里面去找。</p>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://golang.org/ref/mod">https://golang.org/ref/mod</a></li>
<li><a href="https://xuanwo.io/2019/05/27/go-modules/">https://xuanwo.io/2019/05/27/go-modules/</a></li>
<li><a href="https://duyanghao.github.io/golang-module/">https://duyanghao.github.io/golang-module/</a></li>
</ul>
]]></content>
		</item>
		
	</channel>
</rss>
