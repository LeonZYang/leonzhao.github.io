<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algos on LeonZhao Home</title>
    <link>https://leonzyang.github.io/algo/</link>
    <description>Recent content in Algos on LeonZhao Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sat, 08 May 2021 15:11:03 +0800</lastBuildDate><atom:link href="https://leonzyang.github.io/algo/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>常用五大算法-回溯算法</title>
      <link>https://leonzyang.github.io/algo/backtrack/</link>
      <pubDate>Sat, 08 May 2021 15:11:03 +0800</pubDate>
      
      <guid>https://leonzyang.github.io/algo/backtrack/</guid>
      <description>回溯算法 回溯算法是一个枚举过程，在搜索中寻找问题解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
框架 res = [] def backtrack(当前路径，选择列表): if 满足条件: res.append(path) return for 值 in 选择列表: 加入到当前路径 backtrack(当前路径，选择条件) 从当前路径弹出 经典题目 全排列 leetcode 46. 全排列
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2： 输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3： 输入：nums = [1] 输出：[[1]] 提示： 1 &amp;lt;= nums.length &amp;lt;= 6 -10 &amp;lt;= nums[i] &amp;lt;= 10 nums 中的所有整数 互不相同 图形展示 这张图取自网络
解答 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: def backtrack(nums, n, used, path, ret): if len(path) == n: ret.</description>
    </item>
    
    <item>
      <title>排序算法-希尔排序</title>
      <link>https://leonzyang.github.io/algo/sort/shell_sort/</link>
      <pubDate>Sun, 18 Apr 2021 17:49:49 +0800</pubDate>
      
      <guid>https://leonzyang.github.io/algo/sort/shell_sort/</guid>
      <description> 时间复杂度O(nlogN) 不稳定排序   def shell_sort(arr): n = len(arr) gap = n // 2 while gap &amp;gt; 0: for i in range(gap, n): j = i while j &amp;gt; 0: if arr[j] &amp;gt; arr[j-gap]: arr[j], arr[j-gap] = arr[j-gap], arr[j] j-= gap else: break gap /= 2 </description>
    </item>
    
    <item>
      <title>排序算法-归并排序</title>
      <link>https://leonzyang.github.io/algo/sort/merge_sort/</link>
      <pubDate>Sun, 18 Apr 2021 17:49:40 +0800</pubDate>
      
      <guid>https://leonzyang.github.io/algo/sort/merge_sort/</guid>
      <description> 时间复杂度O(nlogN) 不稳定排序   def merge(arrA, arrB): arr = [] i,j = 0,0 while i &amp;lt; len(arrA) and j &amp;lt; len(arrB): if arrA[i] &amp;lt; arrB[j]: arr.append(arrA[i]) i+=1 else: arr.append(arrB[j]) j+=1 for start in range(i, len(arrA)): arr.append(arrA[start]) for start in range(j, len(arrB)): arr.append(arrB[start]) return arr def merge_sort(arr): if len(arr) &amp;lt;= 1: return mid = len(arr) // 2 arrA = merge_sort(arr[:mid]) arrB = merge_sort(arr[mid:]) return merge(arrA, arrB) </description>
    </item>
    
    <item>
      <title>排序算法-堆排序</title>
      <link>https://leonzyang.github.io/algo/sort/heap_sort/</link>
      <pubDate>Sun, 18 Apr 2021 16:11:39 +0800</pubDate>
      
      <guid>https://leonzyang.github.io/algo/sort/heap_sort/</guid>
      <description> 时间复杂度O(nlogN) 不稳定排序   def heapify(tree, n, i): if i &amp;gt;= n: return max_index = i left_child = 2*i + 1 right_child = left_child + 1 if left_child &amp;lt; n and tree[max_index] &amp;lt; tree[left_child]: max_index = left_child if right_child &amp;lt; n and tree[max_index] &amp;lt; tree[right_child]: max_index = right_child if max_index != i: tree[i], tree[max_index] = tree[max_index], tree[i] heapify(tree, n, max_index) def build_heap(arr): last_node = len(arr) - 1 parent = (last_node - 1) // 2 for i in range(parent, -1, -1): heapify(arr, last_node, i) def heap_sort(arr): build_heap(arr) for i in range(1, len(arr)): arr[0], arr[len(arr)-i] = arr[len(arr)-i], arr[0] heapify(arr, len(arr)-i-1, 0) </description>
    </item>
    
    <item>
      <title>排序算法-插入排序</title>
      <link>https://leonzyang.github.io/algo/sort/insert_sort/</link>
      <pubDate>Sun, 18 Apr 2021 16:11:33 +0800</pubDate>
      
      <guid>https://leonzyang.github.io/algo/sort/insert_sort/</guid>
      <description> 时间复杂度O(n2) 稳定排序   def insert_sort(arr): if len(arr) &amp;lt;= 1: return for i in range(1, len(arr)): j = i while j &amp;gt; 0: if arr[j] &amp;lt; arr[j - 1]: arr[j], arr[j - 1] = arr[j - 1], arr[j] j -= 1 else: break </description>
    </item>
    
    <item>
      <title>排序算法-选择排序</title>
      <link>https://leonzyang.github.io/algo/sort/select_sort/</link>
      <pubDate>Sun, 18 Apr 2021 16:11:24 +0800</pubDate>
      
      <guid>https://leonzyang.github.io/algo/sort/select_sort/</guid>
      <description> 时间复杂度O(n2) 稳定排序   def select_sort(arr): for i in range(len(arr)): min_index = i for j in range(j+1, len(arr)): if arr[i] &amp;lt; arr[j]: min_index = j if min_index != i: arr[i], arr[min_index] = arr[min_index], arr[i] </description>
    </item>
    
    <item>
      <title>排序算法-快速排序</title>
      <link>https://leonzyang.github.io/algo/sort/quick_sort/</link>
      <pubDate>Sun, 18 Apr 2021 16:11:15 +0800</pubDate>
      
      <guid>https://leonzyang.github.io/algo/sort/quick_sort/</guid>
      <description> 时间复杂度O(nlogN) 不稳定排序   def quick_sort(arr, low, high): if low &amp;lt; high: m = partition(arr, low, high) quick_sort(arr, low, m) quick_sort(arr, m+1， high) def partition(arr, left, right): priv = arr[left] while left &amp;lt; right: while left &amp;lt; right and arr[right] &amp;gt; priv: right -= 1 arr[left] = arr[right] while left &amp;lt; right and arr[left] &amp;gt;= priv: left += 1 arr[right] = arr[left] arr[left] = priv return left </description>
    </item>
    
    <item>
      <title>排序算法-冒泡排序</title>
      <link>https://leonzyang.github.io/algo/sort/bubble_sort/</link>
      <pubDate>Sun, 18 Apr 2021 16:11:03 +0800</pubDate>
      
      <guid>https://leonzyang.github.io/algo/sort/bubble_sort/</guid>
      <description> 时间复杂度O(n2) 稳定排序   def bubble_sort(arr): n = len(arr) for i in range(n): for j in range(n-i-1, i, -1): if arr[j] &amp;lt; arr[j-1]: arr[j-1], arr[j] = arr[j], arr[j-1] </description>
    </item>
    
  </channel>
</rss>
