<!DOCTYPE html>
<html lang="zh-cn">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="常见五大算法-递归">
<meta itemprop="description" content="递归 在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。实际上，递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在。
递归伪代码
def recursion(参数): if 结束条件: return 处理问题 recursion(缩小参数) 汉诺塔问题 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制: (1) 每次只能移动一个盘子; (2) 盘子只能从柱子顶端滑出移到下一根柱子; (3) 盘子只能叠在比它大的盘子上。 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。 你需要原地修改栈。 示例1: 输入：A = [2, 1, 0], B = [], C = [] 输出：C = [2, 1, 0] 示例2: 输入：A = [1, 0], B = [], C = [] 输出：C = [1, 0] 提示: A中盘子的数目不大于14个。 n = 1 时，直接把盘子从 A 移到 C； n &gt; 1 时， 1.">
<meta itemprop="datePublished" content="2021-05-10T21:33:54+08:00" />
<meta itemprop="dateModified" content="2021-05-10T21:33:54+08:00" />
<meta itemprop="wordCount" content="509">



<meta itemprop="keywords" content="" />
<meta property="og:title" content="常见五大算法-递归" />
<meta property="og:description" content="递归 在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。实际上，递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在。
递归伪代码
def recursion(参数): if 结束条件: return 处理问题 recursion(缩小参数) 汉诺塔问题 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制: (1) 每次只能移动一个盘子; (2) 盘子只能从柱子顶端滑出移到下一根柱子; (3) 盘子只能叠在比它大的盘子上。 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。 你需要原地修改栈。 示例1: 输入：A = [2, 1, 0], B = [], C = [] 输出：C = [2, 1, 0] 示例2: 输入：A = [1, 0], B = [], C = [] 输出：C = [1, 0] 提示: A中盘子的数目不大于14个。 n = 1 时，直接把盘子从 A 移到 C； n &gt; 1 时， 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://leonzyang.github.io/algo/recursion/" />
<meta property="article:published_time" content="2021-05-10T21:33:54+08:00" />
<meta property="article:modified_time" content="2021-05-10T21:33:54+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="常见五大算法-递归"/>
<meta name="twitter:description" content="递归 在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。实际上，递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在。
递归伪代码
def recursion(参数): if 结束条件: return 处理问题 recursion(缩小参数) 汉诺塔问题 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制: (1) 每次只能移动一个盘子; (2) 盘子只能从柱子顶端滑出移到下一根柱子; (3) 盘子只能叠在比它大的盘子上。 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。 你需要原地修改栈。 示例1: 输入：A = [2, 1, 0], B = [], C = [] 输出：C = [2, 1, 0] 示例2: 输入：A = [1, 0], B = [], C = [] 输出：C = [1, 0] 提示: A中盘子的数目不大于14个。 n = 1 时，直接把盘子从 A 移到 C； n &gt; 1 时， 1."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>常见五大算法-递归</title>
	<link rel="stylesheet" href="https://leonzyang.github.io/css/style.min.eac77496566fd7d5768fd650ddb0b2b181ca6a2d7c5fdd6fe6b8ba4bf47e566f.css" integrity="sha256-6sd0llZv19V2j9ZQ3bCysYHKai18X91v5ri6S/R+Vm8=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://leonzyang.github.io">LeonZhao Home</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://leonzyang.github.io/posts/">博客</a>
				<a href="https://leonzyang.github.io/datastruct/">数据结构</a>
				<a href="https://leonzyang.github.io/algo/">算法</a>
				<a href="https://leonzyang.github.io/about-hugo/">关于</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://leonzyang.github.io/posts/">博客</a></li>
			<li><a href="https://leonzyang.github.io/datastruct/">数据结构</a></li>
			<li><a href="https://leonzyang.github.io/algo/">算法</a></li>
			<li><a href="https://leonzyang.github.io/about-hugo/">关于</a></li>
		</ul>
	</div>


	<main class="site-main section-inner thin animated fadeIn faster">
		<h1>常见五大算法-递归</h1>
		<div class="content">
			<h2 id="递归">递归<a href="#递归" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。实际上，递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在。</p>
<p>递归伪代码</p>
<pre><code>def recursion(参数):
    if 结束条件:
        return

    处理问题
    recursion(缩小参数)
</code></pre><h3 id="汉诺塔问题">汉诺塔问题<a href="#汉诺塔问题" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<pre><code>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。

你需要原地修改栈。

示例1:

 输入：A = [2, 1, 0], B = [], C = []
 输出：C = [2, 1, 0]
示例2:

 输入：A = [1, 0], B = [], C = []
 输出：C = [1, 0]
提示:

A中盘子的数目不大于14个。
</code></pre><p><img src="/algo/images/hanota.jpg" alt="汉诺塔"></p>
<p>n = 1 时，直接把盘子从 A 移到 C；
n &gt; 1 时，
1. 先把上面 n - 1 个盘子从 A 移到 B；
2. 再将最大的盘子从 A 移到 C；
3. 再将 B 上 n - 1 个盘子从 B 移到 C</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hanota</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">B</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">C</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s2">&#34;&#34;&#34;
</span><span class="s2">        Do not return anything, modify C in-place instead.
</span><span class="s2">        &#34;&#34;&#34;</span>

        <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">C</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">A</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">return</span>

            <span class="c1"># 将n-1个盘子从A借助C移动到B上</span>
            <span class="n">move</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
            <span class="c1"># 将A中最后一个盘子放到A中</span>
            <span class="n">C</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">A</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1"># 将n-1个盘子从B借助A放到C上</span>
            <span class="n">move</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">move</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>

</code></pre></div><h3 id="24-两两交换链表中的节点">24. 两两·交换链表中的节点<a href="#24-两两交换链表中的节点" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<pre><code>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

 

示例 1：


输入：head = [1,2,3,4]
输出：[2,1,4,3]
示例 2：

输入：head = []
输出：[]
示例 3：

输入：head = [1]
输出：[1]
 

提示：

链表中节点的数目在范围 [0, 100] 内
0 &lt;= Node.val &lt;= 100
</code></pre><p><img src="/algo/images/swap_ex1.jpg" alt="swap_nodes-in-pairs"></p>
<h4 id="解题思路">解题思路<a href="#解题思路" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>链表很多的问题都会用到递归算法，这个也不例外，既然题目要求我们，我们可以把问题进行拆分，先将前两个节点进行交换，然后递归的将剩余的节点进行反转</p>
<h4 id="答案">答案<a href="#答案" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, val=0, next=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.next = next</span>

<span class="c1"># Definition for singly-linked list.</span>
<span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">swapPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="c1"># 判断是否有两个合法的节点</span>
        <span class="k">if</span> <span class="n">head</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">head</span>
        <span class="c1"># 头结点</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span>
        <span class="c1"># 下一个节点</span>
        <span class="n">nextNode</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
        <span class="c1"># 剩余节点</span>
        <span class="n">otherNode</span> <span class="o">=</span> <span class="n">nextNode</span><span class="o">.</span><span class="n">next</span>
        <span class="c1"># 进行节点交换</span>
        <span class="n">nextNode</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span>
        <span class="c1"># 反转剩余节点</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">swapPairs</span><span class="p">(</span><span class="n">otherNode</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">nextNode</span>
        
</code></pre></div><h3 id="669-修剪二叉搜索树">669. 修剪二叉搜索树<a href="#669-修剪二叉搜索树" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<pre><code>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

提示：

树中节点数在范围 [1, 104] 内
0 &lt;= Node.val &lt;= 104
树中每个节点的值都是唯一的
题目数据保证输入是一棵有效的二叉搜索树
0 &lt;= low &lt;= high &lt;= 104
</code></pre><p><code>示例1</code></p>
<p><img src="/algo/images/trim1.jpg" alt="trim1"></p>
<pre><code>输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
</code></pre><p><code>示例2</code></p>
<p><img src="/algo/images/trim2.jpg" alt="trim2"></p>
<pre><code>输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]
</code></pre><pre><code>示例 3：

输入：root = [1], low = 1, high = 2
输出：[1]

示例 4：`

输入：root = [1,null,2], low = 1, high = 3
输出：[1,null,2]
示例 5：

输入：root = [1,null,2], low = 2, high = 4
输出：[2]
</code></pre><h4 id="答案-1">答案<a href="#答案-1" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>


<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">trimBST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">low</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>

        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">:</span>
            <span class="c1"># 如果当前节点小于low，那根据二叉搜索树特性，那么root的left节点肯定都小于low，不符合条件，要舍弃root和root.left，直接将root的right节点变成root</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>
            <span class="c1"># 进行后面的节点判断</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trimBST</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">:</span>
            <span class="c1"># 反之同理，将root和root.right舍弃</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trimBST</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>

        <span class="c1"># 当前root.val在区间[low, high]中，分别对left和right节点进行判断</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trimBST</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trimBST</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
</code></pre></div><h3 id="链表反转">链表反转<a href="#链表反转" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<pre><code>输入：1-&gt;2-&gt;3-&gt;4-&gt;5
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1
</code></pre><div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># class Node:</span>
<span class="c1">#     def __init__(self, val):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.next = None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">recursion</span><span class="p">(</span><span class="n">prev</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">cur</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cur</span><span class="p">:</span>
                <span class="c1"># 返回prev节点</span>
                <span class="k">return</span> <span class="n">prev</span>
            <span class="n">nextNode</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">next</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span>
            <span class="k">return</span> <span class="n">recursion</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">nextNode</span><span class="p">)</span>

        <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span>

        <span class="k">return</span> <span class="n">recursion</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">cur</span><span class="p">)</span>
</code></pre></div>
		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2021 <a href="https://leonzyang.github.io">LeonZhao</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://leonzyang.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://leonzyang.github.io/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js" integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin="anonymous"></script>
	

</body>

</html>
